From f6306578e2b84ea7db9489f1866d25e171b6571e Mon Sep 17 00:00:00 2001
From: Robby Cai <R63905@freescale.com>
Date: Wed, 27 Jan 2010 12:19:44 +0800
Subject: [PATCH] ENGR00117747-2 MX28 Add I2C Bus driver support

Add platform resource and actual driver support for I2C

Signed-off-by: Robby Cai <R63905@freescale.com>
---
 arch/arm/mach-mx28/device.c                |  103 +++++
 arch/arm/mach-mx28/include/mach/regs-i2c.h |  498 +++++++++++++++++++++++++
 arch/arm/mach-mx28/mx28evk_pins.c          |   19 +
 arch/arm/plat-mxs/device.c                 |   37 ++
 arch/arm/plat-mxs/include/mach/device.h    |    4 +
 drivers/i2c/busses/Kconfig                 |   34 ++
 drivers/i2c/busses/Makefile                |    1 +
 drivers/i2c/busses/i2c-mxs.c               |  560 ++++++++++++++++++++--------
 drivers/i2c/busses/i2c-mxs.h               |   41 ++
 9 files changed, 1136 insertions(+), 161 deletions(-)

diff --git a/arch/arm/mach-mx28/device.c b/arch/arm/mach-mx28/device.c
index 68a7931..34d5603 100644
--- a/arch/arm/mach-mx28/device.c
+++ b/arch/arm/mach-mx28/device.c
@@ -119,6 +119,108 @@ static void mx28_init_dma(void)
 }
 #endif
 
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+#ifdef	CONFIG_I2C_MXS_SELECT0
+static struct resource i2c0_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = I2C0_PHYS_ADDR,
+	 .end   = I2C0_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_I2C0,
+	 .end   = MXS_DMA_CHANNEL_AHB_APBX_I2C0,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C0_ERROR,
+	 .end   = IRQ_I2C0_ERROR,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C0_DMA,
+	 .end   = IRQ_I2C0_DMA,
+	 },
+};
+
+static struct mxs_i2c_plat_data i2c0_platdata = {
+#ifdef	CONFIG_I2C_MXS_SELECT0_PIOQUEUE_MODE
+	.pioqueue_mode = 1,
+#endif
+};
+#endif
+
+#ifdef	CONFIG_I2C_MXS_SELECT1
+static struct resource i2c1_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = I2C1_PHYS_ADDR,
+	 .end   = I2C1_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_I2C1,
+	 .end   = MXS_DMA_CHANNEL_AHB_APBX_I2C1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C1_ERROR,
+	 .end   = IRQ_I2C1_ERROR,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C1_DMA,
+	 .end   = IRQ_I2C1_DMA,
+	 },
+};
+
+static struct mxs_i2c_plat_data i2c1_platdata = {
+#ifdef	CONFIG_I2C_MXS_SELECT1_PIOQUEUE_MODE
+	.pioqueue_mode = 1,
+#endif
+};
+#endif
+
+static void __init mx28_init_i2c(void)
+{
+	int i;
+	struct mxs_dev_lookup *lookup;
+	struct platform_device *pdev;
+
+	lookup = mxs_get_devices("mxs-i2c");
+	if (lookup == NULL || IS_ERR(lookup))
+		return;
+	for (i = 0; i < lookup->size; i++) {
+		pdev = lookup->pdev + i;
+		switch (pdev->id) {
+#ifdef	CONFIG_I2C_MXS_SELECT0
+		case 0:
+			pdev->resource = i2c0_resource;
+			pdev->num_resources = ARRAY_SIZE(i2c0_resource);
+			pdev->dev.platform_data = &i2c0_platdata;
+			break;
+#endif
+#ifdef	CONFIG_I2C_MXS_SELECT1
+		case 1:
+			pdev->resource = i2c1_resource;
+			pdev->num_resources = ARRAY_SIZE(i2c1_resource);
+			pdev->dev.platform_data = &i2c1_platdata;
+			break;
+#endif
+		default:
+			return;
+		}
+		mxs_add_device(pdev, 2);
+	}
+}
+#else
+static void __init mx28_init_i2c(void)
+{
+}
+#endif
+
 #if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
 #if defined(CONFIG_MACH_MX28EVK)
 #define MMC0_POWER	MXS_PIN_TO_GPIO(PINID_PWM3)
@@ -425,6 +527,7 @@ int __init mx28_device_init(void)
 {
 	mx28_init_dma();
 	mx28_init_duart();
+	mx28_init_i2c();
 	mx28_init_mmc();
 	mx28_init_wdt();
 	mx28_init_rtc();
diff --git a/arch/arm/mach-mx28/include/mach/regs-i2c.h b/arch/arm/mach-mx28/include/mach/regs-i2c.h
new file mode 100755
index 0000000..7199744
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-i2c.h
@@ -0,0 +1,498 @@
+/*
+ * Freescale I2C Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.54
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___I2C_H
+#define __ARCH_ARM___I2C_H
+
+
+#define HW_I2C_CTRL0	(0x00000000)
+#define HW_I2C_CTRL0_SET	(0x00000004)
+#define HW_I2C_CTRL0_CLR	(0x00000008)
+#define HW_I2C_CTRL0_TOG	(0x0000000c)
+
+#define BM_I2C_CTRL0_SFTRST	0x80000000
+#define BV_I2C_CTRL0_SFTRST__RUN   0x0
+#define BV_I2C_CTRL0_SFTRST__RESET 0x1
+#define BM_I2C_CTRL0_CLKGATE	0x40000000
+#define BV_I2C_CTRL0_CLKGATE__RUN     0x0
+#define BV_I2C_CTRL0_CLKGATE__NO_CLKS 0x1
+#define BM_I2C_CTRL0_RUN	0x20000000
+#define BV_I2C_CTRL0_RUN__HALT 0x0
+#define BV_I2C_CTRL0_RUN__RUN  0x1
+#define BM_I2C_CTRL0_RSVD2	0x10000000
+#define BM_I2C_CTRL0_PRE_ACK	0x08000000
+#define BM_I2C_CTRL0_ACKNOWLEDGE	0x04000000
+#define BV_I2C_CTRL0_ACKNOWLEDGE__SNAK 0x0
+#define BV_I2C_CTRL0_ACKNOWLEDGE__ACK  0x1
+#define BM_I2C_CTRL0_SEND_NAK_ON_LAST	0x02000000
+#define BV_I2C_CTRL0_SEND_NAK_ON_LAST__ACK_IT 0x0
+#define BV_I2C_CTRL0_SEND_NAK_ON_LAST__NAK_IT 0x1
+#define BM_I2C_CTRL0_RSVD1	0x01000000
+#define BM_I2C_CTRL0_MULTI_MASTER	0x00800000
+#define BV_I2C_CTRL0_MULTI_MASTER__SINGLE   0x0
+#define BV_I2C_CTRL0_MULTI_MASTER__MULTIPLE 0x1
+#define BM_I2C_CTRL0_CLOCK_HELD	0x00400000
+#define BV_I2C_CTRL0_CLOCK_HELD__RELEASE  0x0
+#define BV_I2C_CTRL0_CLOCK_HELD__HELD_LOW 0x1
+#define BM_I2C_CTRL0_RETAIN_CLOCK	0x00200000
+#define BV_I2C_CTRL0_RETAIN_CLOCK__RELEASE  0x0
+#define BV_I2C_CTRL0_RETAIN_CLOCK__HOLD_LOW 0x1
+#define BM_I2C_CTRL0_POST_SEND_STOP	0x00100000
+#define BV_I2C_CTRL0_POST_SEND_STOP__NO_STOP   0x0
+#define BV_I2C_CTRL0_POST_SEND_STOP__SEND_STOP 0x1
+#define BM_I2C_CTRL0_PRE_SEND_START	0x00080000
+#define BV_I2C_CTRL0_PRE_SEND_START__NO_START   0x0
+#define BV_I2C_CTRL0_PRE_SEND_START__SEND_START 0x1
+#define BM_I2C_CTRL0_SLAVE_ADDRESS_ENABLE	0x00040000
+#define BV_I2C_CTRL0_SLAVE_ADDRESS_ENABLE__DISABLED 0x0
+#define BV_I2C_CTRL0_SLAVE_ADDRESS_ENABLE__ENABLED  0x1
+#define BM_I2C_CTRL0_MASTER_MODE	0x00020000
+#define BV_I2C_CTRL0_MASTER_MODE__SLAVE  0x0
+#define BV_I2C_CTRL0_MASTER_MODE__MASTER 0x1
+#define BM_I2C_CTRL0_DIRECTION	0x00010000
+#define BV_I2C_CTRL0_DIRECTION__RECEIVE  0x0
+#define BV_I2C_CTRL0_DIRECTION__TRANSMIT 0x1
+#define BP_I2C_CTRL0_XFER_COUNT	0
+#define BM_I2C_CTRL0_XFER_COUNT	0x0000FFFF
+#define BF_I2C_CTRL0_XFER_COUNT(v)  \
+		(((v) << 0) & BM_I2C_CTRL0_XFER_COUNT)
+
+#define HW_I2C_TIMING0	(0x00000010)
+#define HW_I2C_TIMING0_SET	(0x00000014)
+#define HW_I2C_TIMING0_CLR	(0x00000018)
+#define HW_I2C_TIMING0_TOG	(0x0000001c)
+
+#define BP_I2C_TIMING0_RSVD2	26
+#define BM_I2C_TIMING0_RSVD2	0xFC000000
+#define BF_I2C_TIMING0_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING0_RSVD2)
+#define BP_I2C_TIMING0_HIGH_COUNT	16
+#define BM_I2C_TIMING0_HIGH_COUNT	0x03FF0000
+#define BF_I2C_TIMING0_HIGH_COUNT(v)  \
+		(((v) << 16) & BM_I2C_TIMING0_HIGH_COUNT)
+#define BP_I2C_TIMING0_RSVD1	10
+#define BM_I2C_TIMING0_RSVD1	0x0000FC00
+#define BF_I2C_TIMING0_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING0_RSVD1)
+#define BP_I2C_TIMING0_RCV_COUNT	0
+#define BM_I2C_TIMING0_RCV_COUNT	0x000003FF
+#define BF_I2C_TIMING0_RCV_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING0_RCV_COUNT)
+
+#define HW_I2C_TIMING1	(0x00000020)
+#define HW_I2C_TIMING1_SET	(0x00000024)
+#define HW_I2C_TIMING1_CLR	(0x00000028)
+#define HW_I2C_TIMING1_TOG	(0x0000002c)
+
+#define BP_I2C_TIMING1_RSVD2	26
+#define BM_I2C_TIMING1_RSVD2	0xFC000000
+#define BF_I2C_TIMING1_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING1_RSVD2)
+#define BP_I2C_TIMING1_LOW_COUNT	16
+#define BM_I2C_TIMING1_LOW_COUNT	0x03FF0000
+#define BF_I2C_TIMING1_LOW_COUNT(v)  \
+		(((v) << 16) & BM_I2C_TIMING1_LOW_COUNT)
+#define BP_I2C_TIMING1_RSVD1	10
+#define BM_I2C_TIMING1_RSVD1	0x0000FC00
+#define BF_I2C_TIMING1_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING1_RSVD1)
+#define BP_I2C_TIMING1_XMIT_COUNT	0
+#define BM_I2C_TIMING1_XMIT_COUNT	0x000003FF
+#define BF_I2C_TIMING1_XMIT_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING1_XMIT_COUNT)
+
+#define HW_I2C_TIMING2	(0x00000030)
+#define HW_I2C_TIMING2_SET	(0x00000034)
+#define HW_I2C_TIMING2_CLR	(0x00000038)
+#define HW_I2C_TIMING2_TOG	(0x0000003c)
+
+#define BP_I2C_TIMING2_RSVD2	26
+#define BM_I2C_TIMING2_RSVD2	0xFC000000
+#define BF_I2C_TIMING2_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING2_RSVD2)
+#define BP_I2C_TIMING2_BUS_FREE	16
+#define BM_I2C_TIMING2_BUS_FREE	0x03FF0000
+#define BF_I2C_TIMING2_BUS_FREE(v)  \
+		(((v) << 16) & BM_I2C_TIMING2_BUS_FREE)
+#define BP_I2C_TIMING2_RSVD1	10
+#define BM_I2C_TIMING2_RSVD1	0x0000FC00
+#define BF_I2C_TIMING2_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING2_RSVD1)
+#define BP_I2C_TIMING2_LEADIN_COUNT	0
+#define BM_I2C_TIMING2_LEADIN_COUNT	0x000003FF
+#define BF_I2C_TIMING2_LEADIN_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING2_LEADIN_COUNT)
+
+#define HW_I2C_CTRL1	(0x00000040)
+#define HW_I2C_CTRL1_SET	(0x00000044)
+#define HW_I2C_CTRL1_CLR	(0x00000048)
+#define HW_I2C_CTRL1_TOG	(0x0000004c)
+
+#define BM_I2C_CTRL1_RSVD1	0x80000000
+#define BM_I2C_CTRL1_RD_QUEUE_IRQ	0x40000000
+#define BV_I2C_CTRL1_RD_QUEUE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_RD_QUEUE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_WR_QUEUE_IRQ	0x20000000
+#define BV_I2C_CTRL1_WR_QUEUE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_WR_QUEUE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_CLR_GOT_A_NAK	0x10000000
+#define BV_I2C_CTRL1_CLR_GOT_A_NAK__DO_NOTHING 0x0
+#define BV_I2C_CTRL1_CLR_GOT_A_NAK__CLEAR      0x1
+#define BM_I2C_CTRL1_ACK_MODE	0x08000000
+#define BV_I2C_CTRL1_ACK_MODE__ACK_AFTER_HOLD_LOW  0x0
+#define BV_I2C_CTRL1_ACK_MODE__ACK_BEFORE_HOLD_LOW 0x1
+#define BM_I2C_CTRL1_FORCE_DATA_IDLE	0x04000000
+#define BM_I2C_CTRL1_FORCE_CLK_IDLE	0x02000000
+#define BM_I2C_CTRL1_BCAST_SLAVE_EN	0x01000000
+#define BV_I2C_CTRL1_BCAST_SLAVE_EN__NO_BCAST    0x0
+#define BV_I2C_CTRL1_BCAST_SLAVE_EN__WATCH_BCAST 0x1
+#define BP_I2C_CTRL1_SLAVE_ADDRESS_BYTE	16
+#define BM_I2C_CTRL1_SLAVE_ADDRESS_BYTE	0x00FF0000
+#define BF_I2C_CTRL1_SLAVE_ADDRESS_BYTE(v)  \
+		(((v) << 16) & BM_I2C_CTRL1_SLAVE_ADDRESS_BYTE)
+#define BM_I2C_CTRL1_BUS_FREE_IRQ_EN	0x00008000
+#define BV_I2C_CTRL1_BUS_FREE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_BUS_FREE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN	0x00004000
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN	0x00002000
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN	0x00001000
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_EARLY_TERM_IRQ_EN	0x00000800
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_MASTER_LOSS_IRQ_EN	0x00000400
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_SLAVE_STOP_IRQ_EN	0x00000200
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_SLAVE_IRQ_EN	0x00000100
+#define BV_I2C_CTRL1_SLAVE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_SLAVE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_BUS_FREE_IRQ	0x00000080
+#define BV_I2C_CTRL1_BUS_FREE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_BUS_FREE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ	0x00000040
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ	0x00000020
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ	0x00000010
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_EARLY_TERM_IRQ	0x00000008
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_MASTER_LOSS_IRQ	0x00000004
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_SLAVE_STOP_IRQ	0x00000002
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_SLAVE_IRQ	0x00000001
+#define BV_I2C_CTRL1_SLAVE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_SLAVE_IRQ__REQUEST    0x1
+
+#define HW_I2C_STAT	(0x00000050)
+
+#define BM_I2C_STAT_MASTER_PRESENT	0x80000000
+#define BV_I2C_STAT_MASTER_PRESENT__UNAVAILABLE 0x0
+#define BV_I2C_STAT_MASTER_PRESENT__AVAILABLE   0x1
+#define BM_I2C_STAT_SLAVE_PRESENT	0x40000000
+#define BV_I2C_STAT_SLAVE_PRESENT__UNAVAILABLE 0x0
+#define BV_I2C_STAT_SLAVE_PRESENT__AVAILABLE   0x1
+#define BM_I2C_STAT_ANY_ENABLED_IRQ	0x20000000
+#define BV_I2C_STAT_ANY_ENABLED_IRQ__NO_REQUESTS          0x0
+#define BV_I2C_STAT_ANY_ENABLED_IRQ__AT_LEAST_ONE_REQUEST 0x1
+#define BM_I2C_STAT_GOT_A_NAK	0x10000000
+#define BV_I2C_STAT_GOT_A_NAK__NO_NAK       0x0
+#define BV_I2C_STAT_GOT_A_NAK__DETECTED_NAK 0x1
+#define BP_I2C_STAT_RSVD1	24
+#define BM_I2C_STAT_RSVD1	0x0F000000
+#define BF_I2C_STAT_RSVD1(v)  \
+		(((v) << 24) & BM_I2C_STAT_RSVD1)
+#define BP_I2C_STAT_RCVD_SLAVE_ADDR	16
+#define BM_I2C_STAT_RCVD_SLAVE_ADDR	0x00FF0000
+#define BF_I2C_STAT_RCVD_SLAVE_ADDR(v)  \
+		(((v) << 16) & BM_I2C_STAT_RCVD_SLAVE_ADDR)
+#define BM_I2C_STAT_SLAVE_ADDR_EQ_ZERO	0x00008000
+#define BV_I2C_STAT_SLAVE_ADDR_EQ_ZERO__ZERO_NOT_MATCHED 0x0
+#define BV_I2C_STAT_SLAVE_ADDR_EQ_ZERO__WAS_ZERO         0x1
+#define BM_I2C_STAT_SLAVE_FOUND	0x00004000
+#define BV_I2C_STAT_SLAVE_FOUND__IDLE    0x0
+#define BV_I2C_STAT_SLAVE_FOUND__WAITING 0x1
+#define BM_I2C_STAT_SLAVE_SEARCHING	0x00002000
+#define BV_I2C_STAT_SLAVE_SEARCHING__IDLE   0x0
+#define BV_I2C_STAT_SLAVE_SEARCHING__ACTIVE 0x1
+#define BM_I2C_STAT_DATA_ENGINE_DMA_WAIT	0x00001000
+#define BV_I2C_STAT_DATA_ENGINE_DMA_WAIT__CONTINUE 0x0
+#define BV_I2C_STAT_DATA_ENGINE_DMA_WAIT__WAITING  0x1
+#define BM_I2C_STAT_BUS_BUSY	0x00000800
+#define BV_I2C_STAT_BUS_BUSY__IDLE 0x0
+#define BV_I2C_STAT_BUS_BUSY__BUSY 0x1
+#define BM_I2C_STAT_CLK_GEN_BUSY	0x00000400
+#define BV_I2C_STAT_CLK_GEN_BUSY__IDLE 0x0
+#define BV_I2C_STAT_CLK_GEN_BUSY__BUSY 0x1
+#define BM_I2C_STAT_DATA_ENGINE_BUSY	0x00000200
+#define BV_I2C_STAT_DATA_ENGINE_BUSY__IDLE 0x0
+#define BV_I2C_STAT_DATA_ENGINE_BUSY__BUSY 0x1
+#define BM_I2C_STAT_SLAVE_BUSY	0x00000100
+#define BV_I2C_STAT_SLAVE_BUSY__IDLE 0x0
+#define BV_I2C_STAT_SLAVE_BUSY__BUSY 0x1
+#define BM_I2C_STAT_BUS_FREE_IRQ_SUMMARY	0x00000080
+#define BV_I2C_STAT_BUS_FREE_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_BUS_FREE_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY	0x00000040
+#define BV_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY	0x00000020
+#define BV_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY	0x00000010
+#define BV_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_EARLY_TERM_IRQ_SUMMARY	0x00000008
+#define BV_I2C_STAT_EARLY_TERM_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_EARLY_TERM_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY	0x00000004
+#define BV_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY	0x00000002
+#define BV_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_SLAVE_IRQ_SUMMARY	0x00000001
+#define BV_I2C_STAT_SLAVE_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_SLAVE_IRQ_SUMMARY__REQUEST    0x1
+
+#define HW_I2C_QUEUECTRL	(0x00000060)
+#define HW_I2C_QUEUECTRL_SET	(0x00000064)
+#define HW_I2C_QUEUECTRL_CLR	(0x00000068)
+#define HW_I2C_QUEUECTRL_TOG	(0x0000006c)
+
+#define BP_I2C_QUEUECTRL_RSVD3	21
+#define BM_I2C_QUEUECTRL_RSVD3	0xFFE00000
+#define BF_I2C_QUEUECTRL_RSVD3(v) \
+		(((v) << 21) & BM_I2C_QUEUECTRL_RSVD3)
+#define BP_I2C_QUEUECTRL_RD_THRESH	16
+#define BM_I2C_QUEUECTRL_RD_THRESH	0x001F0000
+#define BF_I2C_QUEUECTRL_RD_THRESH(v)  \
+		(((v) << 16) & BM_I2C_QUEUECTRL_RD_THRESH)
+#define BP_I2C_QUEUECTRL_RSVD2	13
+#define BM_I2C_QUEUECTRL_RSVD2	0x0000E000
+#define BF_I2C_QUEUECTRL_RSVD2(v)  \
+		(((v) << 13) & BM_I2C_QUEUECTRL_RSVD2)
+#define BP_I2C_QUEUECTRL_WR_THRESH	8
+#define BM_I2C_QUEUECTRL_WR_THRESH	0x00001F00
+#define BF_I2C_QUEUECTRL_WR_THRESH(v)  \
+		(((v) << 8) & BM_I2C_QUEUECTRL_WR_THRESH)
+#define BP_I2C_QUEUECTRL_RSVD1	6
+#define BM_I2C_QUEUECTRL_RSVD1	0x000000C0
+#define BF_I2C_QUEUECTRL_RSVD1(v)  \
+		(((v) << 6) & BM_I2C_QUEUECTRL_RSVD1)
+#define BM_I2C_QUEUECTRL_QUEUE_RUN	0x00000020
+#define BV_I2C_QUEUECTRL_QUEUE_RUN__STOP  0x0
+#define BV_I2C_QUEUECTRL_QUEUE_RUN__START 0x1
+#define BM_I2C_QUEUECTRL_RD_CLEAR	0x00000010
+#define BM_I2C_QUEUECTRL_WR_CLEAR	0x00000008
+#define BM_I2C_QUEUECTRL_PIO_QUEUE_MODE	0x00000004
+#define BM_I2C_QUEUECTRL_RD_QUEUE_IRQ_EN	0x00000002
+#define BV_I2C_QUEUECTRL_RD_QUEUE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_QUEUECTRL_RD_QUEUE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_QUEUECTRL_WR_QUEUE_IRQ_EN	0x00000001
+#define BV_I2C_QUEUECTRL_WR_QUEUE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_QUEUECTRL_WR_QUEUE_IRQ_EN__ENABLED  0x1
+
+#define HW_I2C_QUEUESTAT	(0x00000070)
+#define HW_I2C_QUEUESTAT_SET	(0x00000074)
+#define HW_I2C_QUEUESTAT_CLR	(0x00000078)
+#define HW_I2C_QUEUESTAT_TOG	(0x0000007c)
+
+#define BP_I2C_QUEUESTAT_RSVD2	15
+#define BM_I2C_QUEUESTAT_RSVD2	0xFFFF8000
+#define BF_I2C_QUEUESTAT_RSVD2(v) \
+		(((v) << 15) & BM_I2C_QUEUESTAT_RSVD2)
+#define BM_I2C_QUEUESTAT_RD_QUEUE_FULL	0x00004000
+#define BM_I2C_QUEUESTAT_RD_QUEUE_EMPTY	0x00002000
+#define BP_I2C_QUEUESTAT_RD_QUEUE_CNT	8
+#define BM_I2C_QUEUESTAT_RD_QUEUE_CNT	0x00001F00
+#define BF_I2C_QUEUESTAT_RD_QUEUE_CNT(v)  \
+		(((v) << 8) & BM_I2C_QUEUESTAT_RD_QUEUE_CNT)
+#define BM_I2C_QUEUESTAT_RSVD1	0x00000080
+#define BM_I2C_QUEUESTAT_WR_QUEUE_FULL	0x00000040
+#define BM_I2C_QUEUESTAT_WR_QUEUE_EMPTY	0x00000020
+#define BP_I2C_QUEUESTAT_WR_QUEUE_CNT	0
+#define BM_I2C_QUEUESTAT_WR_QUEUE_CNT	0x0000001F
+#define BF_I2C_QUEUESTAT_WR_QUEUE_CNT(v)  \
+		(((v) << 0) & BM_I2C_QUEUESTAT_WR_QUEUE_CNT)
+
+#define HW_I2C_QUEUECMD	(0x00000080)
+#define HW_I2C_QUEUECMD_SET	(0x00000084)
+#define HW_I2C_QUEUECMD_CLR	(0x00000088)
+#define HW_I2C_QUEUECMD_TOG	(0x0000008c)
+
+#define BP_I2C_QUEUECMD_RSVD2	28
+#define BM_I2C_QUEUECMD_RSVD2	0xF0000000
+#define BF_I2C_QUEUECMD_RSVD2(v) \
+		(((v) << 28) & BM_I2C_QUEUECMD_RSVD2)
+#define BM_I2C_QUEUECMD_PRE_ACK	0x08000000
+#define BM_I2C_QUEUECMD_ACKNOWLEDGE	0x04000000
+#define BV_I2C_QUEUECMD_ACKNOWLEDGE__SNAK 0x0
+#define BV_I2C_QUEUECMD_ACKNOWLEDGE__ACK  0x1
+#define BM_I2C_QUEUECMD_SEND_NAK_ON_LAST	0x02000000
+#define BV_I2C_QUEUECMD_SEND_NAK_ON_LAST__ACK_IT 0x0
+#define BV_I2C_QUEUECMD_SEND_NAK_ON_LAST__NAK_IT 0x1
+#define BM_I2C_QUEUECMD_RSVD1	0x01000000
+#define BM_I2C_QUEUECMD_MULTI_MASTER	0x00800000
+#define BV_I2C_QUEUECMD_MULTI_MASTER__SINGLE   0x0
+#define BV_I2C_QUEUECMD_MULTI_MASTER__MULTIPLE 0x1
+#define BM_I2C_QUEUECMD_CLOCK_HELD	0x00400000
+#define BV_I2C_QUEUECMD_CLOCK_HELD__RELEASE  0x0
+#define BV_I2C_QUEUECMD_CLOCK_HELD__HELD_LOW 0x1
+#define BM_I2C_QUEUECMD_RETAIN_CLOCK	0x00200000
+#define BV_I2C_QUEUECMD_RETAIN_CLOCK__RELEASE  0x0
+#define BV_I2C_QUEUECMD_RETAIN_CLOCK__HOLD_LOW 0x1
+#define BM_I2C_QUEUECMD_POST_SEND_STOP	0x00100000
+#define BV_I2C_QUEUECMD_POST_SEND_STOP__NO_STOP   0x0
+#define BV_I2C_QUEUECMD_POST_SEND_STOP__SEND_STOP 0x1
+#define BM_I2C_QUEUECMD_PRE_SEND_START	0x00080000
+#define BV_I2C_QUEUECMD_PRE_SEND_START__NO_START   0x0
+#define BV_I2C_QUEUECMD_PRE_SEND_START__SEND_START 0x1
+#define BM_I2C_QUEUECMD_SLAVE_ADDRESS_ENABLE	0x00040000
+#define BV_I2C_QUEUECMD_SLAVE_ADDRESS_ENABLE__DISABLED 0x0
+#define BV_I2C_QUEUECMD_SLAVE_ADDRESS_ENABLE__ENABLED  0x1
+#define BM_I2C_QUEUECMD_MASTER_MODE	0x00020000
+#define BV_I2C_QUEUECMD_MASTER_MODE__SLAVE  0x0
+#define BV_I2C_QUEUECMD_MASTER_MODE__MASTER 0x1
+#define BM_I2C_QUEUECMD_DIRECTION	0x00010000
+#define BV_I2C_QUEUECMD_DIRECTION__RECEIVE  0x0
+#define BV_I2C_QUEUECMD_DIRECTION__TRANSMIT 0x1
+#define BP_I2C_QUEUECMD_XFER_COUNT	0
+#define BM_I2C_QUEUECMD_XFER_COUNT	0x0000FFFF
+#define BF_I2C_QUEUECMD_XFER_COUNT(v)  \
+		(((v) << 0) & BM_I2C_QUEUECMD_XFER_COUNT)
+
+#define HW_I2C_QUEUEDATA	(0x00000090)
+
+#define BP_I2C_QUEUEDATA_DATA	0
+#define BM_I2C_QUEUEDATA_DATA	0xFFFFFFFF
+#define BF_I2C_QUEUEDATA_DATA(v)	(v)
+
+#define HW_I2C_DATA	(0x000000a0)
+
+#define BP_I2C_DATA_DATA	0
+#define BM_I2C_DATA_DATA	0xFFFFFFFF
+#define BF_I2C_DATA_DATA(v)	(v)
+
+#define HW_I2C_DEBUG0	(0x000000b0)
+#define HW_I2C_DEBUG0_SET	(0x000000b4)
+#define HW_I2C_DEBUG0_CLR	(0x000000b8)
+#define HW_I2C_DEBUG0_TOG	(0x000000bc)
+
+#define BM_I2C_DEBUG0_DMAREQ	0x80000000
+#define BM_I2C_DEBUG0_DMAENDCMD	0x40000000
+#define BM_I2C_DEBUG0_DMAKICK	0x20000000
+#define BM_I2C_DEBUG0_DMATERMINATE	0x10000000
+#define BP_I2C_DEBUG0_STATE_VALUE	26
+#define BM_I2C_DEBUG0_STATE_VALUE	0x0C000000
+#define BF_I2C_DEBUG0_STATE_VALUE(v)  \
+		(((v) << 26) & BM_I2C_DEBUG0_STATE_VALUE)
+#define BP_I2C_DEBUG0_DMA_STATE	16
+#define BM_I2C_DEBUG0_DMA_STATE	0x03FF0000
+#define BF_I2C_DEBUG0_DMA_STATE(v)  \
+		(((v) << 16) & BM_I2C_DEBUG0_DMA_STATE)
+#define BM_I2C_DEBUG0_START_TOGGLE	0x00008000
+#define BM_I2C_DEBUG0_STOP_TOGGLE	0x00004000
+#define BM_I2C_DEBUG0_GRAB_TOGGLE	0x00002000
+#define BM_I2C_DEBUG0_CHANGE_TOGGLE	0x00001000
+#define BM_I2C_DEBUG0_STATE_LATCH	0x00000800
+#define BM_I2C_DEBUG0_SLAVE_HOLD_CLK	0x00000400
+#define BP_I2C_DEBUG0_SLAVE_STATE	0
+#define BM_I2C_DEBUG0_SLAVE_STATE	0x000003FF
+#define BF_I2C_DEBUG0_SLAVE_STATE(v)  \
+		(((v) << 0) & BM_I2C_DEBUG0_SLAVE_STATE)
+
+#define HW_I2C_DEBUG1	(0x000000c0)
+#define HW_I2C_DEBUG1_SET	(0x000000c4)
+#define HW_I2C_DEBUG1_CLR	(0x000000c8)
+#define HW_I2C_DEBUG1_TOG	(0x000000cc)
+
+#define BM_I2C_DEBUG1_I2C_CLK_IN	0x80000000
+#define BM_I2C_DEBUG1_I2C_DATA_IN	0x40000000
+#define BP_I2C_DEBUG1_RSVD4	28
+#define BM_I2C_DEBUG1_RSVD4	0x30000000
+#define BF_I2C_DEBUG1_RSVD4(v)  \
+		(((v) << 28) & BM_I2C_DEBUG1_RSVD4)
+#define BP_I2C_DEBUG1_DMA_BYTE_ENABLES	24
+#define BM_I2C_DEBUG1_DMA_BYTE_ENABLES	0x0F000000
+#define BF_I2C_DEBUG1_DMA_BYTE_ENABLES(v)  \
+		(((v) << 24) & BM_I2C_DEBUG1_DMA_BYTE_ENABLES)
+#define BP_I2C_DEBUG1_CLK_GEN_STATE	16
+#define BM_I2C_DEBUG1_CLK_GEN_STATE	0x00FF0000
+#define BF_I2C_DEBUG1_CLK_GEN_STATE(v)  \
+		(((v) << 16) & BM_I2C_DEBUG1_CLK_GEN_STATE)
+#define BP_I2C_DEBUG1_RSVD2	11
+#define BM_I2C_DEBUG1_RSVD2	0x0000F800
+#define BF_I2C_DEBUG1_RSVD2(v)  \
+		(((v) << 11) & BM_I2C_DEBUG1_RSVD2)
+#define BP_I2C_DEBUG1_LST_MODE	9
+#define BM_I2C_DEBUG1_LST_MODE	0x00000600
+#define BF_I2C_DEBUG1_LST_MODE(v)  \
+		(((v) << 9) & BM_I2C_DEBUG1_LST_MODE)
+#define BV_I2C_DEBUG1_LST_MODE__BCAST    0x0
+#define BV_I2C_DEBUG1_LST_MODE__MY_WRITE 0x1
+#define BV_I2C_DEBUG1_LST_MODE__MY_READ  0x2
+#define BV_I2C_DEBUG1_LST_MODE__NOT_ME   0x3
+#define BM_I2C_DEBUG1_LOCAL_SLAVE_TEST	0x00000100
+#define BP_I2C_DEBUG1_RSVD1	5
+#define BM_I2C_DEBUG1_RSVD1	0x000000E0
+#define BF_I2C_DEBUG1_RSVD1(v)  \
+		(((v) << 5) & BM_I2C_DEBUG1_RSVD1)
+#define BM_I2C_DEBUG1_FORCE_CLK_ON	0x00000010
+#define BM_I2C_DEBUG1_FORCE_ARB_LOSS	0x00000008
+#define BM_I2C_DEBUG1_FORCE_RCV_ACK	0x00000004
+#define BM_I2C_DEBUG1_FORCE_I2C_DATA_OE	0x00000002
+#define BM_I2C_DEBUG1_FORCE_I2C_CLK_OE	0x00000001
+
+#define HW_I2C_VERSION	(0x000000d0)
+
+#define BP_I2C_VERSION_MAJOR	24
+#define BM_I2C_VERSION_MAJOR	0xFF000000
+#define BF_I2C_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_I2C_VERSION_MAJOR)
+#define BP_I2C_VERSION_MINOR	16
+#define BM_I2C_VERSION_MINOR	0x00FF0000
+#define BF_I2C_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_I2C_VERSION_MINOR)
+#define BP_I2C_VERSION_STEP	0
+#define BM_I2C_VERSION_STEP	0x0000FFFF
+#define BF_I2C_VERSION_STEP(v)  \
+		(((v) << 0) & BM_I2C_VERSION_STEP)
+#endif /* __ARCH_ARM___I2C_H */
diff --git a/arch/arm/mach-mx28/mx28evk_pins.c b/arch/arm/mach-mx28/mx28evk_pins.c
index 9c9ff4b..a7a55b8 100644
--- a/arch/arm/mach-mx28/mx28evk_pins.c
+++ b/arch/arm/mach-mx28/mx28evk_pins.c
@@ -37,6 +37,25 @@ static struct pin_desc mx28evk_fixed_pins[] = {
 	 .id = PINID_PWM1,
 	 .fun = PIN_FUN3,
 	 },
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+	{
+	 .name = "I2C0_SCL",
+	 .id = PINID_I2C0_SCL,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "I2C0_SDA",
+	 .id = PINID_I2C0_SDA,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
 #if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
 	/* Configurations of SSP0 SD/MMC port pins */
 	{
diff --git a/arch/arm/plat-mxs/device.c b/arch/arm/plat-mxs/device.c
index 6548264..d1e2e9e 100644
--- a/arch/arm/plat-mxs/device.c
+++ b/arch/arm/plat-mxs/device.c
@@ -110,6 +110,34 @@ static struct platform_device mxs_dma[] = {
 };
 #endif
 
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+static struct platform_device mxs_i2c[] = {
+#if defined(CONFIG_I2C_MXS_SELECT0)
+	{
+	 .name	= "mxs-i2c",
+	 .id	= 0,
+	 .dev = {
+		.dma_mask               = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+#endif
+#if defined(CONFIG_I2C_MXS_SELECT1)
+	{
+	 .name	= "mxs-i2c",
+	 .id	= 1,
+	 .dev = {
+		.dma_mask               = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+#endif
+};
+#endif
+
 #if defined(CONFIG_MMC_MXS) || \
 	defined(CONFIG_MMC_MXS_MODULE)
 static struct platform_device mxs_mmc[] = {
@@ -171,6 +199,15 @@ static struct mxs_dev_lookup dev_lookup[] = {
 	 },
 #endif
 
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+	{
+	 .name	= "mxs-i2c",
+	 .size	= ARRAY_SIZE(mxs_i2c),
+	 .pdev	= mxs_i2c,
+	 },
+#endif
+
 #if defined(CONFIG_MMC_MXS) || \
 	defined(CONFIG_MMC_MXS_MODULE)
 	{
diff --git a/arch/arm/plat-mxs/include/mach/device.h b/arch/arm/plat-mxs/include/mach/device.h
index 2e9d596..b362d2e 100644
--- a/arch/arm/plat-mxs/include/mach/device.h
+++ b/arch/arm/plat-mxs/include/mach/device.h
@@ -53,6 +53,10 @@ struct mxs_dma_plat_data {
 	unsigned int chan_num;
 };
 
+struct mxs_i2c_plat_data {
+	unsigned int pioqueue_mode:1;
+};
+
 extern void mxs_timer_init(struct mxs_sys_timer *timer);
 
 extern void mxs_nop_release(struct device *dev);
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index b92f6b3..f70a72a 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -434,6 +434,40 @@ config I2C_MXC_HS
 
 	  This driver can also be built as a module.
 
+config I2C_MXS
+	tristate "MXS I2C Support"
+	depends on I2C && ARCH_MXS
+	help
+	  If you say yes to this option, support will be included for Freescale
+	  MXS I2C modules.
+
+config I2C_MXS_SELECT0
+	bool "Enable I2C0 module"
+	default y
+	depends on I2C_MXS
+	help
+	  Enable MXS I2C0 Module
+
+config I2C_MXS_SELECT0_PIOQUEUE_MODE
+	tristate "MXS I2C0 PIOQUEUE MODE Support"
+	depends on I2C_MXS_SELECT0
+	help
+	  say yes if you are sure transfer length is eqaul to or less than 24 bytes.
+	  Otherwise say no to use DMA mode by default.
+
+config I2C_MXS_SELECT1
+	bool "Enable I2C1 module"
+	depends on I2C_MXS
+	help
+	  Enable MXS I2C1 Module
+
+config I2C_MXS_SELECT1_PIOQUEUE_MODE
+	tristate "MXS I2C1 PIOQUEUE MODE Support"
+	depends on I2C_MXS_SELECT1
+	help
+	  say yes if you are sure transfer length is eqaul to or less than 24 bytes.
+	  Otherwise say no to use DMA mode by default.
+
 config I2C_STMP378X
 	tristate "STMP378x I2C adapter"
 	depends on MACH_STMP378X
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index e18e3b8..e0029e3 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -74,6 +74,7 @@ obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
 obj-$(CONFIG_I2C_MXC)		+= mxc_i2c.o
 obj-$(CONFIG_I2C_MXC_HS)	+= mxc_i2c_hs.o
 obj-$(CONFIG_I2C_STMP378X)	+= i2c-stmp378x.o
+obj-$(CONFIG_I2C_MXS)		+= i2c-mxs.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
diff --git a/drivers/i2c/busses/i2c-mxs.c b/drivers/i2c/busses/i2c-mxs.c
index 4b9793a..db20f6f 100644
--- a/drivers/i2c/busses/i2c-mxs.c
+++ b/drivers/i2c/busses/i2c-mxs.c
@@ -1,21 +1,21 @@
 /*
- * Freescale STMP378X I2C bus driver
+ * Freescale MX28 I2C bus driver
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
- * Author: Dmitrij Frasenyak <sed@embeddedalley.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
-/* #define DEBUG */
 
 #include <linux/device.h>
 #include <linux/module.h>
@@ -25,94 +25,300 @@
 #include <linux/interrupt.h>
 #include <linux/completion.h>
 #include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/io.h>
 
-#include <mach/platform.h>
+#include <mach/dmaengine.h>
+#include <mach/device.h>
 #include <mach/regs-i2c.h>
-#include <mach/regs-apbx.h>
-#include <mach/i2c.h>
-#include <mach/platform.h>
+#include <mach/system.h>
+
+#include "i2c-mxs.h"
+
+/* 2 for read, 1 for write */
+#define	NR_DESC		3
+static struct mxs_dma_desc *desc[NR_DESC];
+static dma_addr_t i2c_buf_phys;
+static u8 *i2c_buf_virt;
+
+#define	CMD_I2C_SELECT	(BM_I2C_CTRL0_RETAIN_CLOCK |	\
+			BM_I2C_CTRL0_PRE_SEND_START |	\
+			BM_I2C_CTRL0_MASTER_MODE |	\
+			BM_I2C_CTRL0_DIRECTION |	\
+			BF_I2C_CTRL0_XFER_COUNT(1))
+#define	CMD_I2C_WRITE	(BM_I2C_CTRL0_PRE_SEND_START |	\
+			BM_I2C_CTRL0_MASTER_MODE |	\
+			BM_I2C_CTRL0_DIRECTION)
+#define	CMD_I2C_READ	(BM_I2C_CTRL0_SEND_NAK_ON_LAST |	\
+			BM_I2C_CTRL0_MASTER_MODE)
+
+static void hw_i2c_dmachan_reset(struct mxs_i2c_dev *dev)
+{
+	mxs_dma_reset(dev->dma_chan);
+	mxs_dma_ack_irq(dev->dma_chan);
+}
 
-static void reset_i2c_module(void)
+static int hw_i2c_dma_init(struct platform_device *pdev)
 {
-	u32 ctrl;
-	int count;
-	count = 1000;
-	__raw_writel(BM_I2C_CTRL0_SFTRST, REGS_I2C_BASE + HW_I2C_CTRL0_SET);
-	udelay(10); /* Reseting the module can take multiple clocks.*/
-	while (--count && (!(__raw_readl(REGS_I2C_BASE + HW_I2C_CTRL0) & BM_I2C_CTRL0_CLKGATE)))
-		udelay(1);
-
-	if (!count) {
-		printk(KERN_ERR "timeout reseting the module\n");
-		BUG();
+	struct mxs_i2c_dev *mxs_i2c = platform_get_drvdata(pdev);
+	int i, ret;
+
+	ret = mxs_dma_request(mxs_i2c->dma_chan, &pdev->dev, "i2c");
+	if (ret)
+		return ret;
+
+	for (i = 0; i < NR_DESC; i++) {
+		desc[i] = mxs_dma_alloc_desc();
+		if (desc[i] == NULL)
+			goto err;
 	}
 
-	/* take controller out of reset */
-	__raw_writel(BM_I2C_CTRL0_SFTRST | BM_I2C_CTRL0_CLKGATE,
-		REGS_I2C_BASE + HW_I2C_CTRL0_CLR);
-	udelay(10);
-	/* Wil catch all error (IRQ mask) */
-	__raw_writel(0x0000FF00, REGS_I2C_BASE + HW_I2C_CTRL1_SET);
+	i2c_buf_virt = dma_alloc_coherent(&pdev->dev,
+					  PAGE_SIZE, &i2c_buf_phys, GFP_KERNEL);
+	if (i2c_buf_virt == NULL)
+		goto err;
+
+	hw_i2c_dmachan_reset(mxs_i2c);
+	mxs_dma_enable_irq(mxs_i2c->dma_chan, 1);
+
+	return 0;
+
+err:
+	while (--i >= 0)
+		mxs_dma_free_desc(desc[i]);
+
+	return -ENOMEM;
+}
+
+static void hw_i2c_dma_uninit(struct platform_device *pdev)
+{
+	struct mxs_i2c_dev *mxs_i2c = platform_get_drvdata(pdev);
+	int i;
+	LIST_HEAD(list);
+
+	mxs_dma_enable_irq(mxs_i2c->dma_chan, 0);
+	mxs_dma_get_cooked(mxs_i2c->dma_chan, &list);
+	mxs_dma_disable(mxs_i2c->dma_chan);
+
+	for (i = 0; i < NR_DESC; i++)
+		mxs_dma_free_desc(desc[i]);
+
+	hw_i2c_dmachan_reset(mxs_i2c);
+
+	dma_free_coherent(&pdev->dev, PAGE_SIZE, i2c_buf_virt, i2c_buf_phys);
+
+	mxs_dma_release(mxs_i2c->dma_chan, &pdev->dev);
+}
+
+static void hw_i2c_pioq_setup_read(struct mxs_i2c_dev *dev,
+				   u8 addr, void *buff, int len, int flags)
+{
+	u32 queuecmd;
+	u32 queuedata;
+
+	WARN_ONCE(len > 24, "choose DMA mode if xfer len > 24 bytes\n");
+
+	/* fill queue cmd */
+	queuecmd = CMD_I2C_SELECT;
+	__raw_writel(queuecmd, dev->regbase + HW_I2C_QUEUECMD);
+
+	/* fill data (slave addr) */
+	queuedata = addr | I2C_READ;
+	__raw_writel(queuedata, dev->regbase + HW_I2C_DATA);
+
+	/* fill queue cmd */
+	queuecmd = CMD_I2C_READ | flags;
+	queuecmd |= BF_I2C_CTRL0_XFER_COUNT(len) | flags;
+	__raw_writel(queuecmd, dev->regbase + HW_I2C_QUEUECMD);
+
+}
+
+static void hw_i2c_dma_setup_read(u8 addr, void *buff, int len, int flags)
+{
+	if (len > (PAGE_SIZE - 4))
+		BUG();
+
+	memset(&desc[0]->cmd, 0, sizeof(desc[0]->cmd));
+	memset(&desc[1]->cmd, 0, sizeof(desc[1]->cmd));
+
+	desc[0]->cmd.cmd.bits.bytes = 1;
+	desc[0]->cmd.cmd.bits.pio_words = 1;
+	desc[0]->cmd.cmd.bits.wait4end = 1;
+	desc[0]->cmd.cmd.bits.dec_sem = 1;
+	desc[0]->cmd.cmd.bits.irq = 1;
+	desc[0]->cmd.cmd.bits.chain = 1;
+	desc[0]->cmd.cmd.bits.command = DMA_READ;
+	desc[0]->cmd.address = i2c_buf_phys;
+	desc[0]->cmd.pio_words[0] = CMD_I2C_SELECT;
+	i2c_buf_virt[0] = addr | I2C_READ;
+
+	desc[1]->cmd.cmd.bits.bytes = len;
+	desc[1]->cmd.cmd.bits.pio_words = 1;
+	desc[1]->cmd.cmd.bits.wait4end = 1;
+	desc[1]->cmd.cmd.bits.dec_sem = 1;
+	desc[1]->cmd.cmd.bits.irq = 1;
+	desc[1]->cmd.cmd.bits.command = DMA_WRITE;
+	desc[1]->cmd.address = (u32) i2c_buf_phys + 1;
+	desc[1]->cmd.pio_words[0] = CMD_I2C_READ;
+	desc[1]->cmd.pio_words[0] |= BF_I2C_CTRL0_XFER_COUNT(len) | flags;
+}
+
+static void hw_i2c_pioq_setup_write(struct mxs_i2c_dev *dev,
+				    u8 addr, void *buff, int len, int flags)
+{
+	int align_len, i;
+	u8 slaveaddr;
+	u32 queuecmd;
+	u8 *buf1;
+	u32 *buf2;
+
+	WARN_ONCE(len > 24, "choose DMA mode if xfer len > 24 bytes\n");
+
+	align_len = (len + 1 + 3) & ~3;
+
+	buf1 = (u8 *) dev->buf;
+	buf2 = (u32 *) dev->buf;
+
+	/* fill queue cmd */
+	queuecmd = CMD_I2C_WRITE;
+	queuecmd |= BF_I2C_CTRL0_XFER_COUNT(len + 1) | flags;
+	__raw_writel(queuecmd, dev->regbase + HW_I2C_QUEUECMD);
+
+	/* fill data (slave addr) */
+	slaveaddr = addr | I2C_WRITE;
+	memcpy(buf1, &slaveaddr, 1);
+
+	memcpy(&buf1[1], buff, len);
+
+	/* fill data */
+	for (i = 0; i < align_len / 4; i++)
+		__raw_writel(*buf2++, dev->regbase + HW_I2C_DATA);
+}
+
+static void hw_i2c_dma_setup_write(u8 addr, void *buff, int len, int flags)
+{
+	memset(&desc[2]->cmd, 0, sizeof(desc[2]->cmd));
+
+	desc[2]->cmd.cmd.bits.bytes = len + 1;
+	desc[2]->cmd.cmd.bits.pio_words = 1;
+	desc[2]->cmd.cmd.bits.wait4end = 1;
+	desc[2]->cmd.cmd.bits.dec_sem = 1;
+	desc[2]->cmd.cmd.bits.irq = 1;
+	desc[2]->cmd.cmd.bits.command = DMA_READ;
+	desc[2]->cmd.address = i2c_buf_phys;
+	desc[2]->cmd.pio_words[0] = CMD_I2C_WRITE;
+	desc[2]->cmd.pio_words[0] |= BF_I2C_CTRL0_XFER_COUNT(len + 1) | flags;
+
+	i2c_buf_virt[0] = addr | I2C_WRITE;
+	memcpy(&i2c_buf_virt[1], buff, len);
+}
+
+static void hw_i2c_pioq_run(struct mxs_i2c_dev *dev)
+{
+	__raw_writel(0x20, dev->regbase + HW_I2C_QUEUECTRL_SET);
+}
+
+static void hw_i2c_dma_run(struct mxs_i2c_dev *dev, int dir)
+{
+	if (dir == I2C_READ) {
+		mxs_dma_desc_append(dev->dma_chan, desc[0]);
+		mxs_dma_desc_append(dev->dma_chan, desc[1]);
+	} else
+		mxs_dma_desc_append(dev->dma_chan, desc[2]);
+
+	mxs_dma_enable(dev->dma_chan);
+}
+
+static void hw_i2c_pioq_stop(struct mxs_i2c_dev *dev)
+{
+	__raw_writel(0x20, dev->regbase + HW_I2C_QUEUECTRL_CLR);
+}
+
+static void hw_i2c_finish_read(struct mxs_i2c_dev *dev, void *buff, int len)
+{
+	int i, align_len;
+	u8 *buf1;
+	u32 *buf2;
+
+	if (dev->flags & MXS_I2C_PIOQUEUE_MODE) {
+		align_len = (len + 3) & ~3;
+
+		buf1 = (u8 *) dev->buf;
+		buf2 = (u32 *) dev->buf;
+
+		for (i = 0; i < align_len / 4; i++)
+			*buf2++ = __raw_readl(dev->regbase + HW_I2C_QUEUEDATA);
+
+		memcpy(buff, buf1, len);
+	} else
+		memcpy(buff, &i2c_buf_virt[1], len);
 }
 
 /*
  * Low level master read/write transaction.
  */
-static int stmp378x_i2c_xfer_msg(struct i2c_adapter *adap,
-				 struct i2c_msg *msg, int stop)
+static int mxs_i2c_xfer_msg(struct i2c_adapter *adap,
+			    struct i2c_msg *msg, int stop)
 {
-	struct stmp378x_i2c_dev *dev = i2c_get_adapdata(adap);
+	struct mxs_i2c_dev *dev = i2c_get_adapdata(adap);
 	int err;
+	int flags;
 
 	init_completion(&dev->cmd_complete);
 	dev->cmd_err = 0;
 
-	dev_dbg(dev->dev, " Start XFER ===>\n");
 	dev_dbg(dev->dev, "addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",
 		msg->addr, msg->len, msg->flags, stop);
 
 	if ((msg->len == 0) || (msg->len > (PAGE_SIZE - 1)))
 		return -EINVAL;
 
-	if (msg->flags & I2C_M_RD) {
-		hw_i2c_setup_read(msg->addr ,
-				  msg->buf ,
-				  msg->len,
-				  stop ? BM_I2C_CTRL0_POST_SEND_STOP : 0);
+	flags = stop ? BM_I2C_CTRL0_POST_SEND_STOP : 0;
 
-		hw_i2c_run(1); /* read */
+	if (msg->flags & I2C_M_RD) {
+		if (dev->flags & MXS_I2C_PIOQUEUE_MODE) {
+			hw_i2c_pioq_setup_read(dev,
+					       msg->addr,
+					       msg->buf, msg->len, flags);
+			hw_i2c_pioq_run(dev);
+		} else {
+			hw_i2c_dma_setup_read(msg->addr,
+					      msg->buf, msg->len, flags);
+
+			hw_i2c_dma_run(dev, I2C_READ);
+		}
 	} else {
-		hw_i2c_setup_write(msg->addr ,
-				   msg->buf ,
-				   msg->len,
-				   stop ? BM_I2C_CTRL0_POST_SEND_STOP : 0);
-
-		hw_i2c_run(0); /* write */
+		if (dev->flags & MXS_I2C_PIOQUEUE_MODE) {
+			hw_i2c_pioq_setup_write(dev,
+						msg->addr,
+						msg->buf, msg->len, flags);
+			hw_i2c_pioq_run(dev);
+		} else {
+			hw_i2c_dma_setup_write(msg->addr,
+					       msg->buf, msg->len, flags);
+			hw_i2c_dma_run(dev, I2C_WRITE);
+		}
 	}
 
-	err = wait_for_completion_interruptible_timeout(
-		&dev->cmd_complete,
-		msecs_to_jiffies(1000)
-		);
-
-	if (err < 0) {
-		dev_dbg(dev->dev, "controler is timed out\n");
+	err = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
+							msecs_to_jiffies(1000)
+	    );
+	if (err <= 0) {
+		dev_dbg(dev->dev, "controller is timed out\n");
 		return -ETIMEDOUT;
 	}
-	if ((!dev->cmd_err) && (msg->flags & I2C_M_RD))
-		hw_i2c_finish_read(msg->buf, msg->len);
 
-	dev_dbg(dev->dev, "<============= Done with err=%d\n", dev->cmd_err);
+	if ((!dev->cmd_err) && (msg->flags & I2C_M_RD))
+		hw_i2c_finish_read(dev, msg->buf, msg->len);
 
+	dev_dbg(dev->dev, "Done with err=%d\n", dev->cmd_err);
 
 	return dev->cmd_err;
 }
 
-
 static int
-stmp378x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+mxs_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 {
 	int i;
 	int err;
@@ -121,7 +327,7 @@ stmp378x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 		return -EINVAL;
 
 	for (i = 0; i < num; i++) {
-		err = stmp378x_i2c_xfer_msg(adap, &msgs[i], (i == (num - 1)));
+		err = mxs_i2c_xfer_msg(adap, &msgs[i], (i == (num - 1)));
 		if (err)
 			break;
 	}
@@ -132,149 +338,171 @@ stmp378x_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	return err;
 }
 
-static u32
-stmp378x_i2c_func(struct i2c_adapter *adap)
+static u32 mxs_i2c_func(struct i2c_adapter *adap)
 {
 	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);
 }
 
-/*
- * Debug. Don't need dma_irq for the final version
- */
-
-static irqreturn_t
-stmp378x_i2c_dma_isr(int this_irq, void *dev_id)
+static irqreturn_t mxs_i2c_dma_isr(int this_irq, void *dev_id)
 {
-	hw_i2c_clear_dma_interrupt();
-	return IRQ_HANDLED;
+	struct mxs_i2c_dev *mxs_i2c = dev_id;
+
+	LIST_HEAD(list);
+	mxs_dma_ack_irq(mxs_i2c->dma_chan);
+	mxs_dma_cooked(mxs_i2c->dma_chan, &list);
 
+	return IRQ_HANDLED;
 }
 
 #define I2C_IRQ_MASK 0x000000FF
-
-static irqreturn_t
-stmp378x_i2c_isr(int this_irq, void *dev_id)
+static irqreturn_t mxs_i2c_isr(int this_irq, void *dev_id)
 {
-	struct stmp378x_i2c_dev *dev = dev_id;
-	u32 stat, ctrl;
+	struct mxs_i2c_dev *mxs_i2c = dev_id;
+	u32 stat;
 	u32 done_mask =
-		BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ |
-		BM_I2C_CTRL1_BUS_FREE_IRQ ;
+	    BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ | BM_I2C_CTRL1_BUS_FREE_IRQ;
 
-	stat = __raw_readl(REGS_I2C_BASE + HW_I2C_CTRL1) & I2C_IRQ_MASK;
+	stat = __raw_readl(mxs_i2c->regbase + HW_I2C_CTRL1) & I2C_IRQ_MASK;
 	if (!stat)
 		return IRQ_NONE;
 
 	if (stat & BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ) {
-		dev->cmd_err = -EREMOTEIO;
+		mxs_i2c->cmd_err = -EREMOTEIO;
 
 		/*
 		 * Stop DMA
 		 * Clear NAK
 		 */
 		__raw_writel(BM_I2C_CTRL1_CLR_GOT_A_NAK,
-			REGS_I2C_BASE + HW_I2C_CTRL1_SET);
-		hw_i2c_reset_dma();
-		reset_i2c_module();
+			     mxs_i2c->regbase + HW_I2C_CTRL1_SET);
+		hw_i2c_dmachan_reset(mxs_i2c);
+		mxs_reset_block((void __iomem *)mxs_i2c->regbase, 1);
+		/* Will catch all error (IRQ mask) */
+		__raw_writel(0x0000FF00, mxs_i2c->regbase + HW_I2C_CTRL1_SET);
 
-		complete(&dev->cmd_complete);
+		complete(&mxs_i2c->cmd_complete);
 
 		goto done;
 	}
 
-/* Don't care about  BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ */
-	if (stat & (
-		    BM_I2C_CTRL1_EARLY_TERM_IRQ |
+	/* Don't care about BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ */
+	if (stat & (BM_I2C_CTRL1_EARLY_TERM_IRQ |
 		    BM_I2C_CTRL1_MASTER_LOSS_IRQ |
-		    BM_I2C_CTRL1_SLAVE_STOP_IRQ |
-		    BM_I2C_CTRL1_SLAVE_IRQ
-		    )) {
-		dev->cmd_err = -EIO;
-		complete(&dev->cmd_complete);
+		    BM_I2C_CTRL1_SLAVE_STOP_IRQ | BM_I2C_CTRL1_SLAVE_IRQ)) {
+		mxs_i2c->cmd_err = -EIO;
+		complete(&mxs_i2c->cmd_complete);
 		goto done;
 	}
-	if ((stat & done_mask)  == done_mask)
-		complete(&dev->cmd_complete);
-
+	if ((stat & done_mask) == done_mask)
+		complete(&mxs_i2c->cmd_complete);
 
 done:
-	__raw_writel(stat, REGS_I2C_BASE + HW_I2C_CTRL1_CLR);
+	__raw_writel(stat, mxs_i2c->regbase + HW_I2C_CTRL1_CLR);
 	return IRQ_HANDLED;
 }
 
-static const struct i2c_algorithm stmp378x_i2c_algo = {
-	.master_xfer	= stmp378x_i2c_xfer,
-	.functionality	= stmp378x_i2c_func,
+static const struct i2c_algorithm mxs_i2c_algo = {
+	.master_xfer = mxs_i2c_xfer,
+	.functionality = mxs_i2c_func,
 };
 
-
-static int
-stmp378x_i2c_probe(struct platform_device *pdev)
+static int mxs_i2c_probe(struct platform_device *pdev)
 {
-	struct stmp378x_i2c_dev	*dev;
-	struct i2c_adapter	*adap;
-	struct resource		*irq;
-	u32 ctrl;
+	struct mxs_i2c_dev *mxs_i2c;
+	struct mxs_i2c_plat_data *pdata;
+	struct i2c_adapter *adap;
+	struct resource *res;
 	int err = 0;
 
-	/* NOTE: driver uses the static register mapping */
-	dev = kzalloc(sizeof(struct stmp378x_i2c_dev), GFP_KERNEL);
-	if (!dev) {
+	mxs_i2c = kzalloc(sizeof(struct mxs_i2c_dev), GFP_KERNEL);
+	if (!mxs_i2c) {
 		dev_err(&pdev->dev, "no mem \n");
 		return -ENOMEM;
 	}
 
-	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0); /* Error */
-	if (!irq) {
+	pdata = pdev->dev.platform_data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no register base resource\n");
+		err = -ENODEV;
+		goto nores;
+	}
+	mxs_i2c->regbase = (unsigned long)IO_ADDRESS(res->start);
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no dma channel resource\n");
+		err = -ENODEV;
+		goto nores;
+	}
+	mxs_i2c->dma_chan = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
 		dev_err(&pdev->dev, "no err_irq resource\n");
 		err = -ENODEV;
 		goto nores;
 	}
-	dev->irq_err = irq->start;
+	mxs_i2c->irq_err = res->start;
 
-	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 1); /* DMA */
-	if (!irq) {
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+	if (!res) {
 		dev_err(&pdev->dev, "no dma_irq resource\n");
 		err = -ENODEV;
 		goto nores;
 	}
+	mxs_i2c->irq_dma = res->start;
 
-	dev->irq_dma = irq->start;
-	dev->dev = &pdev->dev;
+	mxs_i2c->dev = &pdev->dev;
+	mxs_i2c->flags = pdata->pioqueue_mode ?
+	    MXS_I2C_PIOQUEUE_MODE : MXS_I2C_DMA_MODE;
 
-	err = request_irq(dev->irq_err, stmp378x_i2c_isr, 0, pdev->name, dev);
+	err =
+	    request_irq(mxs_i2c->irq_err, mxs_i2c_isr, 0, pdev->name, mxs_i2c);
 	if (err) {
 		dev_err(&pdev->dev, "Can't get IRQ\n");
 		goto no_err_irq;
 	}
 
-	err = request_irq(dev->irq_dma,
-			  stmp378x_i2c_dma_isr,
-			  0, pdev->name, dev);
+	err =
+	    request_irq(mxs_i2c->irq_dma, mxs_i2c_dma_isr, 0, pdev->name,
+			mxs_i2c);
 	if (err) {
 		dev_err(&pdev->dev, "Can't get IRQ\n");
 		goto no_dma_irq;
 	}
 
-	err = hw_i2c_init(&pdev->dev);
-	if (err) {
+	/* reset I2C module */
+	mxs_reset_block((void __iomem *)mxs_i2c->regbase, 1);
+	platform_set_drvdata(pdev, mxs_i2c);
+
+	if (mxs_i2c->flags & MXS_I2C_PIOQUEUE_MODE)
+		__raw_writel(0x04, mxs_i2c->regbase + HW_I2C_QUEUECTRL_SET);
+
+	mxs_i2c->buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (mxs_i2c->buf == NULL) {
 		dev_err(&pdev->dev, "HW Init failed\n");
 		goto init_failed;
+	} else {
+		err = hw_i2c_dma_init(pdev);
+		if (err) {
+			dev_err(&pdev->dev, "HW Init failed\n");
+			goto init_failed;
+		}
 	}
 
 	/* Will catch all error (IRQ mask) */
-	__raw_writel(0x0000FF00,
-		REGS_I2C_BASE + HW_I2C_CTRL1_SET);
+	__raw_writel(0x0000FF00, mxs_i2c->regbase + HW_I2C_CTRL1_SET);
 
-	adap = &dev->adapter;
-	i2c_set_adapdata(adap, dev);
+	adap = &mxs_i2c->adapter;
+	strncpy(adap->name, "MXS I2C adapter", sizeof(adap->name));
 	adap->owner = THIS_MODULE;
 	adap->class = I2C_CLASS_HWMON;
-	strncpy(adap->name, "378x I2C adapter", sizeof(adap->name));
-	adap->algo = &stmp378x_i2c_algo;
+	adap->algo = &mxs_i2c_algo;
 	adap->dev.parent = &pdev->dev;
-
 	adap->nr = pdev->id;
+	i2c_set_adapdata(adap, mxs_i2c);
 	err = i2c_add_numbered_adapter(adap);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to add adapter\n");
@@ -285,61 +513,71 @@ stmp378x_i2c_probe(struct platform_device *pdev)
 	return 0;
 
 no_i2c_adapter:
-	hw_i2c_stop(dev->dev);
+	__raw_writel(BM_I2C_CTRL0_SFTRST, mxs_i2c->regbase + HW_I2C_CTRL0_SET);
+
+	if (mxs_i2c->flags & MXS_I2C_DMA_MODE)
+		hw_i2c_dma_uninit(pdev);
+	else
+		kfree(mxs_i2c->buf);
 init_failed:
-	free_irq(dev->irq_dma, dev);
+	free_irq(mxs_i2c->irq_dma, mxs_i2c);
 no_dma_irq:
-	free_irq(dev->irq_err, dev);
+	free_irq(mxs_i2c->irq_err, mxs_i2c);
 no_err_irq:
 nores:
-	kfree(dev);
+	kfree(mxs_i2c);
 	return err;
 }
 
-static int
-stmp378x_i2c_remove(struct platform_device *pdev)
+static int mxs_i2c_remove(struct platform_device *pdev)
 {
-	struct stmp378x_i2c_dev	*dev = platform_get_drvdata(pdev);
+	struct mxs_i2c_dev *mxs_i2c = platform_get_drvdata(pdev);
 	int res;
 
-	res = i2c_del_adapter(&dev->adapter);
+	res = i2c_del_adapter(&mxs_i2c->adapter);
 	if (res)
 		return -EBUSY;
 
-	hw_i2c_stop(dev->dev);
+	__raw_writel(BM_I2C_CTRL0_SFTRST, mxs_i2c->regbase + HW_I2C_CTRL0_SET);
+
+	if (mxs_i2c->flags & MXS_I2C_DMA_MODE)
+		hw_i2c_dma_uninit(pdev);
+	if (mxs_i2c->flags & MXS_I2C_PIOQUEUE_MODE)
+		hw_i2c_pioq_stop(mxs_i2c);
 
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(dev->irq_err, dev);
-	free_irq(dev->irq_dma, dev);
+	free_irq(mxs_i2c->irq_err, mxs_i2c);
+	free_irq(mxs_i2c->irq_dma, mxs_i2c);
 
-	kfree(dev);
+	kfree(mxs_i2c->buf);
+	kfree(mxs_i2c);
 	return 0;
 }
 
-static struct platform_driver stmp378x_i2c_driver = {
-	.probe		= stmp378x_i2c_probe,
-	.remove		= __devexit_p(stmp378x_i2c_remove),
-	.driver		= {
-		.name	= "i2c_stmp",
-		.owner	= THIS_MODULE,
-	},
+static struct platform_driver mxs_i2c_driver = {
+	.driver = {
+		   .name = "mxs-i2c",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxs_i2c_probe,
+	.remove = __devexit_p(mxs_i2c_remove),
 };
 
-/* I2C may be needed to bring up other drivers */
-
-static int __init stmp378x_i2c_init_driver(void)
+static int __init mxs_i2c_init(void)
 {
-	return platform_driver_register(&stmp378x_i2c_driver);
+	return platform_driver_register(&mxs_i2c_driver);
 }
-subsys_initcall(stmp378x_i2c_init_driver);
 
-static void __exit stmp378x_i2c_exit_driver(void)
+subsys_initcall(mxs_i2c_init);
+
+static void __exit mxs_i2c_exit(void)
 {
-	platform_driver_unregister(&stmp378x_i2c_driver);
+	platform_driver_unregister(&mxs_i2c_driver);
 }
-module_exit(stmp378x_i2c_exit_driver);
 
-MODULE_AUTHOR("old_chap@embeddedalley.com");
-MODULE_DESCRIPTION("IIC for Freescale STMP378x");
+module_exit(mxs_i2c_exit);
+
+MODULE_AUTHOR("Embedded Alley Solutions, Inc/Freescale Inc");
+MODULE_DESCRIPTION("MXS I2C Bus Driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/i2c-mxs.h b/drivers/i2c/busses/i2c-mxs.h
new file mode 100644
index 0000000..4ddca00
--- /dev/null
+++ b/drivers/i2c/busses/i2c-mxs.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _I2C_H
+#define _I2C_H
+
+#define I2C_READ   1
+#define I2C_WRITE  0
+
+struct mxs_i2c_dev {
+	struct device		*dev;
+	void			*buf;
+	unsigned long		regbase;
+	u32			flags;
+#define	MXS_I2C_DMA_MODE	0x1
+#define	MXS_I2C_PIOQUEUE_MODE	0x2
+	int			dma_chan;
+	int			irq_dma;
+	int			irq_err;
+	struct completion	cmd_complete;
+	u32			cmd_err;
+	struct i2c_adapter	adapter;
+	spinlock_t		lock;
+	wait_queue_head_t	queue;
+};
+#endif
-- 
1.5.4.4

