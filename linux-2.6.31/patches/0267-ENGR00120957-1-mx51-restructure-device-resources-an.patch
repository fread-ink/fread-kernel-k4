From 85cc42af7d0d51028906fc53aed49ddb97908571 Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Mon, 15 Feb 2010 13:42:23 -0600
Subject: [PATCH] ENGR00120957-1 mx51: restructure device resources and registration

Separate resources and platform devices from platform data.
Move platform data and device registration to board files.

Signed-off-by: Rob Herring <r.herring@freescale.com>
---
 arch/arm/mach-mx51/Kconfig        |   25 -
 arch/arm/mach-mx51/cpu.c          |   34 +
 arch/arm/mach-mx51/devices.c      | 1827 ++++++++++++++++---------------------
 arch/arm/mach-mx51/devices.h      |   58 ++
 arch/arm/mach-mx51/mx51_3stack.c  |  700 ++++-----------
 arch/arm/mach-mx51/mx51_babbage.c |  472 ++++-------
 arch/arm/plat-mxc/Makefile        |    2 +-
 drivers/video/mxc/tve.c           |    6 -
 8 files changed, 1233 insertions(+), 1891 deletions(-)

diff --git a/arch/arm/mach-mx51/Kconfig b/arch/arm/mach-mx51/Kconfig
index 99ad216..f00ca08 100644
--- a/arch/arm/mach-mx51/Kconfig
+++ b/arch/arm/mach-mx51/Kconfig
@@ -54,29 +54,4 @@ config SDMA_IRAM
 	help
 	  Support Internal RAM as SDMA buffer or control structures
 
-menu "Device options"
-
-config I2C_MXC_SELECT1
-	bool "Enable I2C1 module"
-	default y
-	depends on I2C_MXC
-	help
-	  Enable MX51 I2C1 module.
-
-config I2C_MXC_SELECT2
-	bool "Enable I2C2 module"
-	default n
-	depends on I2C_MXC
-	help
-	  Enable MX51 I2C2 module.
-
-config I2C_MXC_SELECT3
-	bool "Enable I2C3 module"
-	default n
-	depends on I2C_MXC
-	help
-	  Enable MX51 I2C3 module.
-
-endmenu
-
 endmenu
diff --git a/arch/arm/mach-mx51/cpu.c b/arch/arm/mach-mx51/cpu.c
index cac461c..36c58ec 100644
--- a/arch/arm/mach-mx51/cpu.c
+++ b/arch/arm/mach-mx51/cpu.c
@@ -20,10 +20,12 @@
  */
 
 #include <linux/types.h>
+#include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/iram_alloc.h>
 #include <linux/io.h>
+#include <linux/clk.h>
 #include <mach/hardware.h>
 #include "crm_regs.h"
 
@@ -39,12 +41,44 @@ void __init mxc_cpu_init(void)
 		mxc_set_system_rev(0x51, CHIP_REV_1_0);
 }
 
+static void __init mipi_hsc_disable(void)
+{
+	void __iomem *reg_hsc_mcd = ioremap(MIPI_HSC_BASE_ADDR, SZ_4K);
+	void __iomem *reg_hsc_mxt_conf = reg_hsc_mcd + 0x800;
+	struct clk *clk;
+	uint32_t temp;
+
+	/* Temporarily setup MIPI module to legacy mode */
+	clk = clk_get(NULL, "mipi_hsp_clk");
+	if (!IS_ERR(clk)) {
+		clk_enable(clk);
+
+		/* Temporarily setup MIPI module to legacy mode */
+		__raw_writel(0xF00, reg_hsc_mcd);
+
+		/* CSI mode reserved*/
+		temp = __raw_readl(reg_hsc_mxt_conf);
+		__raw_writel(temp | 0x0FF, reg_hsc_mxt_conf);
+
+		if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0) {
+			temp = __raw_readl(reg_hsc_mxt_conf);
+			__raw_writel(temp | 0x10000, reg_hsc_mxt_conf);
+		}
+
+		clk_disable(clk);
+		clk_put(clk);
+	}
+	iounmap(reg_hsc_mcd);
+}
+
 static int __init post_cpu_init(void)
 {
 	void __iomem *base;
 	unsigned int reg;
 	int iram_size = IRAM_SIZE;
 
+	mipi_hsc_disable();
+
 #if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
 	if (cpu_is_mx51())
 		iram_size -= SCC_RAM_SIZE;
diff --git a/arch/arm/mach-mx51/devices.c b/arch/arm/mach-mx51/devices.c
index 0465e57..2c18893 100644
--- a/arch/arm/mach-mx51/devices.c
+++ b/arch/arm/mach-mx51/devices.c
@@ -11,27 +11,21 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-#include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/err.h>
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/spi/spi.h>
 #include <linux/uio_driver.h>
 #include <linux/mxc_scc2_driver.h>
-#include <linux/pwm_backlight.h>
 #include <linux/iram_alloc.h>
-#include <asm/mach-types.h>
 #include <mach/common.h>
 #include <mach/hardware.h>
+#include <mach/gpio.h>
 #include <mach/sdma.h>
-#include <mach/mxc_dvfs.h>
 #include "sdma_script_code.h"
-#include "iomux.h"
 #include "crm_regs.h"
 
 /* Flag used to indicate when IRAM has been initialized */
@@ -101,977 +95,503 @@ void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
 	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
 }
 
-static void mxc_nop_release(struct device *dev)
-{
-	/* Nothing */
-}
-
-#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
-static struct resource w1_resources[] = {
+static struct resource mxc_w1_master_resources[] = {
 	{
-	 .start = MXC_INT_OWIRE,
-	 .flags = IORESOURCE_IRQ,
-	 }
-};
-
-static struct mxc_w1_config mxc_w1_data = {
-	.search_rom_accelerator = 1,
+		.start = OWIRE_BASE_ADDR,
+		.end   = OWIRE_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_OWIRE,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct platform_device mxc_w1_devices = {
+struct platform_device mxc_w1_master_device = {
 	.name = "mxc_w1",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_w1_data,
-		},
-	.num_resources = ARRAY_SIZE(w1_resources),
-	.resource = w1_resources,
-	.id = 0
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_w1_master_resources),
+	.resource = mxc_w1_master_resources,
 };
 
-static void mxc_init_owire(void)
-{
-	(void)platform_device_register(&mxc_w1_devices);
-}
-#else
-static inline void mxc_init_owire(void)
-{
-}
-#endif
+static struct resource mxc_kpp_resources[] = {
+	{
+		.start = KPP_BASE_ADDR,
+		.end = KPP_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_KPP,
+		.end = MXC_INT_KPP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
 
-#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
-static struct mxc_srtc_platform_data srtc_data = {
-	.srtc_sec_mode_addr = 0x83F98840,
+struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
 };
 
 static struct resource rtc_resources[] = {
 	{
-	 .start = SRTC_BASE_ADDR,
-	 .end = SRTC_BASE_ADDR + 0x40,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = SRTC_BASE_ADDR,
+		.end = SRTC_BASE_ADDR + 0x40,
+		.flags = IORESOURCE_MEM,
+	},
 	{
-	 .start = MXC_INT_SRTC_NTZ,
-	 .flags = IORESOURCE_IRQ,
-	 },
+		.start = MXC_INT_SRTC_NTZ,
+		.flags = IORESOURCE_IRQ,
+	},
 };
-static struct platform_device mxc_rtc_device = {
+
+struct platform_device mxc_rtc_device = {
 	.name = "mxc_rtc",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &srtc_data,
-		},
 	.num_resources = ARRAY_SIZE(rtc_resources),
 	.resource = rtc_resources,
 };
-static void mxc_init_rtc(void)
-{
-	(void)platform_device_register(&mxc_rtc_device);
-}
-#else
-static inline void mxc_init_rtc(void)
-{
-}
-#endif
 
-#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+struct platform_device mxc_nandv2_mtd_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+};
+
+static struct resource imx_nfc_resources[] = {
+	{
+		.flags = IORESOURCE_MEM,
+		.start = NFC_BASE_ADDR_AXI + 0x0000,
+		.end   = NFC_BASE_ADDR_AXI + 0x1200 - 1,
+		.name  = IMX_NFC_BUFFERS_ADDR_RES_NAME,
+	},
+	{
+		.flags = IORESOURCE_MEM,
+		.start = NFC_BASE_ADDR_AXI + 0x1E00,
+		.end   = NFC_BASE_ADDR_AXI + 0x1E44 - 1,
+		.name  = IMX_NFC_PRIMARY_REGS_ADDR_RES_NAME,
+	},
+	{
+		.flags = IORESOURCE_MEM,
+		.start = NFC_BASE_ADDR + 0x00,
+		.end   = NFC_BASE_ADDR + 0x34 - 1,
+		.name  = IMX_NFC_SECONDARY_REGS_ADDR_RES_NAME,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+		.start = MXC_INT_NFC,
+		.end   = MXC_INT_NFC,
+		.name  = IMX_NFC_INTERRUPT_RES_NAME,
+	},
+};
+
+struct platform_device imx_nfc_device = {
+	.name = IMX_NFC_DRIVER_NAME,
+	.id = 0,
+	.resource      = imx_nfc_resources,
+	.num_resources = ARRAY_SIZE(imx_nfc_resources),
+};
 
 static struct resource wdt_resources[] = {
 	{
-	 .start = WDOG1_BASE_ADDR,
-	 .end = WDOG1_BASE_ADDR + 0x30,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = WDOG1_BASE_ADDR,
+		.end = WDOG1_BASE_ADDR + 0x30,
+		.flags = IORESOURCE_MEM,
+	},
 };
 
-static struct platform_device mxc_wdt_device = {
+struct platform_device mxc_wdt_device = {
 	.name = "mxc_wdt",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 	.num_resources = ARRAY_SIZE(wdt_resources),
 	.resource = wdt_resources,
 };
 
-static void mxc_init_wdt(void)
-{
-	(void)platform_device_register(&mxc_wdt_device);
-}
-#else
-static inline void mxc_init_wdt(void)
-{
-}
-#endif
-
-#if defined(CONFIG_MXC_PWM)
-static struct resource pwm_resources[] = {
+static struct resource pwm1_resources[] = {
+	{
+		.start = PWM1_BASE_ADDR,
+		.end = PWM1_BASE_ADDR + 0x14,
+		.flags = IORESOURCE_MEM,
+	},
 	{
-	 .start = PWM1_BASE_ADDR,
-	 .end = PWM1_BASE_ADDR + 0x14,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = MXC_INT_PWM1,
+		.end = MXC_INT_PWM1,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct platform_device mxc_pwm_device = {
+struct platform_device mxc_pwm1_device = {
 	.name = "mxc_pwm",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
-	.num_resources = ARRAY_SIZE(pwm_resources),
-	.resource = pwm_resources,
+	.num_resources = ARRAY_SIZE(pwm1_resources),
+	.resource = pwm1_resources,
 };
 
-static void mxc_init_pwm(void)
-{
-	printk(KERN_INFO "mxc_pwm_device registered\n");
-	if (platform_device_register(&mxc_pwm_device) < 0)
-		printk(KERN_ERR "registration of mxc_pwm device failed\n");
-}
-#else
-static void mxc_init_pwm(void)
-{
-
-}
-#endif
+static struct resource pwm2_resources[] = {
+	{
+		.start = PWM2_BASE_ADDR,
+		.end = PWM2_BASE_ADDR + 0x14,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_PWM2,
+		.end = MXC_INT_PWM2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
 
-#if defined(CONFIG_BACKLIGHT_PWM)
-static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
-	.pwm_id = 0,
-	.max_brightness = 255,
-	.dft_brightness = 128,
-	.pwm_period_ns = 78770,
+struct platform_device mxc_pwm2_device = {
+	.name = "mxc_pwm",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(pwm2_resources),
+	.resource = pwm2_resources,
 };
 
-static struct platform_device mxc_pwm_backlight_device = {
+struct platform_device mxc_pwm_backlight_device = {
 	.name = "pwm-backlight",
 	.id = -1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_pwm_backlight_data,
-		},
-};
-
-static void mxc_init_pwm_backlight(void)
-{
-	printk(KERN_INFO "pwm-backlight device registered\n");
-	if (platform_device_register(&mxc_pwm_backlight_device) < 0)
-		printk(KERN_ERR
-		       "registration of pwm-backlight device failed\n");
-}
-#else
-static void mxc_init_pwm_backlight(void)
-{
-
-}
-#endif
-
-#if defined(CONFIG_MXC_IPU_V3) || defined(CONFIG_MXC_IPU_V3_MODULE)
-static struct mxc_ipu_config mxc_ipu_data = {
-	.rev = 1,
 };
 
 static struct resource ipu_resources[] = {
 	{
-	 .start = IPU_CTRL_BASE_ADDR,
-	 .end = IPU_CTRL_BASE_ADDR + SZ_512M,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = IPU_CTRL_BASE_ADDR,
+		.end = IPU_CTRL_BASE_ADDR + SZ_512M,
+		.flags = IORESOURCE_MEM,
+	},
 	{
-	 .start = MXC_INT_IPU_SYN,
-	 .flags = IORESOURCE_IRQ,
-	 },
+		.start = MXC_INT_IPU_SYN,
+		.flags = IORESOURCE_IRQ,
+	},
 	{
-	 .start = MXC_INT_IPU_ERR,
-	 .flags = IORESOURCE_IRQ,
-	 },
+		.start = MXC_INT_IPU_ERR,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct platform_device mxc_ipu_device = {
+struct platform_device mxc_ipu_device = {
 	.name = "mxc_ipu",
 	.id = -1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_ipu_data,
-		},
 	.num_resources = ARRAY_SIZE(ipu_resources),
 	.resource = ipu_resources,
 };
 
-static void mxc_init_ipu(void)
-{
-	void __iomem *reg_hsc_mcd = ioremap(MIPI_HSC_BASE_ADDR, SZ_4K);
-	void __iomem *reg_hsc_mxt_conf = reg_hsc_mcd + 0x800;
-	struct clk *clk;
-	uint32_t temp;
-
-	/* Select IPUv3 h/w version */
-	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
-		mxc_ipu_data.rev = 2;
-
-	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
-	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
-	/* Temporarily setup MIPI module to legacy mode */
-	clk = clk_get(NULL, "mipi_hsp_clk");
-	if (!IS_ERR(clk)) {
-		clk_enable(clk);
-
-		/* Temporarily setup MIPI module to legacy mode */
-		__raw_writel(0xF00, reg_hsc_mcd);
-
-		/* CSI mode reserved*/
-		temp = __raw_readl(reg_hsc_mxt_conf);
-		__raw_writel(temp | 0x0FF, reg_hsc_mxt_conf);
-
-		if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0) {
-			temp = __raw_readl(reg_hsc_mxt_conf);
-			__raw_writel(temp | 0x10000, reg_hsc_mxt_conf);
-		}
-
-		clk_disable(clk);
-		clk_put(clk);
-	}
-	iounmap(reg_hsc_mcd);
-	platform_device_register(&mxc_ipu_device);
-}
-#else
-static inline void mxc_init_ipu(void)
-{
-}
-#endif
+struct platform_device mxc_fb_devices[] = {
+	{
+		.name = "mxc_sdc_fb",
+		.id = 0,
+		.dev = {
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	},
+	{
+		.name = "mxc_sdc_fb",
+		.id = 1,
+		.dev = {
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	},
+	{
+		.name = "mxc_sdc_fb",
+		.id = 2,
+		.dev = {
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	},
+};
 
-#if defined(CONFIG_MXC_VPU) || defined(CONFIG_MXC_VPU_MODULE)
 static struct resource vpu_resources[] = {
-	[0] = {
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = IO_ADDRESS(SRC_BASE_ADDR),
-	       .end = IO_ADDRESS(SRC_BASE_ADDR),
-	       .flags = IORESOURCE_MEM,
-	       },
-};
-
-/*! Platform Data for MXC VPU */
-static struct platform_device mxcvpu_device = {
+	{
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IO_ADDRESS(SRC_BASE_ADDR),
+		.end = IO_ADDRESS(SRC_BASE_ADDR),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start	= MXC_INT_VPU_IDLE,
+		.end	= MXC_INT_VPU_IDLE,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcvpu_device = {
 	.name = "mxc_vpu",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 	.num_resources = ARRAY_SIZE(vpu_resources),
 	.resource = vpu_resources,
 };
 
-static inline void mxc_init_vpu(void)
-{
-	unsigned long addr;
-	iram_alloc(VPU_IRAM_SIZE, &addr);
-	vpu_resources[0].start = addr;
-	vpu_resources[0].end = addr + VPU_IRAM_SIZE - 1;
-	if (platform_device_register(&mxcvpu_device) < 0)
-		printk(KERN_ERR "Error: Registering the VPU.\n");
-}
-#else
-static inline void mxc_init_vpu(void)
-{
-}
-#endif
+static struct resource mxc_fec_resources[] = {
+	{
+		.start	= FEC_BASE_ADDR,
+		.end	= FEC_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= MXC_INT_FEC,
+		.end	= MXC_INT_FEC,
+		.flags	= IORESOURCE_IRQ
+	},
+};
 
-/*!
- * This is platform device structure for adding SCC
- */
-#if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
-static struct platform_device mxc_scc_device = {
-	.name = "mxc_scc",
+struct platform_device mxc_fec_device = {
+	.name = "fec",
 	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_fec_resources),
+	.resource = mxc_fec_resources,
 };
-static void mxc_init_scc(void)
-{
-	platform_device_register(&mxc_scc_device);
-}
-#else
-#define SCM_RD_DELAY	1000000 /* in nanoseconds */
-#define SEC_TO_NANOSEC  1000000000 /*Second to nanoseconds */
-static inline void mxc_init_scc(void)
-{
-	uint32_t reg_value;
-	uint32_t reg_mask = 0;
-	uint8_t *UMID_base;
-	uint32_t *MAP_base;
-	uint8_t i;
-	uint32_t partition_no;
-	uint32_t scc_partno;
-	void *scm_ram_base;
-	void *scc_base;
-	uint8_t iram_partitions = 16;
-	struct timespec stime;
-	struct timespec curtime;
-	long scm_rd_timeout = 0;
-	long cur_ns = 0;
-	long start_ns = 0;
-
-	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
-		iram_partitions = 12;
-
-	scc_base = ioremap((uint32_t) SCC_BASE_ADDR, 0x140);
-	if (scc_base == NULL) {
-		printk(KERN_ERR "FAILED TO MAP IRAM REGS\n");
-		return;
-	}
-	scm_ram_base = ioremap((uint32_t) IRAM_BASE_ADDR, IRAM_SIZE);
-	if (scm_ram_base == NULL) {
-		printk(KERN_ERR "FAILED TO MAP IRAM\n");
-		return;
-	}
-
-	/* Wait for any running SCC operations to finish or fail */
-	getnstimeofday(&stime);
-	do {
-		reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
-		getnstimeofday(&curtime);
-		if (curtime.tv_nsec > stime.tv_nsec)
-			scm_rd_timeout = curtime.tv_nsec - stime.tv_nsec;
-		else{
-			/*Converted second to nanosecond and add to
-			nsec when current nanosec is less than
-			start time nanosec.*/
-			cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
-			curtime.tv_nsec;
-			start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
-				stime.tv_nsec;
-			scm_rd_timeout = cur_ns - start_ns;
-		}
-	} while (((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
-	&& ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_FAIL));
-
-	/* Check for failures */
-	if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY) {
-		/* Special message for bad secret key fuses */
-		if (reg_value & SCM_STATUS_KST_BAD_KEY)
-			printk(KERN_ERR "INVALID SCC KEY FUSE PATTERN\n");
-		else
-		    printk(KERN_ERR "SECURE RAM FAILURE\n");
 
-		iounmap(scm_ram_base);
-		iounmap(scc_base);
-		return;
-	}
-
-	scm_rd_timeout = 0;
-	/* Release final two partitions for SCC2 driver */
-	scc_partno = iram_partitions - (SCC_IRAM_SIZE / SZ_8K);
-	for (partition_no = scc_partno; partition_no < iram_partitions;
-	     partition_no++) {
-		reg_value = (((partition_no << SCM_ZCMD_PART_SHIFT) &
-			SCM_ZCMD_PART_MASK) | ((0x03 << SCM_ZCMD_CCMD_SHIFT) &
-			SCM_ZCMD_CCMD_MASK));
-		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
-		udelay(1);
-		/* Wait for zeroization to complete */
-		getnstimeofday(&stime);
-	    do {
-			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
-		    getnstimeofday(&curtime);
-			if (curtime.tv_nsec > stime.tv_nsec)
-				scm_rd_timeout = curtime.tv_nsec -
-				stime.tv_nsec;
-			else {
-				/*Converted second to nanosecond and add to
-				nsec when current nanosec is less than
-				start time nanosec.*/
-				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
-				curtime.tv_nsec;
-				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
-					stime.tv_nsec;
-				scm_rd_timeout = cur_ns - start_ns;
-		    }
-	    } while (((reg_value & SCM_STATUS_SRS_MASK) !=
-	    SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
-	    SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
-
-		if (scm_rd_timeout > SCM_RD_DELAY)
-			printk(KERN_ERR "SCM Status Register Read timeout"
-			"for Partition No:%d", partition_no);
-
-		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
-			break;
-	}
-
-	/*Check all expected partitions released */
-	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
-	if ((reg_value & reg_mask) != 0) {
-		printk(KERN_ERR "FAILED TO RELEASE IRAM PARTITION\n");
-		iounmap(scm_ram_base);
-		iounmap(scc_base);
-		return;
-	}
-	reg_mask = 0;
-	scm_rd_timeout = 0;
-	/* Allocate remaining partitions for general use */
-	for (partition_no = 0; partition_no < scc_partno; partition_no++) {
-		/* Supervisor mode claims a partition for it's own use
-		by writing zero to SMID register.*/
-	    __raw_writel(0, scc_base + (SCM_SMID0_REG + 8 * partition_no));
-
-		/* Wait for any zeroization to complete */
-		getnstimeofday(&stime);
-	    do {
-			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
-		    getnstimeofday(&curtime);
-		    if (curtime.tv_nsec > stime.tv_nsec)
-				scm_rd_timeout = curtime.tv_nsec -
-				stime.tv_nsec;
-			else{
-				/*Converted second to nanosecond and add to
-				nsec when current nanosec is less than
-				start time nanosec.*/
-				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
-				curtime.tv_nsec;
-				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
-					stime.tv_nsec;
-				scm_rd_timeout = cur_ns - start_ns;
-			}
-	    } while (((reg_value & SCM_STATUS_SRS_MASK) !=
-	    SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
-	    SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
-
-		if (scm_rd_timeout > SCM_RD_DELAY)
-			printk(KERN_ERR "SCM Status Register Read timeout"
-			"for Partition No:%d", partition_no);
-
-		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
-			break;
-		/* Set UMID=0 and permissions for universal data
-		read/write access */
-		MAP_base = scm_ram_base + (partition_no * 0x2000);
-		UMID_base = (uint8_t *) MAP_base + 0x10;
-		for (i = 0; i < 16; i++)
-			UMID_base[i] = 0;
-
-		MAP_base[0] = (SCM_PERM_NO_ZEROIZE | SCM_PERM_HD_SUP_DISABLE |
-			SCM_PERM_HD_READ | SCM_PERM_HD_WRITE |
-			SCM_PERM_HD_EXECUTE | SCM_PERM_TH_READ |
-			SCM_PERM_TH_WRITE);
-		reg_mask |= (3 << (2 * (partition_no)));
-	}
-
-	/* Check all expected partitions allocated */
-	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
-	if ((reg_value & reg_mask) != reg_mask) {
-		printk(KERN_ERR "FAILED TO ACQUIRE IRAM PARTITION\n");
-		iounmap(scm_ram_base);
-		iounmap(scc_base);
-		return;
-	}
-
-	iounmap(scm_ram_base);
-	iounmap(scc_base);
-	printk(KERN_INFO "IRAM READY\n");
-	iram_ready = 1;
-}
-#endif
-
-/* SPI controller and device data */
-#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
-
-#ifdef CONFIG_SPI_MXC_SELECT1
-/*!
- * Resource definition for the CSPI1
- */
 static struct resource mxcspi1_resources[] = {
-	[0] = {
-	       .start = CSPI1_BASE_ADDR,
-	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_CSPI1,
-	       .end = MXC_INT_CSPI1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-extern void mx51_babbage_gpio_spi_chipselect_active(int cspi_mode, int status,
-						    int chipselect);
-extern void mx51_babbage_gpio_spi_chipselect_inactive(int cspi_mode, int status,
-						      int chipselect);
-/*! Platform Data for MXC CSPI1 */
-static struct mxc_spi_master mxcspi1_data = {
-	.maxchipselect = 4,
-	.spi_version = 23,
-};
-
-/*! Device Definition for MXC CSPI1 */
-static struct platform_device mxcspi1_device = {
+	{
+		.start = CSPI1_BASE_ADDR,
+		.end = CSPI1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CSPI1,
+		.end = MXC_INT_CSPI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcspi1_device = {
 	.name = "mxc_spi",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxcspi1_data,
-		},
 	.num_resources = ARRAY_SIZE(mxcspi1_resources),
 	.resource = mxcspi1_resources,
 };
 
-#endif				/* CONFIG_SPI_MXC_SELECT1 */
-
-#ifdef CONFIG_SPI_MXC_SELECT2
-/*!
- * Resource definition for the CSPI2
- */
 static struct resource mxcspi2_resources[] = {
-	[0] = {
-	       .start = CSPI2_BASE_ADDR,
-	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_CSPI2,
-	       .end = MXC_INT_CSPI2,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC CSPI2 */
-static struct mxc_spi_master mxcspi2_data = {
-	.maxchipselect = 4,
-	.spi_version = 23,
-};
-
-/*! Device Definition for MXC CSPI2 */
-static struct platform_device mxcspi2_device = {
+	{
+		.start = CSPI2_BASE_ADDR,
+		.end = CSPI2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CSPI2,
+		.end = MXC_INT_CSPI2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcspi2_device = {
 	.name = "mxc_spi",
 	.id = 1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxcspi2_data,
-		},
 	.num_resources = ARRAY_SIZE(mxcspi2_resources),
 	.resource = mxcspi2_resources,
 };
-#endif				/* CONFIG_SPI_MXC_SELECT2 */
 
-#ifdef CONFIG_SPI_MXC_SELECT3
-/*!
- * Resource definition for the CSPI3
- */
 static struct resource mxcspi3_resources[] = {
-	[0] = {
-	       .start = CSPI3_BASE_ADDR,
-	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_CSPI,
-	       .end = MXC_INT_CSPI,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC CSPI3 */
-static struct mxc_spi_master mxcspi3_data = {
-	.maxchipselect = 4,
-	.spi_version = 7,
-};
-
-/*! Device Definition for MXC CSPI3 */
-static struct platform_device mxcspi3_device = {
+	{
+		.start = CSPI3_BASE_ADDR,
+		.end = CSPI3_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CSPI,
+		.end = MXC_INT_CSPI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcspi3_device = {
 	.name = "mxc_spi",
 	.id = 2,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxcspi3_data,
-		},
 	.num_resources = ARRAY_SIZE(mxcspi3_resources),
 	.resource = mxcspi3_resources,
 };
-#endif				/* CONFIG_SPI_MXC_SELECT3 */
 
-void __init mxc_init_spi(void)
-{
-#ifdef CONFIG_SPI_MXC_SELECT1
-	if (machine_is_mx51_babbage()) {
-		mxcspi1_data.chipselect_active =
-			mx51_babbage_gpio_spi_chipselect_active;
-		mxcspi1_data.chipselect_inactive =
-			mx51_babbage_gpio_spi_chipselect_inactive;
-	}
-	if (platform_device_register(&mxcspi1_device) < 0)
-		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
-#endif				/* CONFIG_SPI_MXC_SELECT1 */
-#ifdef CONFIG_SPI_MXC_SELECT2
-	if (platform_device_register(&mxcspi2_device) < 0)
-		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
-#endif				/* CONFIG_SPI_MXC_SELECT2 */
-#ifdef CONFIG_SPI_MXC_SELECT3
-	if (platform_device_register(&mxcspi3_device) < 0)
-		printk(KERN_ERR "Error: Registering the SPI Controller_3\n");
-#endif				/* CONFIG_SPI_MXC_SELECT3 */
-}
-#else
-void __init mxc_init_spi(void)
-{
-}
-#endif
-
-/* I2C controller and device data */
-#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
-
-#ifdef CONFIG_I2C_MXC_SELECT1
-/*!
- * Resource definition for the I2C1
- */
 static struct resource mxci2c1_resources[] = {
-	[0] = {
-	       .start = I2C1_BASE_ADDR,
-	       .end = I2C1_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_I2C1,
-	       .end = MXC_INT_I2C1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC I2C */
-static struct mxc_i2c_platform_data mxci2c1_data = {
-	.i2c_clk = 100000,
+	{
+		.start = I2C1_BASE_ADDR,
+		.end = I2C1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_I2C1,
+		.end = MXC_INT_I2C1,
+		.flags = IORESOURCE_IRQ,
+	},
 };
-#endif
 
-#ifdef CONFIG_I2C_MXC_SELECT2
-/*!
- * Resource definition for the I2C2
- */
 static struct resource mxci2c2_resources[] = {
-	[0] = {
-	       .start = I2C2_BASE_ADDR,
-	       .end = I2C2_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_I2C2,
-	       .end = MXC_INT_I2C2,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC I2C */
-static struct mxc_i2c_platform_data mxci2c2_data = {
-	.i2c_clk = 100000,
+	{
+		.start = I2C2_BASE_ADDR,
+		.end = I2C2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_I2C2,
+		.end = MXC_INT_I2C2,
+		.flags = IORESOURCE_IRQ,
+	},
 };
-#endif
 
-#ifdef CONFIG_I2C_MXC_SELECT3
-/*!
- * Resource definition for the I2C3
- */
-static struct resource mxci2c3_resources[] = {
-	[0] = {
-	       .start = I2C3_BASE_ADDR,
-	       .end = I2C3_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_I2C3,
-	       .end = MXC_INT_I2C3,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC I2C */
-static struct mxc_i2c_platform_data mxci2c3_data = {
-	.i2c_clk = 100000,
-};
-#endif
 
-/*! Device Definition for MXC I2C1 */
-static struct platform_device mxci2c_devices[] = {
-#ifdef CONFIG_I2C_MXC_SELECT1
+struct platform_device mxci2c_devices[] = {
 	{
-	 .name = "mxc_i2c",
-	 .id = 0,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .platform_data = &mxci2c1_data,
-		 },
-	 .num_resources = ARRAY_SIZE(mxci2c1_resources),
-	 .resource = mxci2c1_resources,},
-#endif
-#ifdef CONFIG_I2C_MXC_SELECT2
-	{
-	 .name = "mxc_i2c",
-	 .id = 1,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .platform_data = &mxci2c2_data,
-		 },
-	 .num_resources = ARRAY_SIZE(mxci2c2_resources),
-	 .resource = mxci2c2_resources,},
-#endif
-#ifdef CONFIG_I2C_MXC_SELECT3
-	{
-	 .name = "mxc_i2c",
-	 .id = 2,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .platform_data = &mxci2c3_data,
-		 },
-	 .num_resources = ARRAY_SIZE(mxci2c3_resources),
-	 .resource = mxci2c3_resources,},
-#endif
+		.name = "mxc_i2c",
+		.id = 0,
+		.num_resources = ARRAY_SIZE(mxci2c1_resources),
+		.resource = mxci2c1_resources,
+	},
+	{
+		.name = "mxc_i2c",
+		.id = 1,
+		.num_resources = ARRAY_SIZE(mxci2c2_resources),
+		.resource = mxci2c2_resources,
+	},
 };
 
-static inline void mxc_init_i2c(void)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(mxci2c_devices); i++) {
-		if (platform_device_register(&mxci2c_devices[i]) < 0)
-			dev_err(&mxci2c_devices[i].dev,
-				"Unable to register I2C device\n");
-	}
-}
-#else
-static inline void mxc_init_i2c(void)
-{
-}
-#endif
-
-#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
 static struct resource mxci2c_hs_resources[] = {
-	[0] = {
-	       .start = HSI2C_DMA_BASE_ADDR,
-	       .end = HSI2C_DMA_BASE_ADDR + SZ_16K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_HS_I2C,
-	       .end = MXC_INT_HS_I2C,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC I2C */
-static struct mxc_i2c_platform_data mxci2c_hs_data = {
-	.i2c_clk = 400000,
+	{
+		.start = HSI2C_DMA_BASE_ADDR,
+		.end = HSI2C_DMA_BASE_ADDR + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_HS_I2C,
+		.end = MXC_INT_HS_I2C,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct platform_device mxci2c_hs_device = {
+struct platform_device mxci2c_hs_device = {
 	.name = "mxc_i2c_hs",
 	.id = 3,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxci2c_hs_data,
-		},
 	.num_resources = ARRAY_SIZE(mxci2c_hs_resources),
 	.resource = mxci2c_hs_resources
 };
 
-static inline void mxc_init_i2c_hs(void)
-{
-	if (platform_device_register(&mxci2c_hs_device) < 0)
-		dev_err(&mxci2c_hs_device.dev,
-			"Unable to register High Speed I2C device\n");
-}
-#else
-static inline void mxc_init_i2c_hs(void)
-{
-}
-#endif
+static struct resource ssi1_resources[] = {
+	{
+		.start = SSI1_BASE_ADDR,
+		.end = SSI1_BASE_ADDR + 0x5C,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SSI1,
+		.end = MXC_INT_SSI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
 
-#if defined(CONFIG_FB_MXC_TVOUT_TVE) || defined(CONFIG_FB_MXC_TVOUT_TVE_MODULE)
-static struct resource tve_resources[] = {
+struct platform_device mxc_ssi1_device = {
+	.name = "mxc_ssi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(ssi1_resources),
+	.resource = ssi1_resources,
+};
+
+static struct resource ssi2_resources[] = {
 	{
-	 .start = TVE_BASE_ADDR,
-	 .end = TVE_BASE_ADDR + SZ_4K - 1,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = SSI2_BASE_ADDR,
+		.end = SSI2_BASE_ADDR + 0x5C,
+		.flags = IORESOURCE_MEM,
+	},
 	{
-	 .start = MXC_INT_TVE,
-	 .flags = IORESOURCE_IRQ,
-	 },
+		.start = MXC_INT_SSI2,
+		.end = MXC_INT_SSI2,
+		.flags = IORESOURCE_IRQ,
+	},
 };
-static struct tve_platform_data tve_data = {
-	.dac_reg = "VVIDEO",
-	.dig_reg = "VDIG",
+
+struct platform_device mxc_ssi2_device = {
+	.name = "mxc_ssi",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(ssi2_resources),
+	.resource = ssi2_resources,
+};
+
+static struct resource tve_resources[] = {
+	{
+		.start = TVE_BASE_ADDR,
+		.end = TVE_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_TVE,
+		.end = MXC_INT_TVE,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct platform_device mxc_tve_device = {
+struct platform_device mxc_tve_device = {
 	.name = "tve",
-	.dev = {
-		.platform_data = &tve_data,
-		.release = mxc_nop_release,
-		},
 	.num_resources = ARRAY_SIZE(tve_resources),
 	.resource = tve_resources,
 };
 
-void __init mxc_init_tve(void)
-{
-	platform_device_register(&mxc_tve_device);
-}
-#else
-static inline void mxc_init_tve(void)
-{
-}
-#endif
-
-/*!
- * Resource definition for the DVFS CORE
- */
 static struct resource dvfs_core_resources[] = {
-	[0] = {
-	       .start = MXC_DVFS_CORE_BASE,
-	       .end = MXC_DVFS_CORE_BASE + 4 * SZ_16 - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_GPC1,
-	       .end = MXC_INT_GPC1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for DVFS CORE */
-struct mxc_dvfs_platform_data dvfs_core_data = {
-	.reg_id = "SW1",
-	.clk1_id = "cpu_clk",
-	.clk2_id = "gpc_dvfs_clk",
-	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
-	.gpc_vcr_reg_addr = MXC_GPC_VCR,
-	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
-	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
-	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
-	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
-	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
-	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
-	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
-	.prediv_mask = 0x1F800,
-	.prediv_offset = 11,
-	.prediv_val = 3,
-	.div3ck_mask = 0xE0000000,
-	.div3ck_offset = 29,
-	.div3ck_val = 2,
-	.emac_val = 0x08,
-	.upthr_val = 25,
-	.dnthr_val = 9,
-	.pncthr_val = 33,
-	.upcnt_val = 10,
-	.dncnt_val = 10,
-	.delay_time = 30,
-	.num_wp = 3,
-};
-
-/*! Device Definition for MXC DVFS core */
-static struct platform_device mxc_dvfs_core_device = {
+	{
+		.start = MXC_DVFS_CORE_BASE,
+		.end = MXC_DVFS_CORE_BASE + 4 * SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_GPC1,
+		.end = MXC_INT_GPC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_dvfs_core_device = {
 	.name = "mxc_dvfs_core",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &dvfs_core_data,
-		},
 	.num_resources = ARRAY_SIZE(dvfs_core_resources),
 	.resource = dvfs_core_resources,
 };
 
-static inline void mxc_init_dvfs_core(void)
-{
-	if (platform_device_register(&mxc_dvfs_core_device) < 0)
-		dev_err(&mxc_dvfs_core_device.dev,
-			"Unable to register DVFS core device\n");
-}
-
-/*!
- * Resource definition for the DVFS PER
- */
 static struct resource dvfs_per_resources[] = {
-	[0] = {
-	       .start = DVFSPER_BASE_ADDR,
-	       .end = DVFSPER_BASE_ADDR + 2 * SZ_16 - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_GPC1,
-	       .end = MXC_INT_GPC1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Platform Data for MXC DVFS PER*/
-struct mxc_dvfsper_data dvfs_per_data = {
-	.reg_id = "SW2",
-	.clk_id = "gpc_dvfs_clk",
-	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
-	.gpc_vcr_reg_addr = MXC_GPC_VCR,
-	.gpc_adu = 0x0,
-	.vai_mask = MXC_DVFSPMCR0_FSVAI_MASK,
-	.vai_offset = MXC_DVFSPMCR0_FSVAI_OFFSET,
-	.dvfs_enable_bit = MXC_DVFSPMCR0_DVFEN,
-	.irq_mask = MXC_DVFSPMCR0_FSVAIM,
-	.div3_offset = 0,
-	.div3_mask = 0x7,
-	.div3_div = 2,
-	.lp_high = 1200000,
-	.lp_low = 1200000,
-};
-
-/*! Device Definition for MXC DVFS Peripheral*/
-static struct platform_device mxc_dvfs_per_device = {
+	{
+		.start = DVFSPER_BASE_ADDR,
+		.end = DVFSPER_BASE_ADDR + 2 * SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_GPC1,
+		.end = MXC_INT_GPC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_dvfs_per_device = {
 	 .name = "mxc_dvfsper",
 	 .id = 0,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .platform_data = &dvfs_per_data,
-		 },
 	 .num_resources = ARRAY_SIZE(dvfs_per_resources),
 	 .resource = dvfs_per_resources,
 };
 
-static inline void mxc_init_dvfs_per(void)
-{
-	if (platform_device_register(&mxc_dvfs_per_device) < 0) {
-		dev_err(&mxc_dvfs_per_device.dev,
-				"Unable to register DVFS device\n");
-	} else {
-		printk(KERN_INFO "mxc_init_dvfs_per initialised\n");
-	}
-	return;
-}
-
 struct mxc_gpio_port mxc_gpio_ports[] = {
-	[0] = {
-	 .chip.label = "gpio-0",
-	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
-	 .irq = MXC_INT_GPIO1_LOW,
-	 .irq_high = MXC_INT_GPIO1_HIGH,
-	 .virtual_irq_start = MXC_GPIO_IRQ_START
-	 },
-	[1] = {
-	 .chip.label = "gpio-1",
-	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
-	 .irq = MXC_INT_GPIO2_LOW,
-	 .irq_high = MXC_INT_GPIO2_HIGH,
-	 .virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 1
-	 },
-	[2] = {
-	 .chip.label = "gpio-2",
-	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
-	 .irq = MXC_INT_GPIO3_LOW,
-	 .irq_high = MXC_INT_GPIO3_HIGH,
-	 .virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 2
-	 },
-	[3] = {
-	 .chip.label = "gpio-3",
-	 .base = IO_ADDRESS(GPIO4_BASE_ADDR),
-	 .irq = MXC_INT_GPIO4_LOW,
-	 .irq_high = MXC_INT_GPIO4_HIGH,
-	 .virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
-	 }
+	{
+		.chip.label = "gpio-0",
+		.base = IO_ADDRESS(GPIO1_BASE_ADDR),
+		.irq = MXC_INT_GPIO1_LOW,
+		.irq_high = MXC_INT_GPIO1_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START
+	},
+	{
+		.chip.label = "gpio-1",
+		.base = IO_ADDRESS(GPIO2_BASE_ADDR),
+		.irq = MXC_INT_GPIO2_LOW,
+		.irq_high = MXC_INT_GPIO2_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 1
+	},
+	{
+		.chip.label = "gpio-2",
+		.base = IO_ADDRESS(GPIO3_BASE_ADDR),
+		.irq = MXC_INT_GPIO3_LOW,
+		.irq_high = MXC_INT_GPIO3_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 2
+	},
+	{
+		.chip.label = "gpio-3",
+		.base = IO_ADDRESS(GPIO4_BASE_ADDR),
+		.irq = MXC_INT_GPIO4_LOW,
+		.irq_high = MXC_INT_GPIO4_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
+	},
 };
 
 int __init mxc_register_gpios(void)
@@ -1079,189 +599,317 @@ int __init mxc_register_gpios(void)
 	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
 }
 
-static struct platform_device mxc_dma_device = {
-	.name = "mxc_dma",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
-};
-
-static inline void mxc_init_dma(void)
-{
-	(void)platform_device_register(&mxc_dma_device);
-}
-
 static struct resource spdif_resources[] = {
 	{
-	 .start = SPDIF_BASE_ADDR,
-	 .end = SPDIF_BASE_ADDR + 0x50,
-	 .flags = IORESOURCE_MEM,
-	 },
-};
-
-static struct mxc_spdif_platform_data mxc_spdif_data = {
-	.spdif_tx = 1,
-	.spdif_rx = 0,
-	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
-	.spdif_clk_48000 = 7,	/* audio osc source */
-	.spdif_clkid = 0,
-	.spdif_clk = NULL,	/* spdif bus clk */
+		.start = SPDIF_BASE_ADDR,
+		.end = SPDIF_BASE_ADDR + 0x50,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SPDIF,
+		.end = MXC_INT_SPDIF,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct platform_device mxc_alsa_spdif_device = {
+struct platform_device mxc_alsa_spdif_device = {
 	.name = "mxc_alsa_spdif",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_spdif_data,
-		},
 	.num_resources = ARRAY_SIZE(spdif_resources),
 	.resource = spdif_resources,
 };
 
-static inline void mxc_init_spdif(void)
-{
-	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
-	clk_put(mxc_spdif_data.spdif_core_clk);
-	platform_device_register(&mxc_alsa_spdif_device);
-}
-
-static struct platform_device mx51_lpmode_device = {
+struct platform_device mx51_lpmode_device = {
 	.name = "mx51_lpmode",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 };
 
-static inline void mx51_init_lpmode(void)
-{
-	(void)platform_device_register(&mx51_lpmode_device);
-}
-
-static struct platform_device busfreq_device = {
+struct platform_device busfreq_device = {
 	.name = "busfreq",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 };
 
-static inline void mxc_init_busfreq(void)
-{
-	(void)platform_device_register(&busfreq_device);
-}
-
 static struct resource mxc_m4if_resources[] = {
 	{
-	 .start = M4IF_BASE_ADDR,
-	 .end = M4IF_BASE_ADDR + SZ_4K - 1,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = M4IF_BASE_ADDR,
+		.end = M4IF_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
 };
 
-static struct platform_device sdram_autogating_device = {
+struct platform_device sdram_autogating_device = {
 	.name = "sdram_autogating",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 	.resource = mxc_m4if_resources,
 	.num_resources = ARRAY_SIZE(mxc_m4if_resources),
 };
 
-static inline void mxc_init_sdram_autogating(void)
-{
-	(void)platform_device_register(&sdram_autogating_device);
-}
-
-#if defined(CONFIG_MXC_IIM) || defined(CONFIG_MXC_IIM_MODULE)
 static struct resource mxc_iim_resources[] = {
 	{
-	 .start = IIM_BASE_ADDR,
-	 .end = IIM_BASE_ADDR + SZ_4K - 1,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = IIM_BASE_ADDR,
+		.end = IIM_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
 };
 
-static struct platform_device mxc_iim_device = {
+struct platform_device mxc_iim_device = {
 	.name = "mxc_iim",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 	.num_resources = ARRAY_SIZE(mxc_iim_resources),
 	.resource = mxc_iim_resources
 };
 
-static inline void mxc_init_iim(void)
-{
-	if (platform_device_register(&mxc_iim_device) < 0)
-		dev_err(&mxc_iim_device.dev,
-			"Unable to register mxc iim device\n");
-}
-#else
-static inline void mxc_init_iim(void)
-{
-}
-#endif
+static struct resource mxc_sim_resources[] = {
+	{
+		.start = SIM_BASE_ADDR,
+		.end = SIM_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SIM_IPB,
+		.end = MXC_INT_SIM_IPB,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MXC_INT_SIM_DAT,
+		.end = MXC_INT_SIM_DAT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_sim_device = {
+	.name = "mxc_sim",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_sim_resources),
+	.resource = mxc_sim_resources,
+};
+
+static struct resource mxcsdhc1_resources[] = {
+	{
+		.start = MMC_SDHC1_BASE_ADDR,
+		.end = MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_MMC_SDHC1,
+		.end = MXC_INT_MMC_SDHC1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mxcsdhc2_resources[] = {
+	{
+		.start = MMC_SDHC2_BASE_ADDR,
+		.end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_MMC_SDHC2,
+		.end = MXC_INT_MMC_SDHC2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcsdhc1_device = {
+	.name = "mxsdhci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+struct platform_device mxcsdhc2_device = {
+	.name = "mxsdhci",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+static struct resource pata_fsl_resources[] = {
+	{
+		.start = ATA_BASE_ADDR,
+		.end = ATA_BASE_ADDR + 0x000000C8,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_ATA,
+		.end = MXC_INT_ATA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pata_fsl_device = {
+	.name = "pata_fsl",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pata_fsl_resources),
+	.resource = pata_fsl_resources,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static u64 usb_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource usbotg_resources[] = {
+	{
+		.start = OTG_BASE_ADDR,
+		.end = OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource usbotg_xcvr_resources[] = {
+	{
+		.start = OTG_BASE_ADDR,
+		.end = OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_usbdr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource      = usbotg_resources,
+	.num_resources = ARRAY_SIZE(usbotg_resources),
+};
+
+struct platform_device mxc_usbdr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource      = usbotg_xcvr_resources,
+	.num_resources = ARRAY_SIZE(usbotg_xcvr_resources),
+};
+
+struct platform_device mxc_usbdr_host_device = {
+	.name = "fsl-ehci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(usbotg_resources),
+	.resource = usbotg_resources,
+	.dev = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static struct resource usbh1_resources[] = {
+	{
+		.start = OTG_BASE_ADDR + 0x200,
+		.end = OTG_BASE_ADDR + 0x200 + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_USB_H1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_usbh1_device = {
+	.name = "fsl-ehci",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(usbh1_resources),
+	.resource = usbh1_resources,
+	.dev = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static struct resource usbh2_resources[] = {
+	{
+		.start = OTG_BASE_ADDR + 0x400,
+		.end = OTG_BASE_ADDR + 0x400 + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_USB_H2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_usbh2_device = {
+	.name = "fsl-ehci",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(usbh2_resources),
+	.resource = usbh2_resources,
+	.dev = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
 
 static struct resource mxc_gpu_resources[] = {
-	[0] = {
+	{
 		.start = MXC_INT_GPU2_IRQ,
 		.end = MXC_INT_GPU2_IRQ,
 		.name = "gpu_2d_irq",
-		.flags = IORESOURCE_IRQ,},
-	[1] = {
+		.flags = IORESOURCE_IRQ,
+	},
+	{
 		.start = MXC_INT_GPU,
 		.end = MXC_INT_GPU,
 		.name = "gpu_3d_irq",
-		.flags = IORESOURCE_IRQ,},
-	[2] = {
+		.flags = IORESOURCE_IRQ,
+	},
+	{
 		.start = GPU2D_BASE_ADDR,
 		.end = GPU2D_BASE_ADDR + SZ_4K - 1,
 		.name = "gpu_2d_registers",
-		.flags = IORESOURCE_MEM,},
-	[3] = {
+		.flags = IORESOURCE_MEM,
+	},
+	{
 		.start = GPU_BASE_ADDR,
 		.end = GPU_BASE_ADDR + SZ_128K - 1,
 		.name = "gpu_3d_registers",
-		.flags = IORESOURCE_MEM,},
-	[4] = {
+		.flags = IORESOURCE_MEM,
+	},
+	{
 		.start = GPU_GMEM_BASE_ADDR,
 		.end = GPU_GMEM_BASE_ADDR + SZ_128K - 1,
 		.name = "gpu_graphics_mem",
-		.flags = IORESOURCE_MEM,},
+		.flags = IORESOURCE_MEM,
+	},
 };
 
-static struct platform_device gpu_device = {
+struct platform_device gpu_device = {
 	.name = "mxc_gpu",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
 	.num_resources = ARRAY_SIZE(mxc_gpu_resources),
 	.resource = mxc_gpu_resources,
 };
 
-static void __init mxc_init_gpu(void)
-{
-	platform_device_register(&gpu_device);
-}
-
 static struct resource mxc_gpu2d_resources[] = {
 	{
-	 .start = GPU2D_BASE_ADDR,
-	 .end = GPU2D_BASE_ADDR + SZ_4K - 1,
-	 .flags = IORESOURCE_MEM,
-	 },
+		.start = GPU2D_BASE_ADDR,
+		.end = GPU2D_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
 	{
-	 .flags = IORESOURCE_MEM,
-	 },
+		.flags = IORESOURCE_MEM,
+	},
 	{
-	 .flags = IORESOURCE_MEM,
-	 },
+		.flags = IORESOURCE_MEM,
+	},
 };
 
 #if defined(CONFIG_UIO_PDRV_GENIRQ) || defined(CONFIG_UIO_PDRV_GENIRQ_MODULE)
@@ -1314,9 +962,8 @@ static struct uio_info gpu2d_info = {
 static struct platform_device mxc_gpu2d_device = {
 	.name = "uio_pdrv_genirq",
 	.dev = {
-		.release = mxc_nop_release,
 		.platform_data = &gpu2d_info,
-		.coherent_dma_mask = 0xFFFFFFFF,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
 		},
 	.num_resources = ARRAY_SIZE(mxc_gpu2d_resources),
 	.resource = mxc_gpu2d_resources,
@@ -1350,89 +997,197 @@ void __init mx51_init_irq(void)
 	mxc_tzic_init_irq(tzic_addr);
 }
 
-#if defined(CONFIG_SND_MXC_SOC_SSI) || defined(CONFIG_SND_MXC_SOC_SSI_MODULE)
+#define SCM_RD_DELAY	1000000 /* in nanoseconds */
+#define SEC_TO_NANOSEC  1000000000 /*Second to nanoseconds */
+static __init void mxc_init_scc_iram(void)
+{
+	uint32_t reg_value;
+	uint32_t reg_mask = 0;
+	uint8_t *UMID_base;
+	uint32_t *MAP_base;
+	uint8_t i;
+	uint32_t partition_no;
+	uint32_t scc_partno;
+	void *scm_ram_base;
+	void *scc_base;
+	uint8_t iram_partitions = 16;
+	struct timespec stime;
+	struct timespec curtime;
+	long scm_rd_timeout = 0;
+	long cur_ns = 0;
+	long start_ns = 0;
 
-static struct resource ssi1_resources[] = {
-	{
-	 .start = SSI1_BASE_ADDR,
-	 .end = SSI1_BASE_ADDR + 0x5C,
-	 .flags = IORESOURCE_MEM,
-	 },
-	{
-	 .start = MXC_INT_SSI1,
-	 .end = MXC_INT_SSI1,
-	 .flags = IORESOURCE_IRQ,
-	},
-};
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		iram_partitions = 12;
 
-static struct platform_device mxc_alsa_ssi1_device = {
-	.name = "mxc_ssi",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		},
-	.num_resources = ARRAY_SIZE(ssi1_resources),
-	.resource = ssi1_resources,
-};
+	scc_base = ioremap((uint32_t) SCC_BASE_ADDR, 0x140);
+	if (scc_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP IRAM REGS\n");
+		return;
+	}
+	scm_ram_base = ioremap((uint32_t) IRAM_BASE_ADDR, IRAM_SIZE);
+	if (scm_ram_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP IRAM\n");
+		return;
+	}
 
-static struct resource ssi2_resources[] = {
-	{
-	 .start = SSI2_BASE_ADDR,
-	 .end = SSI2_BASE_ADDR + 0x5C,
-	 .flags = IORESOURCE_MEM,
-	 },
-	{
-	 .start = MXC_INT_SSI2,
-	 .end = MXC_INT_SSI2,
-	 .flags = IORESOURCE_IRQ,
-	},
-};
+	/* Wait for any running SCC operations to finish or fail */
+	getnstimeofday(&stime);
+	do {
+		reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec > stime.tv_nsec)
+			scm_rd_timeout = curtime.tv_nsec - stime.tv_nsec;
+		else{
+			/*Converted second to nanosecond and add to
+			nsec when current nanosec is less than
+			start time nanosec.*/
+			cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+			curtime.tv_nsec;
+			start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+				stime.tv_nsec;
+			scm_rd_timeout = cur_ns - start_ns;
+		}
+	} while (((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+	&& ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_FAIL));
 
-static struct platform_device mxc_alsa_ssi2_device = {
-	.name = "mxc_ssi",
-	.id = 1,
-	.dev = {
-		.release = mxc_nop_release,
-		},
-	.num_resources = ARRAY_SIZE(ssi2_resources),
-	.resource = ssi2_resources,
-};
+	/* Check for failures */
+	if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY) {
+		/* Special message for bad secret key fuses */
+		if (reg_value & SCM_STATUS_KST_BAD_KEY)
+			printk(KERN_ERR "INVALID SCC KEY FUSE PATTERN\n");
+		else
+		    printk(KERN_ERR "SECURE RAM FAILURE\n");
 
-static inline void mxc_init_ssi(void)
-{
-	platform_device_register(&mxc_alsa_ssi1_device);
-	platform_device_register(&mxc_alsa_ssi2_device);
-}
-#else
-static inline void mxc_init_ssi(void)
-{
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	scm_rd_timeout = 0;
+	/* Release final two partitions for SCC2 driver */
+	scc_partno = iram_partitions - (SCC_IRAM_SIZE / SZ_8K);
+	for (partition_no = scc_partno; partition_no < iram_partitions;
+	     partition_no++) {
+		reg_value = (((partition_no << SCM_ZCMD_PART_SHIFT) &
+			SCM_ZCMD_PART_MASK) | ((0x03 << SCM_ZCMD_CCMD_SHIFT) &
+			SCM_ZCMD_CCMD_MASK));
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		udelay(1);
+		/* Wait for zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else {
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+	}
+
+	/*Check all expected partitions released */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != 0) {
+		printk(KERN_ERR "FAILED TO RELEASE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+	reg_mask = 0;
+	scm_rd_timeout = 0;
+	/* Allocate remaining partitions for general use */
+	for (partition_no = 0; partition_no < scc_partno; partition_no++) {
+		/* Supervisor mode claims a partition for it's own use
+		by writing zero to SMID register.*/
+		__raw_writel(0, scc_base + (SCM_SMID0_REG + 8 * partition_no));
+
+		/* Wait for any zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else{
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+		/* Set UMID=0 and permissions for universal data
+		read/write access */
+		MAP_base = scm_ram_base + (partition_no * 0x2000);
+		UMID_base = (uint8_t *) MAP_base + 0x10;
+		for (i = 0; i < 16; i++)
+			UMID_base[i] = 0;
+
+		MAP_base[0] = (SCM_PERM_NO_ZEROIZE | SCM_PERM_HD_SUP_DISABLE |
+			SCM_PERM_HD_READ | SCM_PERM_HD_WRITE |
+			SCM_PERM_HD_EXECUTE | SCM_PERM_TH_READ |
+			SCM_PERM_TH_WRITE);
+		reg_mask |= (3 << (2 * (partition_no)));
+	}
+
+	/* Check all expected partitions allocated */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != reg_mask) {
+		printk(KERN_ERR "FAILED TO ACQUIRE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	iounmap(scm_ram_base);
+	iounmap(scc_base);
+	printk(KERN_INFO "IRAM READY\n");
+	iram_ready = 1;
 }
-#endif /* CONFIG_SND_MXC_SOC_SSI */
 
 int __init mxc_init_devices(void)
 {
-	mxc_init_wdt();
-	mxc_init_spi();
-	mxc_init_i2c();
-	mxc_init_i2c_hs();
-	mxc_init_rtc();
-	mxc_init_scc();
-	mxc_init_dma();
-	mxc_init_owire();
-	mxc_init_ipu();
-	mxc_init_vpu();
-	mxc_init_spdif();
-	mxc_init_tve();
-	mx51_init_lpmode();
-	mxc_init_busfreq();
-	mxc_init_sdram_autogating();
-	mxc_init_dvfs_core();
-	mxc_init_dvfs_per();
-	mxc_init_iim();
-	mxc_init_gpu();
+	unsigned long addr;
+
+	iram_alloc(VPU_IRAM_SIZE, &addr);
+	vpu_resources[0].start = addr;
+	vpu_resources[0].end = addr + VPU_IRAM_SIZE - 1;
+
+	mxc_init_scc_iram();
 	mxc_init_gpu2d();
-	mxc_init_pwm();
-	mxc_init_pwm_backlight();
-	mxc_init_ssi();
 	return 0;
 }
+postcore_initcall(mxc_init_devices);
+
diff --git a/arch/arm/mach-mx51/devices.h b/arch/arm/mach-mx51/devices.h
new file mode 100644
index 0000000..52b07e8
--- /dev/null
+++ b/arch/arm/mach-mx51/devices.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+extern struct platform_device mxc_w1_master_device;
+extern struct platform_device mxc_keypad_device;
+extern struct platform_device mxc_rtc_device;
+extern struct platform_device mxc_nandv2_mtd_device;
+extern struct platform_device imx_nfc_device;
+extern struct platform_device mxc_wdt_device;
+extern struct platform_device mxc_pwm1_device;
+extern struct platform_device mxc_pwm2_device;
+extern struct platform_device mxc_pwm_backlight_device;
+extern struct platform_device mxc_ipu_device;
+extern struct platform_device mxc_fb_devices[];
+extern struct platform_device mxcvpu_device;
+extern struct platform_device mxcspi1_device;
+extern struct platform_device mxcspi2_device;
+extern struct platform_device mxcspi3_device;
+extern struct platform_device mxci2c_devices[];
+extern struct platform_device mxci2c_hs_device;
+extern struct platform_device mxc_tve_device;
+extern struct platform_device mxc_dvfs_core_device;
+extern struct platform_device mxc_dvfs_per_device;
+extern struct platform_device mxc_ssi1_device;
+extern struct platform_device mxc_ssi2_device;
+extern struct platform_device mxc_alsa_spdif_device;
+extern struct platform_device mx51_lpmode_device;
+extern struct platform_device busfreq_device;
+extern struct platform_device sdram_autogating_device;
+extern struct platform_device mxc_iim_device;
+extern struct platform_device mxc_sim_device;
+extern struct platform_device mxcsdhc1_device;
+extern struct platform_device mxcsdhc2_device;
+extern struct platform_device pata_fsl_device;
+extern struct platform_device gpu_device;
+extern struct platform_device mxc_fec_device;
+extern struct platform_device mxc_usbdr_udc_device;
+extern struct platform_device mxc_usbdr_otg_device;
+extern struct platform_device mxc_usbdr_host_device;
+extern struct platform_device mxc_usbh1_device;
+extern struct platform_device mxc_usbh2_device;
+
diff --git a/arch/arm/mach-mx51/mx51_3stack.c b/arch/arm/mach-mx51/mx51_3stack.c
index 69a22b3..cb0d81a 100644
--- a/arch/arm/mach-mx51/mx51_3stack.c
+++ b/arch/arm/mach-mx51/mx51_3stack.c
@@ -12,14 +12,10 @@
  */
 
 #include <linux/types.h>
-#include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <asm/mach/keypad.h>
 #include <linux/init.h>
-#include <linux/input.h>
-#include <linux/nodemask.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
@@ -29,6 +25,7 @@
 #include <linux/ata.h>
 #include <linux/pmic_external.h>
 #include <linux/ipu.h>
+#include <linux/pwm_backlight.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
@@ -39,16 +36,17 @@
 
 #include <linux/regulator/consumer.h>
 #include <mach/hardware.h>
-#include <asm/irq.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/time.h>
+#include <asm/mach/keypad.h>
 #include <mach/common.h>
-#include <mach/memory.h>
 #include <mach/gpio.h>
 #include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
 
+#include "devices.h"
 #include "board-mx51_3stack.h"
 #include "iomux.h"
 #include "crm_regs.h"
@@ -64,6 +62,7 @@ extern void __init mx51_3stack_io_init(void);
 extern struct cpu_wp *(*get_cpu_wp)(int *wp);
 extern void (*set_num_cpu_wp)(int num);
 static int num_cpu_wp = 3;
+static bool debug_board_present;
 
 /* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
 static struct cpu_wp cpu_wp_auto[] = {
@@ -108,12 +107,10 @@ void mx51_3stack_set_num_cpu_wp(int num)
 	return;
 }
 
-static void mxc_nop_release(struct device *dev)
-{
-	/* Nothing */
-}
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
 
-#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
 static u16 keymapping[24] = {
 	KEY_1, KEY_2, KEY_3, KEY_F1, KEY_UP, KEY_F2,
 	KEY_4, KEY_5, KEY_6, KEY_LEFT, KEY_SELECT, KEY_RIGHT,
@@ -121,14 +118,6 @@ static u16 keymapping[24] = {
 	KEY_0, KEY_OK, KEY_ESC, KEY_ENTER, KEY_MENU, KEY_BACK,
 };
 
-static struct resource mxc_kpp_resources[] = {
-	[0] = {
-	       .start = MXC_INT_KPP,
-	       .end = MXC_INT_KPP,
-	       .flags = IORESOURCE_IRQ,
-	       }
-};
-
 static struct keypad_data keypad_plat_data = {
 	.rowmax = 4,
 	.colmax = 6,
@@ -138,27 +127,100 @@ static struct keypad_data keypad_plat_data = {
 	.matrix = keymapping,
 };
 
-/* mxc keypad driver */
-static struct platform_device mxc_keypad_device = {
-	.name = "mxc_keypad",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
-	.resource = mxc_kpp_resources,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &keypad_plat_data,
-		},
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 2,
+};
+
+extern void mx51_babbage_gpio_spi_chipselect_active(int cspi_mode, int status,
+						    int chipselect);
+extern void mx51_babbage_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+						      int chipselect);
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx51_babbage_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx51_babbage_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_i2c_platform_data mxci2c_hs_data = {
+	.i2c_clk = 400000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+	.dig_reg = "VDIG",
+};
+
+static struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
+	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
+	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
+	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
+	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
+	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
+	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 30,
+	.num_wp = 3,
+};
+
+static struct mxc_dvfsper_data dvfs_per_data = {
+	.reg_id = "SW2",
+	.clk_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_DVFSPMCR0_FSVAI_MASK,
+	.vai_offset = MXC_DVFSPMCR0_FSVAI_OFFSET,
+	.dvfs_enable_bit = MXC_DVFSPMCR0_DVFEN,
+	.irq_mask = MXC_DVFSPMCR0_FSVAIM,
+	.div3_offset = 0,
+	.div3_mask = 0x7,
+	.div3_div = 2,
+	.lp_high = 1200000,
+	.lp_low = 1200000,
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 7,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
 };
 
-static void mxc_init_keypad(void)
-{
-	(void)platform_device_register(&mxc_keypad_device);
-}
-#else
-static inline void mxc_init_keypad(void)
-{
-}
-#endif
 
 /* NAND Flash Partitions */
 #ifdef CONFIG_MTD_PARTITIONS
@@ -188,14 +250,6 @@ static struct mtd_partition nand_flash_partitions[] = {
 
 #endif
 
-/* MTD NAND flash */
-#if defined(CONFIG_MTD_NAND_MXC) \
-	|| defined(CONFIG_MTD_NAND_MXC_MODULE) \
-	|| defined(CONFIG_MTD_NAND_MXC_V2) \
-	|| defined(CONFIG_MTD_NAND_MXC_V2_MODULE) \
-	|| defined(CONFIG_MTD_NAND_MXC_V3) \
-	|| defined(CONFIG_MTD_NAND_MXC_V3_MODULE)
-
 extern void gpio_nand_active(void);
 extern void gpio_nand_inactive(void);
 
@@ -222,58 +276,10 @@ static struct flash_platform_data mxc_nand_data = {
 	.exit = nand_exit,
 };
 
-static struct platform_device mxc_nandv2_mtd_device = {
-	.name = "mxc_nandv2_flash",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_nand_data,
-		},
-};
-
-static void mxc_init_nand_mtd(void)
-{
-	(void)platform_device_register(&mxc_nandv2_mtd_device);
-}
-#else
-static inline void mxc_init_nand_mtd(void)
-{
-}
-#endif
-
 /* i.MX MTD NAND Flash Controller */
 
 #if defined(CONFIG_MTD_NAND_IMX_NFC) || defined(CONFIG_MTD_NAND_IMX_NFC_MODULE)
 
-/* Resources for this device. */
-
-static struct resource imx_nfc_resources[] = {
-	{
-		.flags = IORESOURCE_MEM,
-		.start = NFC_BASE_ADDR_AXI + 0x0000,
-		.end   = NFC_BASE_ADDR_AXI + 0x1200 - 1,
-		.name  = IMX_NFC_BUFFERS_ADDR_RES_NAME,
-	},
-	{
-		.flags = IORESOURCE_MEM,
-		.start = NFC_BASE_ADDR_AXI + 0x1E00,
-		.end   = NFC_BASE_ADDR_AXI + 0x1E44 - 1,
-		.name  = IMX_NFC_PRIMARY_REGS_ADDR_RES_NAME,
-	},
-	{
-		.flags = IORESOURCE_MEM,
-		.start = NFC_BASE_ADDR + 0x00,
-		.end   = NFC_BASE_ADDR + 0x34 - 1,
-		.name  = IMX_NFC_SECONDARY_REGS_ADDR_RES_NAME,
-	},
-	{
-		.flags = IORESOURCE_IRQ,
-		.start = MXC_INT_NFC,
-		.end   = MXC_INT_NFC,
-		.name  = IMX_NFC_INTERRUPT_RES_NAME,
-	},
-};
-
 /*
  * Platform-specific information about this device. Some of the details depend
  * on the SoC. See imx_init_nfc() below for code that fills in the rest.
@@ -293,42 +299,8 @@ static struct imx_nfc_platform_data imx_nfc_platform_data = {
 	#endif
 };
 
-/* The structure that represents the NFC device. */
-
-static struct platform_device imx_nfc_device = {
-	.name = IMX_NFC_DRIVER_NAME,
-	.id = 0,
-	.dev = {
-		.release       = mxc_nop_release,
-		.platform_data = &imx_nfc_platform_data,
-	},
-	.resource      = imx_nfc_resources,
-	.num_resources = ARRAY_SIZE(imx_nfc_resources),
-};
-
-/**
- * imx_init_nfc() - Sets up the NFC for this platform.
- *
- * This function sets up data structures representing the NFC device on this
- * platform and registers the device with the platform management system.
- */
-
-static void imx_nfc_init(void)
-{
-	(void)platform_device_register(&imx_nfc_device);
-}
-
-#else
-
-static inline void imx_nfc_init(void)
-{
-}
-
 #endif /* i.MX MTD NAND Flash Controller */
 
-#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
-	defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
-
 static struct mxc_fb_platform_data fb_data[] = {
 	{
 	 .interface_pix_fmt = IPU_PIX_FMT_RGB666,
@@ -338,35 +310,6 @@ static struct mxc_fb_platform_data fb_data[] = {
 	 },
 };
 
-static struct platform_device mxc_fb_device[] = {
-	{
-	 .name = "mxc_sdc_fb",
-	 .id = 0,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .coherent_dma_mask = 0xFFFFFFFF,
-		 .platform_data = &fb_data[0],
-		 },
-	 },
-	{
-	 .name = "mxc_sdc_fb",
-	 .id = 1,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .coherent_dma_mask = 0xFFFFFFFF,
-		 .platform_data = &fb_data[1],
-		 },
-	 },
-	{
-	 .name = "mxc_sdc_fb",
-	 .id = 2,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .coherent_dma_mask = 0xFFFFFFFF,
-		 },
-	 },
-};
-
 static void lcd_reset_to2(void)
 {
 	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
@@ -394,10 +337,6 @@ static struct mxc_lcd_platform_data lcd_data = {
 
 static struct platform_device mxc_lcd_device = {
 	.name = "lcd_spi",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &lcd_data,
-		},
 };
 
 static void wvga_reset(void)
@@ -411,42 +350,13 @@ static struct mxc_lcd_platform_data lcd_wvga_data = {
 
 static struct platform_device lcd_wvga_device = {
 	.name = "lcd_claa",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &lcd_wvga_data,
-		},
 };
 
-extern int g_di1_tvout;
-static void mxc_init_fb(void)
-{
-	g_di1_tvout = 1;
-	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
-		lcd_data.reset = lcd_reset_to2;
-
-	(void)platform_device_register(&mxc_lcd_device);
-	(void)platform_device_register(&lcd_wvga_device);
-
-	(void)platform_device_register(&mxc_fb_device[0]);
-	(void)platform_device_register(&mxc_fb_device[1]);
-	(void)platform_device_register(&mxc_fb_device[2]);
-}
-#else
-static inline void mxc_init_fb(void)
-{
-}
-#endif
-
 static struct platform_device mxcbl_device = {
 	.name = "mxc_mc13892_bl",
 };
 
-static inline void mxc_init_bl(void)
-{
-	platform_device_register(&mxcbl_device);
-}
-
-void si4702_reset(void)
+static void si4702_reset(void)
 {
 	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 0);
 	msleep(100);
@@ -454,7 +364,7 @@ void si4702_reset(void)
 	msleep(100);
 }
 
-void si4702_clock_ctl(int flag)
+static void si4702_clock_ctl(int flag)
 {
 }
 
@@ -483,13 +393,6 @@ static struct mxc_fm_platform_data si4702_data = {
 	.seekth = 0xa,
 };
 
-#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
-
-#ifdef CONFIG_I2C_MXC_SELECT1
-static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
-};
-#endif
-#ifdef CONFIG_I2C_MXC_SELECT2
 static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	{
 	 .type = "wm8903-i2c",
@@ -510,8 +413,7 @@ static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	 .platform_data = (void *)&si4702_data,
 	 },
 };
-#endif
-#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
+
 static struct mxc_camera_platform_data camera_data = {
 	.io_regulator = "SW4",
 	.analog_regulator = "VIOHI",
@@ -530,21 +432,16 @@ static struct i2c_board_info mxc_i2c_hs_board_info[] __initdata = {
 		.platform_data = (void *)&camera_data,
 	},
 	{
-	 .type = "isl29003",
-	 .addr = 0x44,
-	 .platform_data = &ls_data,
+		.type = "isl29003",
+		.addr = 0x44,
+		.platform_data = &ls_data,
 	 },
 };
-#endif
 
-#endif
-
-static u32 cpld_base_addr;
-
-/*lan9217 device*/
-#if defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
 static struct resource smsc911x_resources[] = {
 	{
+	 .start = CS5_BASE_ADDR,
+	 .end = CS5_BASE_ADDR + SZ_4K - 1,
 	 .flags = IORESOURCE_MEM,
 	 },
 	{
@@ -562,31 +459,10 @@ struct smsc911x_platform_config smsc911x_config = {
 static struct platform_device smsc_lan9217_device = {
 	.name = "smsc911x",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &smsc911x_config,
-		},
 	.num_resources = ARRAY_SIZE(smsc911x_resources),
 	.resource = smsc911x_resources,
 };
-static void mxc_init_enet(void)
-{
-	if (cpld_base_addr) {
-		smsc_lan9217_device.resource[0].start =
-		    LAN9217_BASE_ADDR(cpld_base_addr);
-		smsc_lan9217_device.resource[0].end =
-		    LAN9217_BASE_ADDR(cpld_base_addr) + 0x100;
-		(void)platform_device_register(&smsc_lan9217_device);
-	}
-}
-#else
-static inline void mxc_init_enet(void)
-{
-}
-#endif
 
-#if defined(CONFIG_IMX_SIM) || defined(CONFIG_IMX_SIM_MODULE)
-/* Used to configure the SIM bus */
 static struct mxc_sim_platform_data sim_data = {
 	.clk_rate = 4000000,
 	.clock_sim = "sim_clk",
@@ -597,53 +473,9 @@ static struct mxc_sim_platform_data sim_data = {
 };
 
 /*!
- * Resource definition for the SIM
- */
-static struct resource mxc_sim_resources[] = {
-	[0] = {
-	       .start = SIM_BASE_ADDR,
-	       .end = SIM_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_SIM_IPB,
-	       .end = MXC_INT_SIM_IPB,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = MXC_INT_SIM_DAT,
-	       .end = MXC_INT_SIM_DAT,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Device Definition for IMX SIM */
-static struct platform_device mxc_sim_device = {
-	.name = "mxc_sim",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &sim_data,
-		},
-	.num_resources = ARRAY_SIZE(mxc_sim_resources),
-	.resource = mxc_sim_resources,
-};
-
-static inline void mxc_init_sim(void)
-{
-	(void)platform_device_register(&mxc_sim_device);
-}
-#else
-static inline void mxc_init_sim(void)
-{
-}
-#endif
-
-#if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
-/*!
  * Get WP pin value to detect write protection
  */
-int sdhc_write_protect(struct device *dev)
+static int sdhc_write_protect(struct device *dev)
 {
 	unsigned short rc = 0;
 
@@ -654,10 +486,7 @@ int sdhc_write_protect(struct device *dev)
 	return rc;
 }
 
-/*
- * Probe for the card. If present the GPIO data would be set.
- */
-unsigned int sdhc_get_card_det_status(struct device *dev)
+static unsigned int sdhc_get_card_det_status(struct device *dev)
 {
 	int ret;
 
@@ -692,83 +521,6 @@ static struct mxc_mmc_platform_data mmc2_data = {
 	.clock_mmc = "esdhc_clk",
 };
 
-/*!
- * Resource definition for the SDHC1
- */
-static struct resource mxcsdhc1_resources[] = {
-	[0] = {
-	       .start = MMC_SDHC1_BASE_ADDR,
-	       .end = MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_MMC_SDHC1,
-	       .end = MXC_INT_MMC_SDHC1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
-	       .end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*!
- * Resource definition for the SDHC2
- */
-static struct resource mxcsdhc2_resources[] = {
-	[0] = {
-	       .start = MMC_SDHC2_BASE_ADDR,
-	       .end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_MMC_SDHC2,
-	       .end = MXC_INT_MMC_SDHC2,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = 0,
-	       .end = 0,
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Device Definition for MXC SDHC1 */
-static struct platform_device mxcsdhc1_device = {
-	.name = "mxsdhci",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mmc1_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
-	.resource = mxcsdhc1_resources,
-};
-
-/*! Device Definition for MXC SDHC2 */
-static struct platform_device mxcsdhc2_device = {
-	.name = "mxsdhci",
-	.id = 1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mmc2_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
-	.resource = mxcsdhc2_resources,
-};
-
-static inline void mxc_init_mmc(void)
-{
-	(void)platform_device_register(&mxcsdhc1_device);
-	(void)platform_device_register(&mxcsdhc2_device);
-}
-#else
-static inline void mxc_init_mmc(void)
-{
-}
-#endif
-
 static u32 brd_io;
 static void expio_ack_irq(u32 irq);
 
@@ -865,10 +617,9 @@ static int __init mxc_expio_init(void)
 	    (__raw_readw(brd_io + MAGIC_NUMBER2_REG) != 0x5555) ||
 	    (__raw_readw(brd_io + MAGIC_NUMBER3_REG) != 0xCAFE)) {
 		pr_info("3-Stack Debug board not detected \n");
-		cpld_base_addr = 0;
 		return -ENODEV;
 	} else {
-		cpld_base_addr = CS5_BASE_ADDR;
+		debug_board_present = true;
 	}
 
 	pr_info("3-Stack Debug board detected, rev = 0x%04X\n",
@@ -897,7 +648,6 @@ static int __init mxc_expio_init(void)
 	return 0;
 }
 
-#if defined(CONFIG_PATA_FSL) || defined(CONFIG_PATA_FSL_MODULE)
 extern void gpio_ata_active(void);
 extern void gpio_ata_inactive(void);
 
@@ -926,54 +676,6 @@ static struct fsl_ata_platform_data ata_data = {
 	.io_reg = NULL,
 };
 
-static struct resource pata_fsl_resources[] = {
-	[0] = {
-	       .start = ATA_BASE_ADDR,
-	       .end = ATA_BASE_ADDR + 0x000000C8,
-	       .flags = IORESOURCE_MEM,},
-	[2] = {
-	       .start = MXC_INT_ATA,
-	       .end = MXC_INT_ATA,
-	       .flags = IORESOURCE_IRQ,},
-};
-
-static struct platform_device pata_fsl_device = {
-	.name = "pata_fsl",
-	.id = -1,
-	.num_resources = ARRAY_SIZE(pata_fsl_resources),
-	.resource = pata_fsl_resources,
-	.dev = {
-		.platform_data = &ata_data,
-		.coherent_dma_mask = ~0,},
-};
-
-static void __init mxc_init_pata(void)
-{
-	(void)platform_device_register(&pata_fsl_device);
-}
-#else				/* CONFIG_PATA_FSL */
-static void __init mxc_init_pata(void)
-{
-}
-#endif				/* CONFIG_PATA_FSL */
-
-#if defined(CONFIG_TOUCHSCREEN_TSC2007) \
-	|| defined(CONFIG_TOUCHSCREEN_TSC2007_MODULE)
-
-static int __init mxc_init_touchscreen(void)
-{
-	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5), "gpio1_5");
-	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5));
-
-	return 0;
-}
-#else
-static int __init mxc_init_touchscreen(void)
-{
-	return 0;
-}
-#endif
-
 static int __init mxc_init_srpgconfig(void)
 {
 	struct clk *gpcclk = clk_get(NULL, "gpc_dvfs_clk");
@@ -998,19 +700,13 @@ static int __init mxc_init_srpgconfig(void)
 	return 0;
 }
 
-#if defined(CONFIG_SND_SOC_IMX_3STACK_WM8903) \
-    || defined(CONFIG_SND_SOC_IMX_3STACK_WM8903_MODULE)
-static struct mxc_audio_platform_data wm8903_data;
-
 static struct platform_device mxc_wm8903_device = {
 	.name = "imx-3stack-wm8903",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &wm8903_data,
-		},
 };
 
+static struct mxc_audio_platform_data wm8903_data;
+
 static void __init mxc_init_wm8903(void)
 {
 	wm8903_data.ssi_clk[0] = clk_get(NULL, "ssi_clk.0");
@@ -1025,42 +721,17 @@ static void __init mxc_init_wm8903(void)
 
 	(void)platform_device_register(&mxc_wm8903_device);
 }
-#else
-static void __init mxc_init_wm8903(void)
-{
-}
-#endif
 
-#if defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) \
-    || defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000_MODULE)
-static int mxc_sgtl5000_plat_init(void);
-static int mxc_sgtl5000_plat_finit(void);
-static int mxc_sgtl5000_amp_enable(int enable);
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
 
 int headphone_det_status(void)
 {
 	return gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A26));
 }
 
-static struct mxc_audio_platform_data sgtl5000_data = {
-	.ssi_num = 1,
-	.src_port = 2,
-	.ext_port = 3,
-	.hp_irq = IOMUX_TO_IRQ(MX51_PIN_EIM_A26),
-	.hp_status = headphone_det_status,
-	.amp_enable = mxc_sgtl5000_amp_enable,
-	.sysclk = 12000000,
-	.init = mxc_sgtl5000_plat_init,
-	.finit = mxc_sgtl5000_plat_finit,
-};
-
-static struct platform_device mxc_sgtl5000_device = {
-	.name = "imx-3stack-sgtl5000",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &sgtl5000_data,
-		},
-};
+static struct mxc_audio_platform_data sgtl5000_data;
 
 static int mxc_sgtl5000_plat_init(void)
 {
@@ -1097,15 +768,17 @@ static int mxc_sgtl5000_amp_enable(int enable)
 	return 0;
 }
 
-static void mxc_init_sgtl5000(void)
-{
-	platform_device_register(&mxc_sgtl5000_device);
-}
-#else
-static inline void mxc_init_sgtl5000(void)
-{
-}
-#endif
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_irq = IOMUX_TO_IRQ(MX51_PIN_EIM_A26),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.sysclk = 12000000,
+	.init = mxc_sgtl5000_plat_init,
+	.finit = mxc_sgtl5000_plat_finit,
+};
 
 static void bt_reset(void)
 {
@@ -1123,17 +796,8 @@ static struct mxc_bt_platform_data mxc_bt_data = {
 static struct platform_device mxc_bt_device = {
 	.name = "mxc_bt",
 	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mxc_bt_data,
-		},
 };
 
-static void mxc_init_bluetooth(void)
-{
-	(void)platform_device_register(&mxc_bt_device);
-}
-
 static void mxc_unifi_hardreset(int pin_level)
 {
 	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), pin_level & 0x01);
@@ -1150,7 +814,6 @@ struct mxc_unifi_platform_data *get_unifi_plat_data(void)
 {
 	return &unifi_data;
 }
-
 EXPORT_SYMBOL(get_unifi_plat_data);
 
 /*!
@@ -1171,18 +834,8 @@ static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
 
 	get_cpu_wp = mx51_3stack_get_cpu_wp;
 	set_num_cpu_wp = mx51_3stack_set_num_cpu_wp;
-#ifdef CONFIG_DISCONTIGMEM
-	do {
-		int nid;
-		mi->nr_banks = MXC_NUMNODES;
-		for (nid = 0; nid < mi->nr_banks; nid++)
-			SET_NODE(mi, nid);
-
-	} while (0);
-#endif
 }
 
-#if defined(CONFIG_GPS_IOCTRL) || defined(CONFIG_GPS_IOCTRL_MODULE)
 static struct mxc_gps_platform_data gps_data = {
 	.core_reg = "VIOHI",
 	.analog_reg = "SW4",
@@ -1191,16 +844,8 @@ static struct mxc_gps_platform_data gps_data = {
 static struct platform_device mxc_gps_device = {
 	.name = "gps_ioctrl",
 	.id = -1,
-	.dev = {
-		.platform_data = &gps_data,
-	},
 };
 
-static void __init mxc_init_gps(void)
-{
-	(void)platform_device_register(&mxc_gps_device);
-}
-
 int gpio_gps_access(int para)
 {
 	iomux_pin_name_t pin;
@@ -1215,11 +860,6 @@ int gpio_gps_access(int para)
 	return 0;
 }
 EXPORT_SYMBOL(gpio_gps_access);
-#else
-static void __init mxc_init_gps(void)
-{
-}
-#endif
 
 /*!
  * Board specific initialization.
@@ -1228,46 +868,80 @@ static void __init mxc_board_init(void)
 {
 	int err;
 
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+
 	mxc_cpu_common_init();
 	mxc_register_gpios();
 	mx51_3stack_io_init();
 	early_console_setup(saved_command_line);
-	mxc_init_devices();
+
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_hs_device, &mxci2c_hs_data);
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&mxc_ipu_device, &mxc_ipu_data);
+	mxc_register_device(&mxc_tve_device, &tve_data);
+	mxc_register_device(&mxcvpu_device, NULL);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mx51_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&sdram_autogating_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	mxc_register_device(&mxc_iim_device, NULL);
+	mxc_register_device(&mxc_pwm1_device, NULL);
+	mxc_register_device(&mxc_pwm_backlight_device, &mxc_pwm_backlight_data);
+	mxc_register_device(&mxc_keypad_device, &keypad_plat_data);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc2_device, &mmc2_data);
+	mxc_register_device(&mxc_sim_device, &sim_data);
+	mxc_register_device(&pata_fsl_device, &ata_data);
+	mxc_register_device(&mxc_alsa_spdif_device, &mxc_spdif_data);
 
 	mxc_expio_init();
-	mxc_init_enet();
-	mxc_init_pata();
-	mxc_init_fb();
-	mxc_init_bl();
-	mxc_init_keypad();
-	mxc_init_nand_mtd();
-	imx_nfc_init();
-	mxc_init_mmc();
-	mxc_init_sim();
-	mxc_init_srpgconfig();
-	mx51_3stack_init_mc13892();
+	if (debug_board_present)
+		mxc_register_device(&smsc_lan9217_device, &smsc911x_config);
 
-#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		lcd_data.reset = lcd_reset_to2;
 
-#ifdef CONFIG_I2C_MXC_SELECT1
-	i2c_register_board_info(0, mxc_i2c0_board_info,
-				ARRAY_SIZE(mxc_i2c0_board_info));
+	mxc_register_device(&mxc_lcd_device, &lcd_data);
+	mxc_register_device(&lcd_wvga_device, &lcd_wvga_data);
+	mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+	mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+	mxc_register_device(&mxc_fb_devices[2], NULL);
+	mxc_register_device(&mxcbl_device, NULL);
+
+#if defined(CONFIG_MTD_NAND_IMX_NFC) || defined(CONFIG_MTD_NAND_IMX_NFC_MODULE)
+	mxc_register_device(&imx_nfc_device, &imx_nfc_platform_data);
+#else
+	mxc_register_device(&mxc_nandv2_mtd_device, &mxc_nand_data);
 #endif
-#ifdef CONFIG_I2C_MXC_SELECT2
+	mxc_init_srpgconfig();
+	mx51_3stack_init_mc13892();
+
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 				ARRAY_SIZE(mxc_i2c1_board_info));
-#endif
-#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
 	i2c_register_board_info(3, mxc_i2c_hs_board_info,
 				ARRAY_SIZE(mxc_i2c_hs_board_info));
-#endif
 
-#endif
-	mxc_init_touchscreen();
 	mxc_init_wm8903();
-	mxc_init_sgtl5000();
-	mxc_init_bluetooth();
-	mxc_init_gps();
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+	mxc_register_device(&mxc_bt_device, &mxc_bt_data);
+	mxc_register_device(&mxc_gps_device, &gps_data);
+
+	/* Setup Touchscreen interrupt */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5), "gpio1_5");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5));
 
 	err = mxc_request_iomux(MX51_PIN_EIM_D19, IOMUX_CONFIG_GPIO);
 	if (err)
diff --git a/arch/arm/mach-mx51/mx51_babbage.c b/arch/arm/mach-mx51/mx51_babbage.c
index 68f1926..3887d79 100644
--- a/arch/arm/mach-mx51/mx51_babbage.c
+++ b/arch/arm/mach-mx51/mx51_babbage.c
@@ -12,20 +12,16 @@
  */
 
 #include <linux/types.h>
-#include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/init.h>
-#include <linux/input.h>
-#include <linux/nodemask.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/spi/spi.h>
 #include <linux/i2c.h>
-#include <linux/ata.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
@@ -35,17 +31,19 @@
 #include <linux/pmic_status.h>
 #include <linux/ipu.h>
 #include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
 #include <mach/common.h>
 #include <mach/hardware.h>
-#include <asm/irq.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/time.h>
 #include <asm/mach/keypad.h>
-#include <mach/memory.h>
 #include <mach/gpio.h>
 #include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+
+#include "devices.h"
 #include "board-mx51_babbage.h"
 #include "iomux.h"
 #include "crm_regs.h"
@@ -127,12 +125,11 @@ void mx51_babbage_set_num_cpu_wp(int num)
 	num_cpu_wp = num;
 	return;
 }
-static void mxc_nop_release(struct device *dev)
-{
-	/* Nothing */
-}
 
-#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
 static u16 keymapping[24] = {
 	KEY_1, KEY_2, KEY_3, KEY_F1, KEY_UP, KEY_F2,
 	KEY_4, KEY_5, KEY_6, KEY_LEFT, KEY_SELECT, KEY_RIGHT,
@@ -140,14 +137,6 @@ static u16 keymapping[24] = {
 	KEY_0, KEY_OK, KEY_ESC, KEY_ENTER, KEY_MENU, KEY_BACK,
 };
 
-static struct resource mxc_kpp_resources[] = {
-	[0] = {
-	       .start = MXC_INT_KPP,
-	       .end = MXC_INT_KPP,
-	       .flags = IORESOURCE_IRQ,
-	       }
-};
-
 static struct keypad_data keypad_plat_data = {
 	.rowmax = 4,
 	.colmax = 6,
@@ -157,30 +146,100 @@ static struct keypad_data keypad_plat_data = {
 	.matrix = keymapping,
 };
 
-/* mxc keypad driver */
-static struct platform_device mxc_keypad_device = {
-	.name = "mxc_keypad",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
-	.resource = mxc_kpp_resources,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &keypad_plat_data,
-		},
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 2,
+};
+
+extern void mx51_babbage_gpio_spi_chipselect_active(int cspi_mode, int status,
+						    int chipselect);
+extern void mx51_babbage_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+						      int chipselect);
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx51_babbage_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx51_babbage_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_i2c_platform_data mxci2c_hs_data = {
+	.i2c_clk = 400000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+	.dig_reg = "VDIG",
+};
+
+static struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
+	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
+	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
+	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
+	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
+	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
+	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 30,
+	.num_wp = 3,
+};
+
+static struct mxc_dvfsper_data dvfs_per_data = {
+	.reg_id = "SW2",
+	.clk_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_DVFSPMCR0_FSVAI_MASK,
+	.vai_offset = MXC_DVFSPMCR0_FSVAI_OFFSET,
+	.dvfs_enable_bit = MXC_DVFSPMCR0_DVFEN,
+	.irq_mask = MXC_DVFSPMCR0_FSVAIM,
+	.div3_offset = 0,
+	.div3_mask = 0x7,
+	.div3_div = 2,
+	.lp_high = 1200000,
+	.lp_low = 1200000,
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 7,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
 };
 
-static void mxc_init_keypad(void)
-{
-	(void)platform_device_register(&mxc_keypad_device);
-}
-#else
-static inline void mxc_init_keypad(void)
-{
-}
-#endif
-
-#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
-	defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
 static struct resource mxcfb_resources[] = {
 	[0] = {
 	       .flags = IORESOURCE_MEM,
@@ -198,37 +257,6 @@ static struct mxc_fb_platform_data fb_data[] = {
 	 },
 };
 
-static struct platform_device mxc_fb_device[] = {
-	{
-	 .name = "mxc_sdc_fb",
-	 .id = 0,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .coherent_dma_mask = 0xFFFFFFFF,
-		 .platform_data = &fb_data[0],
-		 },
-	 .num_resources = ARRAY_SIZE(mxcfb_resources),
-	 .resource = mxcfb_resources,
-	 },
-	{
-	 .name = "mxc_sdc_fb",
-	 .id = 1,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .coherent_dma_mask = 0xFFFFFFFF,
-		 .platform_data = &fb_data[1],
-		 },
-	 },
-	{
-	 .name = "mxc_sdc_fb",
-	 .id = 2,
-	 .dev = {
-		 .release = mxc_nop_release,
-		 .coherent_dma_mask = 0xFFFFFFFF,
-		 },
-	 },
-};
-
 static int __initdata enable_vga = { 0 };
 static int __initdata enable_wvga = { 0 };
 static int __initdata enable_tv = { 0 };
@@ -245,10 +273,6 @@ static struct mxc_lcd_platform_data lcd_wvga_data = {
 
 static struct platform_device lcd_wvga_device = {
 	.name = "lcd_claa",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &lcd_wvga_data,
-		},
 };
 
 static int handle_edid(int *pixclk)
@@ -338,7 +362,6 @@ static int handle_edid(int *pixclk)
 	return 0;
 }
 
-extern int g_di1_tvout;
 static int __init mxc_init_fb(void)
 {
 	int pixclk = 0;
@@ -351,7 +374,6 @@ static int __init mxc_init_fb(void)
 		fb_data[0].mode_str = NULL;
 		fb_data[1].mode_str = NULL;
 	}
-	g_di1_tvout = 1;
 
 	/* DI1: Dumb LCD */
 	if (enable_wvga) {
@@ -384,17 +406,15 @@ static int __init mxc_init_fb(void)
 	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), 1);
 	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), 0);
 
-	(void)platform_device_register(&lcd_wvga_device);
+	mxc_register_device(&lcd_wvga_device, &lcd_wvga_data);
 
 	if (cpu_is_mx51_rev(CHIP_REV_1_1) == 2)
 		handle_edid(&pixclk);
 
 	if (enable_vga) {
 		printk(KERN_INFO "VGA monitor is primary\n");
-		g_di1_tvout = 0;
 	} else if (enable_wvga) {
 		printk(KERN_INFO "WVGA LCD panel is primary\n");
-		g_di1_tvout = 0;
 	} else if (enable_tv == 2)
 		printk(KERN_INFO "HDTV is primary\n");
 	else
@@ -404,6 +424,7 @@ static int __init mxc_init_fb(void)
 		printk(KERN_INFO "HDTV is specified as %d\n", enable_tv);
 		fb_data[1].interface_pix_fmt = IPU_PIX_FMT_YUV444;
 		fb_data[1].mode = &(video_modes[0]);
+		mxc_register_device(&mxc_tve_device, &tve_data);
 	}
 
 	/* Once a customer knows the platform configuration,
@@ -419,11 +440,9 @@ static int __init mxc_init_fb(void)
 		 * 2. WVGA      RGB 	   800x480M-16@55
 		 * 3. TVE       YUV	   video_modes[0]
 		 */
-		(void)platform_device_register(&mxc_fb_device[1]);
-		mxc_fb_device[0].num_resources = 0;
-		mxc_fb_device[0].resource = NULL;
-		mxc_fb_device[1].num_resources = ARRAY_SIZE(mxcfb_resources);
-		mxc_fb_device[1].resource = mxcfb_resources;
+		mxc_fb_devices[1].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[1].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
 		if (fb_data[0].mode_str || fb_data[0].mode)
 			/*
 			 * DI0 -> DC channel:
@@ -433,7 +452,7 @@ static int __init mxc_init_fb(void)
 			 * 1. LVDS      RGB 	   video_modes[1]
 			 * 2. DVI       RGB 	   1024x768M-16@60
 			 */
-			(void)platform_device_register(&mxc_fb_device[0]);
+			mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
 	} else {
 		/*
 		 * DI0 -> DP-BG channel:
@@ -443,7 +462,9 @@ static int __init mxc_init_fb(void)
 		 * 1. LVDS      RGB 	   video_modes[1]
 		 * 2. DVI       RGB 	   1024x768M-16@60
 		 */
-		(void)platform_device_register(&mxc_fb_device[0]);
+		mxc_fb_devices[0].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[0].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
 		if (fb_data[1].mode_str || fb_data[1].mode)
 			/*
 			 * DI1 -> DC channel:
@@ -454,13 +475,13 @@ static int __init mxc_init_fb(void)
 			 * 2. WVGA      RGB 	   800x480M-16@55
 			 * 3. TVE       YUV	   video_modes[0]
 			 */
-			(void)platform_device_register(&mxc_fb_device[1]);
+			mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
 	}
 
 	/*
 	 * DI0/1 DP-FG channel:
 	 */
-	(void)platform_device_register(&mxc_fb_device[2]);
+	mxc_register_device(&mxc_fb_devices[2], NULL);
 
 	return 0;
 }
@@ -471,7 +492,6 @@ static int __init vga_setup(char *__unused)
 	enable_vga = 1;
 	return 1;
 }
-
 __setup("vga", vga_setup);
 
 static int __init wvga_setup(char *__unused)
@@ -479,7 +499,6 @@ static int __init wvga_setup(char *__unused)
 	enable_wvga = 1;
 	return 1;
 }
-
 __setup("wvga", wvga_setup);
 
 static int __init mitsubishi_xga_setup(char *__unused)
@@ -487,7 +506,6 @@ static int __init mitsubishi_xga_setup(char *__unused)
 	enable_mitsubishi_xga = 1;
 	return 1;
 }
-
 __setup("mitsubishi_xga", mitsubishi_xga_setup);
 
 static int __init tv_setup(char *s)
@@ -497,13 +515,7 @@ static int __init tv_setup(char *s)
 		enable_tv = 2;
 	return 1;
 }
-
 __setup("hdtv", tv_setup);
-#else
-static inline void mxc_init_fb(void)
-{
-}
-#endif
 
 static void dvi_reset(void)
 {
@@ -577,9 +589,6 @@ static struct mxc_fm_platform_data si4702_data = {
 	.clock_ctl = si4702_clock_ctl,
 };
 
-#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
-
-#ifdef CONFIG_I2C_MXC_SELECT1
 static struct mxc_camera_platform_data camera_data = {
 	.io_regulator = "SW4",
 	.analog_regulator = "VIOHI",
@@ -594,8 +603,7 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 	.platform_data = (void *)&camera_data,
 	},
 };
-#endif
-#ifdef CONFIG_I2C_MXC_SELECT2
+
 static struct mxc_lightsensor_platform_data ls_data = {
 	.vdd_reg = "VIOHI",
 	.rext = 100,
@@ -612,9 +620,7 @@ static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	 .platform_data = &ls_data,
 	 },
 };
-#endif
 
-#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
 static struct i2c_board_info mxc_i2c_hs_board_info[] __initdata = {
 	{
 	 .type = "sii9022",
@@ -632,11 +638,7 @@ static struct i2c_board_info mxc_i2c_hs_board_info[] __initdata = {
 	 .platform_data = (void *)&si4702_data,
 	 },
 };
-#endif
 
-#endif
-
-#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 static struct mtd_partition mxc_spi_nor_partitions[] = {
 	{
 	 .name = "bootloader",
@@ -672,32 +674,26 @@ static struct flash_platform_data mxc_spi_flash_data[] = {
 	 .nr_parts = ARRAY_SIZE(mxc_dataflash_partitions),
 	 .type = "at45db321d",}
 };
-#endif
 
 static struct spi_board_info mxc_spi_nor_device[] __initdata = {
-#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 	{
 	 .modalias = "mxc_spi_nor",
 	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
 	 .bus_num = 1,
 	 .chip_select = 1,
-	 .platform_data = &mxc_spi_flash_data[0],},
-#endif
+	 .platform_data = &mxc_spi_flash_data[0],
+	},
 };
 
 static struct spi_board_info mxc_dataflash_device[] __initdata = {
-#if defined(CONFIG_MTD_MXC_DATAFLASH) \
-	|| defined(CONFIG_MTD_MXC_DATAFLASH_MODULE)
 	{
 	 .modalias = "mxc_dataflash",
 	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
 	 .bus_num = 1,
 	 .chip_select = 1,
 	 .platform_data = &mxc_spi_flash_data[1],},
-#endif
 };
 
-#if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
 static int sdhc_write_protect(struct device *dev)
 {
 	unsigned short rc = 0;
@@ -752,94 +748,11 @@ static struct mxc_mmc_platform_data mmc2_data = {
 	.clock_mmc = "esdhc_clk",
 };
 
-/*!
- * Resource definition for the SDHC1
- */
-static struct resource mxcsdhc1_resources[] = {
-	[0] = {
-	       .start = MMC_SDHC1_BASE_ADDR,
-	       .end = MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_MMC_SDHC1,
-	       .end = MXC_INT_MMC_SDHC1,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
-	       .end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*!
- * Resource definition for the SDHC2
- */
-static struct resource mxcsdhc2_resources[] = {
-	[0] = {
-	       .start = MMC_SDHC2_BASE_ADDR,
-	       .end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
-	       .flags = IORESOURCE_MEM,
-	       },
-	[1] = {
-	       .start = MXC_INT_MMC_SDHC2,
-	       .end = MXC_INT_MMC_SDHC2,
-	       .flags = IORESOURCE_IRQ,
-	       },
-	[2] = {
-	       .start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_6),
-	       .end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_6),
-	       .flags = IORESOURCE_IRQ,
-	       },
-};
-
-/*! Device Definition for MXC SDHC1 */
-static struct platform_device mxcsdhc1_device = {
-	.name = "mxsdhci",
-	.id = 0,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mmc1_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
-	.resource = mxcsdhc1_resources,
-};
-
-/*! Device Definition for MXC SDHC2 */
-static struct platform_device mxcsdhc2_device = {
-	.name = "mxsdhci",
-	.id = 1,
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &mmc2_data,
-		},
-	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
-	.resource = mxcsdhc2_resources,
-};
-
-static inline void mxc_init_mmc(void)
-{
-	if (board_is_rev(BOARD_REV_2)) {
-		/* BB2.5 */
-		mxcsdhc2_resources[2].start =
-			IOMUX_TO_IRQ(MX51_PIN_GPIO1_6);	/* SD2 CD */
-		mxcsdhc2_resources[2].end =
-			IOMUX_TO_IRQ(MX51_PIN_GPIO1_6);	/* SD2 CD */
-	}
-
-	(void)platform_device_register(&mxcsdhc1_device);
-	(void)platform_device_register(&mxcsdhc2_device);
-}
-#else
-static inline void mxc_init_mmc(void)
+static int mxc_sgtl5000_amp_enable(int enable)
 {
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A23), enable ? 1 : 0);
+	return 0;
 }
-#endif
-
-#if defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) \
-    || defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000_MODULE)
-static int mxc_sgtl5000_amp_enable(int enable);
 
 static int headphone_det_status(void)
 {
@@ -861,98 +774,8 @@ static struct mxc_audio_platform_data sgtl5000_data = {
 
 static struct platform_device mxc_sgtl5000_device = {
 	.name = "imx-3stack-sgtl5000",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &sgtl5000_data,
-		},
-};
-
-static int mxc_sgtl5000_amp_enable(int enable)
-{
-	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A23), enable ? 1 : 0);
-	return 0;
-}
-
-static void mxc_init_sgtl5000(void)
-{
-	if (cpu_is_mx51_rev(CHIP_REV_1_1) == 2) {
-		sgtl5000_data.sysclk = 26000000;
-	}
-
-	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_A23), "eim_a23");
-	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_A23), 0);
-
-	platform_device_register(&mxc_sgtl5000_device);
-}
-#else
-static inline void mxc_init_sgtl5000(void)
-{
-}
-#endif
-
-#if defined CONFIG_FEC
-static struct resource mxc_fec_resources[] = {
-	{
-		.start	= FEC_BASE_ADDR,
-		.end	= FEC_BASE_ADDR + 0xfff,
-		.flags	= IORESOURCE_MEM
-	}, {
-		.start	= MXC_INT_FEC,
-		.end	= MXC_INT_FEC,
-		.flags	= IORESOURCE_IRQ
-	},
-};
-
-struct platform_device mxc_fec_device = {
-	.name = "fec",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_fec_resources),
-	.resource = mxc_fec_resources,
-};
-
-static __init int mxc_init_fec(void)
-{
-	return platform_device_register(&mxc_fec_device);
-}
-#else
-static inline int mxc_init_fec(void)
-{
-	return 0;
-}
-#endif
-
-#if defined(CONFIG_GPIO_BUTTON_MXC) || \
-	defined(CONFIG_GPIO_BUTTON_MXC_MODULE)
-
-#define MXC_BUTTON_GPIO_PIN MX51_PIN_EIM_DTACK
-
-static struct mxc_gpio_button_data gpio_button_data = {
-	.name = "Power Button (CM)",
-	.gpio = MXC_BUTTON_GPIO_PIN,
-	.irq = IOMUX_TO_IRQ(MXC_BUTTON_GPIO_PIN),
-	.key = KEY_POWER,
-};
-
-static struct platform_device gpio_button_device = {
-	.name = "gpio_button",
-	.dev = {
-		.release = mxc_nop_release,
-		.platform_data = &gpio_button_data,
-		},
 };
 
-static inline void mxc_init_gpio_button(void)
-{
-	gpio_request(IOMUX_TO_GPIO(MXC_BUTTON_GPIO_PIN), "button");
-	gpio_direction_input(IOMUX_TO_GPIO(MXC_BUTTON_GPIO_PIN));
-	platform_device_register(&gpio_button_device);
-}
-#else
-static inline void mxc_init_gpio_button(void)
-{
-}
-#endif
-
 /*!
  * Board specific fixup function. It is called by \b setup_arch() in
  * setup.c file very early on during kernel starts. It allows the user to
@@ -1042,7 +865,6 @@ static int __init mxc_init_power_key(void)
 		enable_irq_wake(irq);
 	return ret;
 }
-
 late_initcall(mxc_init_power_key);
 
 /*!
@@ -1050,16 +872,49 @@ late_initcall(mxc_init_power_key);
  */
 static void __init mxc_board_init(void)
 {
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+
+	/* SD card detect irqs */
+	mxcsdhc2_device.resource[2].start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_6);
+	mxcsdhc2_device.resource[2].end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_6);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0);
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0);
+
 	mxc_cpu_common_init();
 	mxc_register_gpios();
 	mx51_babbage_io_init();
 	early_console_setup(saved_command_line);
 
-	mxc_init_devices();
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_hs_device, &mxci2c_hs_data);
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&mxc_ipu_device, &mxc_ipu_data);
+	mxc_register_device(&mxc_tve_device, &tve_data);
+	mxc_register_device(&mxcvpu_device, NULL);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mx51_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&sdram_autogating_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	mxc_register_device(&mxc_iim_device, NULL);
+	mxc_register_device(&mxc_pwm1_device, NULL);
+	mxc_register_device(&mxc_pwm_backlight_device, &mxc_pwm_backlight_data);
+	mxc_register_device(&mxc_keypad_device, &keypad_plat_data);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc2_device, &mmc2_data);
+	mxc_register_device(&mxc_ssi1_device, NULL);
+	mxc_register_device(&mxc_ssi2_device, NULL);
+	mxc_register_device(&mxc_alsa_spdif_device, &mxc_spdif_data);
+	mxc_register_device(&mxc_fec_device, NULL);
 
-	mxc_init_keypad();
-	mxc_init_mmc();
-	mxc_init_gpio_button();
 	mx51_babbage_init_mc13892();
 
 	if (board_is_rev(BOARD_REV_2))
@@ -1071,17 +926,11 @@ static void __init mxc_board_init(void)
 		spi_register_board_info(mxc_spi_nor_device,
 					ARRAY_SIZE(mxc_spi_nor_device));
 
-#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
-
-#ifdef CONFIG_I2C_MXC_SELECT1
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 				ARRAY_SIZE(mxc_i2c0_board_info));
-#endif
-#ifdef CONFIG_I2C_MXC_SELECT2
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 				ARRAY_SIZE(mxc_i2c1_board_info));
-#endif
-#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
+
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) >= 1) {
 		vga_data.core_reg = NULL;
 		vga_data.io_reg = NULL;
@@ -1089,12 +938,15 @@ static void __init mxc_board_init(void)
 	}
 	i2c_register_board_info(3, mxc_i2c_hs_board_info,
 				ARRAY_SIZE(mxc_i2c_hs_board_info));
-#endif
 
-#endif
 	pm_power_off = mxc_power_off;
-	mxc_init_fec();
-	mxc_init_sgtl5000();
+
+	if (cpu_is_mx51_rev(CHIP_REV_1_1) == 2) {
+		sgtl5000_data.sysclk = 26000000;
+	}
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_A23), "eim_a23");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_A23), 0);
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
 }
 
 static void __init mx51_babbage_timer_init(void)
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 49eaf04..0a76967 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := cpu.o cpu_common.o gpio.o clock.o wdog.o snoop.o io.o time.o
+obj-y := cpu.o cpu_common.o gpio.o clock.o wdog.o snoop.o io.o time.o devices.o
 
 obj-$(CONFIG_IRAM_ALLOC) += iram.o
 
diff --git a/drivers/video/mxc/tve.c b/drivers/video/mxc/tve.c
index 37bba3a..eccf5cc 100644
--- a/drivers/video/mxc/tve.c
+++ b/drivers/video/mxc/tve.c
@@ -646,7 +646,6 @@ static int _tve_get_revision(void)
 	return rev;
 }
 
-extern int g_di1_tvout;
 static int tve_probe(struct platform_device *pdev)
 {
 	int ret, i, primary = 0;
@@ -654,11 +653,6 @@ static int tve_probe(struct platform_device *pdev)
 	struct tve_platform_data *plat_data = pdev->dev.platform_data;
 	u32 conf_reg;
 
-	if (!g_di1_tvout) {
-		pr_debug("TVE: DI1 was occupied by other device,TVE will not enable\n");
-		return -EBUSY;
-	}
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL)
 		return -ENOMEM;
-- 
1.5.4.4

