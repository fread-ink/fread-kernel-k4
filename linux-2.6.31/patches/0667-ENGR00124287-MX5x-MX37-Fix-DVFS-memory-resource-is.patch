From c917c67e4670014d8e497c903949b984c1b657f1 Mon Sep 17 00:00:00 2001
From: Nancy Chen <Nancy.Chen@freescale.com>
Date: Wed, 9 Jun 2010 13:49:47 -0500
Subject: [PATCH] ENGR00124287 MX5x, MX37: Fix DVFS memory resource issue

MX5x, MX37: Fix DVFS memory resource issue.

Signed-off-by: Nancy Chen <Nancy.Chen@freescale.com>
---
 arch/arm/mach-mx37/crm_regs.h             |   25 ++----
 arch/arm/mach-mx37/devices.c              |   24 +++---
 arch/arm/mach-mx5/devices.c               |    2 +
 arch/arm/mach-mx5/mx51_3stack.c           |    4 -
 arch/arm/mach-mx5/mx51_babbage.c          |    4 -
 arch/arm/mach-mx5/mx53_evk.c              |    4 -
 arch/arm/plat-mxc/dptc.c                  |   78 +++++++++++-------
 arch/arm/plat-mxc/dvfs_core.c             |  127 ++++++++++++++++++-----------
 arch/arm/plat-mxc/dvfs_per.c              |  126 +++++++++++++++++------------
 arch/arm/plat-mxc/include/mach/mx37.h     |    3 +
 arch/arm/plat-mxc/include/mach/mxc_dvfs.h |   33 ++++++--
 11 files changed, 248 insertions(+), 182 deletions(-)

diff --git a/arch/arm/mach-mx37/crm_regs.h b/arch/arm/mach-mx37/crm_regs.h
index a03bc4e..607e7cf 100644
--- a/arch/arm/mach-mx37/crm_regs.h
+++ b/arch/arm/mach-mx37/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -10,6 +10,7 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
+
 #ifndef __ARCH_ARM_MACH_MX37_CRM_REGS_H__
 #define __ARCH_ARM_MACH_MX37_CRM_REGS_H__
 
@@ -548,21 +549,13 @@
 #define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
 #define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
 
-/* DPTC GP */
-#define MXC_GP_DPTCCR		(MXC_DPTC_GP_BASE + 0x00)
-#define MXC_GP_DPTCDBG		(MXC_DPTC_GP_BASE + 0x04)
-#define MXC_GP_DCVR0		(MXC_DPTC_GP_BASE + 0x08)
-#define MXC_GP_DCVR1		(MXC_DPTC_GP_BASE + 0x0C)
-#define MXC_GP_DCVR2		(MXC_DPTC_GP_BASE + 0x10)
-#define MXC_GP_DCVR3		(MXC_DPTC_GP_BASE + 0x14)
-
-/* DPTC LP */
-#define MXC_LP_DPTCCR		(MXC_DPTC_LP_BASE + 0x00)
-#define MXC_LP_DPTCDBG		(MXC_DPTC_LP_BASE + 0x04)
-#define MXC_LP_DCVR0		(MXC_DPTC_LP_BASE + 0x08)
-#define MXC_LP_DCVR1		(MXC_DPTC_LP_BASE + 0x0C)
-#define MXC_LP_DCVR2		(MXC_DPTC_LP_BASE + 0x10)
-#define MXC_LP_DCVR3		(MXC_DPTC_LP_BASE + 0x14)
+/* DPTC register offset */
+#define MXC_DPTCCR		0x00
+#define MXC_DPTCDBG		0x04
+#define MXC_DCVR0		0x08
+#define MXC_DCVR1		0x0C
+#define MXC_DCVR2		0x10
+#define MXC_DCVR3		0x14
 
 #define MXC_DPTCCR_DRCE3                     0x00400000
 #define MXC_DPTCCR_DRCE2                     0x00200000
diff --git a/arch/arm/mach-mx37/devices.c b/arch/arm/mach-mx37/devices.c
index e346899..fd4011b 100644
--- a/arch/arm/mach-mx37/devices.c
+++ b/arch/arm/mach-mx37/devices.c
@@ -645,8 +645,8 @@ void __init mxc_init_tve(void)
  */
 static struct resource dvfs_core_resources[] = {
 	[0] = {
-	       .start = MXC_DVFS_CORE_BASE,
-	       .end = MXC_DVFS_CORE_BASE + 4 * SZ_16 - 1,
+	       .start = DVFSCORE_BASE_ADDR,
+	       .end = DVFSCORE_BASE_ADDR + 4 * SZ_16 - 1,
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
@@ -666,10 +666,6 @@ struct mxc_dvfs_platform_data dvfs_core_data = {
 	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
 	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
 	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
-	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
-	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
-	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
-	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
 	.prediv_mask = 0x3800,
 	.prediv_offset = 11,
 	.prediv_val = 1,
@@ -710,8 +706,8 @@ static inline void mxc_init_dvfs_core(void)
  */
 static struct resource dptc_gp_resources[] = {
 	[0] = {
-	       .start = MXC_DPTC_GP_BASE,
-	       .end = MXC_DPTC_GP_BASE + 8 * SZ_16 - 1,
+	       .start = DPTCGP_BASE_ADDR,
+	       .end = DPTCGP_BASE_ADDR + 8 * SZ_16 - 1,
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
@@ -725,8 +721,8 @@ static struct resource dptc_gp_resources[] = {
 struct mxc_dptc_data dptc_gp_data = {
 	.reg_id = "SW1",
 	.clk_id = "cpu_clk",
-	.dptccr_reg_addr = MXC_GP_DPTCCR,
-	.dcvr0_reg_addr = MXC_GP_DCVR0,
+	.dptccr_reg_addr = MXC_DPTCCR,
+	.dcvr0_reg_addr = MXC_DCVR0,
 	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
 	.dptccr = MXC_GPCCNTR_DPTC0CR,
 	.dptc_wp_supported = DPTC_GP_WP_SUPPORTED,
@@ -754,8 +750,8 @@ struct mxc_dptc_data dptc_gp_data = {
  */
 static struct resource dptc_lp_resources[] = {
 	[0] = {
-	       .start = MXC_DPTC_LP_BASE,
-	       .end = MXC_DPTC_LP_BASE + 8 * SZ_16 - 1,
+	       .start = DPTCLP_BASE_ADDR,
+	       .end = DPTCLP_BASE_ADDR + 8 * SZ_16 - 1,
 	       .flags = IORESOURCE_MEM,
 	       },
 	[1] = {
@@ -769,8 +765,8 @@ static struct resource dptc_lp_resources[] = {
 struct mxc_dptc_data dptc_lp_data = {
 	.reg_id = "SW2",
 	.clk_id = "ahb_clk",
-	.dptccr_reg_addr = MXC_LP_DPTCCR,
-	.dcvr0_reg_addr = MXC_LP_DCVR0,
+	.dptccr_reg_addr = MXC_DPTCCR,
+	.dcvr0_reg_addr = MXC_DCVR0,
 	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
 	.dptccr = MXC_GPCCNTR_DPTC1CR,
 	.dptc_wp_supported = DPTC_LP_WP_SUPPORTED,
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
index 647a103..0b77377 100644
--- a/arch/arm/mach-mx5/devices.c
+++ b/arch/arm/mach-mx5/devices.c
@@ -1407,6 +1407,8 @@ int __init mxc_init_devices(void)
 		ssi2_resources[0].end -= MX53_OFFSET;
 		tve_resources[0].start -= MX53_OFFSET;
 		tve_resources[0].end -= MX53_OFFSET;
+		dvfs_core_resources[0].start -= MX53_OFFSET;
+		dvfs_core_resources[0].end -= MX53_OFFSET;
 		dvfs_per_resources[0].start -= MX53_OFFSET;
 		dvfs_per_resources[0].end -= MX53_OFFSET;
 		spdif_resources[0].start -= MX53_OFFSET;
diff --git a/arch/arm/mach-mx5/mx51_3stack.c b/arch/arm/mach-mx5/mx51_3stack.c
index 7c3d809..b8fd434 100644
--- a/arch/arm/mach-mx5/mx51_3stack.c
+++ b/arch/arm/mach-mx5/mx51_3stack.c
@@ -184,10 +184,6 @@ static struct mxc_dvfs_platform_data dvfs_core_data = {
 	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
 	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
 	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
-	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
-	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
-	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
-	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
 	.prediv_mask = 0x1F800,
 	.prediv_offset = 11,
 	.prediv_val = 3,
diff --git a/arch/arm/mach-mx5/mx51_babbage.c b/arch/arm/mach-mx5/mx51_babbage.c
index c6fc167..88afcc2 100644
--- a/arch/arm/mach-mx5/mx51_babbage.c
+++ b/arch/arm/mach-mx5/mx51_babbage.c
@@ -226,10 +226,6 @@ static struct mxc_dvfs_platform_data dvfs_core_data = {
 	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
 	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
 	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
-	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
-	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
-	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
-	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
 	.prediv_mask = 0x1F800,
 	.prediv_offset = 11,
 	.prediv_val = 3,
diff --git a/arch/arm/mach-mx5/mx53_evk.c b/arch/arm/mach-mx5/mx53_evk.c
index 1e87687..6c100b5 100644
--- a/arch/arm/mach-mx5/mx53_evk.c
+++ b/arch/arm/mach-mx5/mx53_evk.c
@@ -283,10 +283,6 @@ static struct mxc_dvfs_platform_data dvfs_core_data = {
 	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
 	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
 	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
-	.dvfs_thrs_reg_addr = MXC_DVFSTHRS,
-	.dvfs_coun_reg_addr = MXC_DVFSCOUN,
-	.dvfs_emac_reg_addr = MXC_DVFSEMAC,
-	.dvfs_cntr_reg_addr = MXC_DVFSCNTR,
 	.prediv_mask = 0x1F800,
 	.prediv_offset = 11,
 	.prediv_val = 3,
diff --git a/arch/arm/plat-mxc/dptc.c b/arch/arm/plat-mxc/dptc.c
index 6b7f559..a26fd9b 100644
--- a/arch/arm/plat-mxc/dptc.c
+++ b/arch/arm/plat-mxc/dptc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -67,6 +67,7 @@ enum {
 
 struct device *dev_data0;
 struct device *dev_data1;
+struct dptc_device *dptc_device_data;
 
 /*!
  * In case the MXC device has multiple DPTC modules, this structure is used to
@@ -89,6 +90,8 @@ struct dptc_device {
 	int curr_wp;
 	/* DPTC vai bits */
 	u32 ptvai;
+	/* The base address of the DPTC */
+	void __iomem *membase;
 	/* The interrupt number used by the DPTC device */
 	int irq;
 	/* DPTC platform data pointer */
@@ -104,13 +107,13 @@ static void update_dptc_wp(struct dptc_device *drv_data, u32 wp)
 	voltage_uV = dptc_data->dptc_wp_allfreq[wp].voltage * 1000;
 
 	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr0,
-		     dptc_data->dcvr0_reg_addr);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr);
 	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr1,
-		     dptc_data->dcvr0_reg_addr + 0x4);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr + 0x4);
 	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr2,
-		     dptc_data->dcvr0_reg_addr + 0x8);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr + 0x8);
 	__raw_writel(dptc_data->dptc_wp_allfreq[wp].dcvr3,
-		     dptc_data->dcvr0_reg_addr + 0xC);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr + 0xC);
 
 	/* Set the voltage */
 	ret = regulator_set_voltage(drv_data->dptc_reg, voltage_uV, voltage_uV);
@@ -130,7 +133,8 @@ static irqreturn_t dptc_irq(int irq, void *dev_id)
 	struct device *dev = dev_id;
 	struct dptc_device *drv_data = dev->driver_data;
 	struct mxc_dptc_data *dptc_data = dev->platform_data;
-	u32 dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	u32 dptccr = __raw_readl(drv_data->membase
+				 + dptc_data->dptccr_reg_addr);
 	u32 gpc_cntr = __raw_readl(dptc_data->gpc_cntr_reg_addr);
 
 	gpc_cntr = (gpc_cntr & dptc_data->dptccr);
@@ -145,7 +149,8 @@ static irqreturn_t dptc_irq(int irq, void *dev_id)
 		dptccr = (dptccr & ~(dptc_data->dptc_enable_bit)) |
 		    (dptc_data->irq_mask);
 		dptccr = (dptccr & ~(dptc_data->dptc_nvcr_bit));
-		__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+		__raw_writel(dptccr, drv_data->membase
+			     + dptc_data->dptccr_reg_addr);
 
 		if (drv_data->turbo_mode_active == 1)
 			schedule_delayed_work(&drv_data->dptc_work, 0);
@@ -162,7 +167,8 @@ static void dptc_workqueue_handler(struct work_struct *work1)
 	struct dptc_device *drv_data =
 	    container_of(dptc_work_tmp, struct dptc_device, dptc_work);
 	struct mxc_dptc_data *dptc_data = drv_data->dptc_platform_data;
-	u32 dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	u32 dptccr = __raw_readl(drv_data->membase
+				 + dptc_data->dptccr_reg_addr);
 
 	switch (drv_data->ptvai) {
 	case DPTC_PTVAI_DECREASE:
@@ -193,7 +199,7 @@ static void dptc_workqueue_handler(struct work_struct *work1)
 	/* Enable DPTC and unmask its interrupt */
 	dptccr = (dptccr & ~(dptc_data->irq_mask)) |
 	    dptc_data->dptc_nvcr_bit | dptc_data->dptc_enable_bit;
-	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+	__raw_writel(dptccr, drv_data->membase + dptc_data->dptccr_reg_addr);
 }
 
 /* Start DPTC unconditionally */
@@ -228,12 +234,12 @@ static int start_dptc(struct device *dev)
 			     dptc_data->gpc_cntr_reg_addr);
 	}
 
-	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	dptccr = __raw_readl(drv_data->membase + dptc_data->dptccr_reg_addr);
 
 	/* Enable DPTC and unmask its interrupt */
 	dptccr = ((dptccr & ~(dptc_data->irq_mask)) | dptc_data->enable_config);
 
-	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+	__raw_writel(dptccr, drv_data->membase + dptc_data->dptccr_reg_addr);
 
 	spin_unlock_irqrestore(&drv_data->lock, flags);
 
@@ -257,13 +263,13 @@ static void stop_dptc(struct device *dev)
 	struct dptc_device *drv_data = dev->driver_data;
 	u32 dptccr;
 
-	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	dptccr = __raw_readl(drv_data->membase + dptc_data->dptccr_reg_addr);
 
 	/* disable DPTC and mask its interrupt */
 	dptccr = ((dptccr & ~(dptc_data->dptc_enable_bit)) |
 		  dptc_data->irq_mask) & (~dptc_data->dptc_nvcr_bit);
 
-	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+	__raw_writel(dptccr, drv_data->membase + dptc_data->dptccr_reg_addr);
 
 	/* Restore Turbo Mode voltage to highest wp */
 	update_dptc_wp(drv_data, 0);
@@ -304,12 +310,12 @@ void dptc_suspend(int id)
 	if (!drv_data->dptc_is_active)
 		return;
 
-	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	dptccr = __raw_readl(drv_data->membase + dptc_data->dptccr_reg_addr);
 
 	/* Disable DPTC and mask its interrupt */
 	dptccr = (dptccr & ~(dptc_data->dptc_enable_bit)) | dptc_data->irq_mask;
 
-	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+	__raw_writel(dptccr, drv_data->membase + dptc_data->dptccr_reg_addr);
 }
 EXPORT_SYMBOL(dptc_suspend);
 
@@ -344,20 +350,20 @@ void dptc_resume(int id)
 		return;
 
 	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr0,
-		     dptc_data->dcvr0_reg_addr);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr);
 	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr1,
-		     dptc_data->dcvr0_reg_addr + 0x4);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr + 0x4);
 	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr2,
-		     dptc_data->dcvr0_reg_addr + 0x8);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr + 0x8);
 	__raw_writel(dptc_data->dptc_wp_allfreq[0].dcvr3,
-		     dptc_data->dcvr0_reg_addr + 0xC);
+		     drv_data->membase + dptc_data->dcvr0_reg_addr + 0xC);
 
-	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	dptccr = __raw_readl(drv_data->membase + dptc_data->dptccr_reg_addr);
 
 	/* Enable DPTC and unmask its interrupt */
 	dptccr = (dptccr & ~(dptc_data->irq_mask)) | dptc_data->dptc_enable_bit;
 
-	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+	__raw_writel(dptccr, drv_data->membase + dptc_data->dptccr_reg_addr);
 }
 EXPORT_SYMBOL(dptc_resume);
 
@@ -426,7 +432,6 @@ static DEVICE_ATTR(enable, 0644, dptc_show, dptc_store);
  */
 static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 {
-	struct dptc_device *dptc_device_data;
 	int ret = 0;
 	struct resource *res;
 	u32 dptccr = 0;
@@ -449,13 +454,16 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 		goto err1;
 	}
 
+	dptc_device_data->membase = ioremap(res->start,
+					    res->end - res->start + 1);
+
 	/*
 	 * Request the DPTC interrupt
 	 */
 	dptc_device_data->irq = platform_get_irq(pdev, 0);
 	if (dptc_device_data->irq < 0) {
 		ret = dptc_device_data->irq;
-		goto err1;
+		goto err2;
 	}
 
 	ret =
@@ -463,7 +471,7 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 			pdev->name, &pdev->dev);
 	if (ret) {
 		printk(KERN_ERR "DPTC: Unable to attach to DPTC interrupt\n");
-		goto err1;
+		goto err2;
 	}
 
 	dptc_device_data->curr_wp = 0;
@@ -471,7 +479,8 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 	dptc_device_data->turbo_mode_active = 0;
 	dptc_device_data->ptvai = 0;
 
-	dptccr = __raw_readl(dptc_data->dptccr_reg_addr);
+	dptccr = __raw_readl(dptc_device_data->membase
+			     + dptc_data->dptccr_reg_addr);
 
 	printk(KERN_INFO "DPTC mxc_dptc_probe()\n");
 
@@ -487,32 +496,33 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 		else
 			printk(KERN_ERR "DPTC: Pointer to DPTC table is NULL\
 					not started\n");
-		goto err1;
+		goto err3;
 	}
 
 	dptc_device_data->dptc_reg = regulator_get(NULL, dptc_data->reg_id);
 	if (IS_ERR(dptc_device_data->dptc_reg)) {
 		clk_put(dptc_device_data->dptc_clk);
 		printk(KERN_ERR "%s: failed to get regulator\n", __func__);
-		goto err1;
+		goto err3;
 	}
 
 	INIT_DELAYED_WORK(&dptc_device_data->dptc_work, dptc_workqueue_handler);
 
 	/* Enable Reference Circuits */
 	dptccr = (dptccr & ~(dptc_data->dcr_mask)) | dptc_data->init_config;
-	__raw_writel(dptccr, dptc_data->dptccr_reg_addr);
+	__raw_writel(dptccr, dptc_device_data->membase
+			     + dptc_data->dptccr_reg_addr);
 
 	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_enable.attr);
 	if (ret) {
 		printk(KERN_ERR
 		       "DPTC: Unable to register sysdev entry for dptc");
-		goto err1;
+		goto err3;
 	}
 
 	if (ret != 0) {
 		printk(KERN_ERR "DPTC: Unable to start");
-		goto err1;
+		goto err3;
 	}
 
 	dptc_device_data->dptc_clk = clk_get(NULL, dptc_data->clk_id);
@@ -529,6 +539,10 @@ static int __devinit mxc_dptc_probe(struct platform_device *pdev)
 
 	return 0;
 
+err3:
+	free_irq(dptc_device_data->irq, &pdev->dev);
+err2:
+	iounmap(dptc_device_data->membase);
 err1:
 	dev_err(&pdev->dev, "Failed to probe DPTC\n");
 	kfree(dptc_device_data);
@@ -607,6 +621,10 @@ static int __init dptc_init(void)
 
 static void __exit dptc_cleanup(void)
 {
+	free_irq(dptc_device_data->irq, NULL);
+	iounmap(dptc_device_data->membase);
+	kfree(dptc_device_data);
+
 	/* Unregister the device structure */
 	platform_driver_unregister(&mxc_dptc_driver);
 
diff --git a/arch/arm/plat-mxc/dvfs_core.c b/arch/arm/plat-mxc/dvfs_core.c
index 98a8bf2..c2df94c 100644
--- a/arch/arm/plat-mxc/dvfs_core.c
+++ b/arch/arm/plat-mxc/dvfs_core.c
@@ -135,18 +135,19 @@ static void dvfs_load_config(int set_point)
 	reg |= dvfs_core_setpoint[set_point].downthr <<
 	    MXC_DVFSTHRS_DNTHR_OFFSET;
 	reg |= dvfs_core_setpoint[set_point].panicthr;
-	__raw_writel(reg, dvfs_data->dvfs_thrs_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_THRS);
 
 	reg = 0;
 	reg |= dvfs_core_setpoint[set_point].downcnt <<
 	    MXC_DVFSCOUN_DNCNT_OFFSET;
 	reg |= dvfs_core_setpoint[set_point].upcnt << MXC_DVFSCOUN_UPCNT_OFFSET;
-	__raw_writel(reg, dvfs_data->dvfs_coun_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_COUN);
 
 	/* Set EMAC value */
 	__raw_writel((dvfs_core_setpoint[set_point].emac <<
 					MXC_DVFSEMAC_EMAC_OFFSET),
-					dvfs_data->dvfs_emac_reg_addr);
+					dvfs_data->membase
+					+ MXC_DVFSCORE_EMAC);
 
 
 }
@@ -202,7 +203,7 @@ static int set_cpu_freq(int wp)
 			reg |= 1 << MXC_GPCVCR_VINC_OFFSET;
 
 		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
-		    (1 << MXC_GPCVCR_VCNT_OFFSET);
+		       (1 << MXC_GPCVCR_VCNT_OFFSET);
 		__raw_writel(reg, dvfs_data->gpc_vcr_reg_addr);
 
 		reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
@@ -354,13 +355,13 @@ static int start_dvfs(void)
 	__raw_writel(reg, dvfs_data->gpc_cntr_reg_addr);
 
 	/* Set PREDIV bits */
-	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	reg = (reg & ~(dvfs_data->prediv_mask));
 	reg |= (dvfs_data->prediv_val) << (dvfs_data->prediv_offset);
-	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 
 	/* Enable DVFS interrupt */
-	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	/* FSVAIM=0 */
 	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
 	/* Set MAXF, MINF */
@@ -376,12 +377,12 @@ static int start_dvfs(void)
 	/* Set DIV3CK */
 	reg = (reg & ~(dvfs_data->div3ck_mask));
 	reg |= (dvfs_data->div3ck_val) << (dvfs_data->div3ck_offset);
-	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 
 	/* Enable DVFS */
-	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	reg |= MXC_DVFSCNTR_DVFEN;
-	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 
 	dvfs_core_is_active = 1;
 
@@ -421,10 +422,10 @@ static irqreturn_t dvfs_irq(int irq, void *dev_id)
 		return IRQ_NONE;
 
 	/* Mask DVFS irq */
-	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	/* FSVAIM=1 */
 	reg |= MXC_DVFSCNTR_FSVAIM;
-	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 
 	/* Mask GPC1 irq */
 	reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
@@ -448,7 +449,7 @@ static void dvfs_core_work_handler(struct work_struct *work)
 	low_freq_bus_ready = low_freq_bus_used();
 
 	/* Check DVFS frequency adjustment interrupt status */
-	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	fsvai = (reg & MXC_DVFSCNTR_FSVAI_MASK) >> MXC_DVFSCNTR_FSVAI_OFFSET;
 	/* Check FSVAI, FSVAI=0 is error */
 	if (fsvai == FSVAI_FREQ_NOCHANGE) {
@@ -520,7 +521,7 @@ static void dvfs_core_work_handler(struct work_struct *work)
 
 
 END:	/* Set MAXF, MINF */
-	reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	reg = (reg & ~(MXC_DVFSCNTR_MAXF_MASK | MXC_DVFSCNTR_MINF_MASK));
 	reg |= maxf << MXC_DVFSCNTR_MAXF_OFFSET;
 	reg |= minf << MXC_DVFSCNTR_MINF_OFFSET;
@@ -532,7 +533,7 @@ END:	/* Set MAXF, MINF */
 	/* LBFL=1 */
 	reg = (reg & ~MXC_DVFSCNTR_LBFL);
 	reg |= MXC_DVFSCNTR_LBFL;
-	__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 	/*Unmask GPC1 IRQ */
 	reg = __raw_readl(dvfs_data->gpc_cntr_reg_addr);
 	reg &= ~MXC_GPCCNTR_GPCIRQM;
@@ -559,10 +560,12 @@ static void stop_dvfs(void)
 	if (dvfs_core_is_active) {
 
 		/* Mask dvfs irq, disable DVFS */
-		reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+		reg = __raw_readl(dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
 		/* FSVAIM=1 */
 		reg |= MXC_DVFSCNTR_FSVAIM;
-		__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+		__raw_writel(reg, dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
 
 		curr_wp = 0;
 		if (!high_bus_freq_mode)
@@ -580,9 +583,11 @@ static void stop_dvfs(void)
 		}
 		spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
 
-		reg = __raw_readl(dvfs_data->dvfs_cntr_reg_addr);
+		reg = __raw_readl(dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
 		reg = (reg & ~MXC_DVFSCNTR_DVFEN);
-		__raw_writel(reg, dvfs_data->dvfs_cntr_reg_addr);
+		__raw_writel(reg, dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
 
 		spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
 
@@ -610,39 +615,56 @@ void dump_dvfs_core_regs()
 		printk(KERN_DEBUG "diff = %d\n", diff);
 
 	printk(KERN_INFO "THRS = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS));
 	printk(KERN_INFO "COUNT = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x04));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x04));
 	printk(KERN_INFO "SIG1 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x08));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x08));
 	printk(KERN_INFO "SIG0 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x0c));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x0c));
 	printk(KERN_INFO "GPC0 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x10));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x10));
 	printk(KERN_INFO "GPC1 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x14));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x14));
 	printk(KERN_INFO "GPBT = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x18));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x18));
 	printk(KERN_INFO "EMAC = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x1c));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x1c));
 	printk(KERN_INFO "CNTR = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x20));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x20));
 	printk(KERN_INFO "LTR0_0 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x24));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x24));
 	printk(KERN_INFO "LTR0_1 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x28));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x28));
 	printk(KERN_INFO "LTR1_0 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x2c));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x2c));
 	printk(KERN_DEBUG "LTR1_1 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x30));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x30));
 	printk(KERN_INFO "PT0 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x34));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x34));
 	printk(KERN_INFO "PT1 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x38));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x38));
 	printk(KERN_INFO "PT2 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x3c));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x3c));
 	printk(KERN_INFO "PT3 = 0x%08x\n",
-			__raw_readl(dvfs_data->dvfs_thrs_reg_addr+0x40));
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x40));
 }
 
 static ssize_t downthreshold_show(struct device *dev,
@@ -741,7 +763,6 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 {
 	int err = 0;
 	struct resource *res;
-	int irq;
 
 	printk(KERN_INFO "mxc_dvfs_core_probe\n");
 	dvfs_dev = &pdev->dev;
@@ -780,22 +801,26 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 		err = -ENODEV;
 		goto err1;
 	}
+	dvfs_data->membase = ioremap(res->start, res->end - res->start + 1);
 
 	/*
 	 * Request the DVFS interrupt
 	 */
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		err = irq;
-		goto err1;
+	dvfs_data->irq = platform_get_irq(pdev, 0);
+	if (dvfs_data->irq < 0) {
+		err = dvfs_data->irq;
+		goto err2;
 	}
 
 	/* request the DVFS interrupt */
-	err = request_irq(irq, dvfs_irq, IRQF_SHARED, "dvfs", dvfs_dev);
-	if (err)
+	err = request_irq(dvfs_data->irq, dvfs_irq, IRQF_SHARED, "dvfs",
+			  dvfs_dev);
+	if (err) {
 		printk(KERN_ERR
 		       "DVFS: Unable to attach to DVFS interrupt,err = %d",
 		       err);
+		goto err2;
+	}
 
 	clk_enable(dvfs_clk);
 	err = init_dvfs_controller();
@@ -809,14 +834,14 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 	if (err) {
 		printk(KERN_ERR
 		       "DVFS: Unable to register sysdev entry for DVFS");
-		return err;
+		goto err3;
 	}
 
 	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_show_regs.attr);
 	if (err) {
 		printk(KERN_ERR
 		       "DVFS: Unable to register sysdev entry for DVFS");
-		return err;
+		goto err3;
 	}
 
 
@@ -824,14 +849,14 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 	if (err) {
 		printk(KERN_ERR
 		       "DVFS: Unable to register sysdev entry for DVFS");
-		return err;
+		goto err3;
 	}
 
 	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_down_count.attr);
 	if (err) {
 		printk(KERN_ERR
 		       "DVFS: Unable to register sysdev entry for DVFS");
-		return err;
+		goto err3;
 	}
 
 	/* Set the current working point. */
@@ -842,7 +867,10 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 	cpufreq_trig_needed = 0;
 
 	return err;
-
+err3:
+	free_irq(dvfs_data->irq, dvfs_dev);
+err2:
+	iounmap(dvfs_data->membase);
 err1:
 	dev_err(&pdev->dev, "Failed to probe DVFS CORE\n");
 	return err;
@@ -912,13 +940,14 @@ static void __exit dvfs_cleanup(void)
 	stop_dvfs();
 
 	/* release the DVFS interrupt */
-	free_irq(MXC_INT_GPC1, NULL);
+	free_irq(dvfs_data->irq, dvfs_dev);
 
 	sysfs_remove_file(&dvfs_dev->kobj, &dev_attr_enable.attr);
 
 	/* Unregister the device structure */
 	platform_driver_unregister(&mxc_dvfs_core_driver);
 
+	iounmap(dvfs_data->membase);
 	clk_put(cpu_clk);
 	clk_put(dvfs_clk);
 
diff --git a/arch/arm/plat-mxc/dvfs_per.c b/arch/arm/plat-mxc/dvfs_per.c
index 43d0dfc..e57f8a2 100644
--- a/arch/arm/plat-mxc/dvfs_per.c
+++ b/arch/arm/plat-mxc/dvfs_per.c
@@ -51,15 +51,14 @@
 #endif
 
 /* DVFS PER */
-static void __iomem *dvfs_per_base;
-#define MXC_DVFS_PER_LTR0	(dvfs_per_base)
-#define MXC_DVFS_PER_LTR1	(dvfs_per_base + 0x04)
-#define MXC_DVFS_PER_LTR2	(dvfs_per_base + 0x08)
-#define MXC_DVFS_PER_LTR3	(dvfs_per_base + 0x0C)
-#define MXC_DVFS_PER_LTBR0	(dvfs_per_base + 0x10)
-#define MXC_DVFS_PER_LTBR1	(dvfs_per_base + 0x14)
-#define MXC_DVFS_PER_PMCR0	(dvfs_per_base + 0x18)
-#define MXC_DVFS_PER_PMCR1	(dvfs_per_base + 0x1C)
+#define MXC_DVFS_PER_LTR0	0x00
+#define MXC_DVFS_PER_LTR1	0x04
+#define MXC_DVFS_PER_LTR2	0x08
+#define MXC_DVFS_PER_LTR3	0x0C
+#define MXC_DVFS_PER_LTBR0	0x10
+#define MXC_DVFS_PER_LTBR1	0x14
+#define MXC_DVFS_PER_PMCR0	0x18
+#define MXC_DVFS_PER_PMCR1	0x1C
 
 #define DRIVER_NAME "DVFSPER"
 #define DVFS_PER_DEBUG 0
@@ -134,16 +133,16 @@ static void dvfs_per_load_config(void)
 {
 	u32 reg;
 
-	reg = __raw_readl(MXC_DVFS_PER_LTR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
 	reg &= ~MXC_DVFSLTR0_UPTHR_MASK;
 	reg &= ~MXC_DVFSLTR0_DNTHR_MASK;
 	reg |= dvfs_per_setpoint[cur_setpoint].upthr <<
 						MXC_DVFSLTR0_UPTHR_OFFSET;
 	reg |= dvfs_per_setpoint[cur_setpoint].downthr <<
 						MXC_DVFSLTR0_DNTHR_OFFSET;
-	__raw_writel(reg, MXC_DVFS_PER_LTR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
 
-	reg = __raw_readl(MXC_DVFS_PER_LTR1);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
 	reg &= ~MXC_DVFSLTR1_PNCTHR_MASK;
 	reg &= ~MXC_DVFSLTR1_DNCNT_MASK;
 	reg &= ~MXC_DVFSLTR1_UPCNT_MASK;
@@ -153,11 +152,11 @@ static void dvfs_per_load_config(void)
 				MXC_DVFSLTR1_UPCNT_OFFSET;
 	reg |= dvfs_per_setpoint[cur_setpoint].panicthr <<
 				MXC_DVFSLTR1_PNCTHR_OFFSET;
-	__raw_writel(reg, MXC_DVFS_PER_LTR1);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
 
 	reg = dvfs_per_setpoint[cur_setpoint].emac <<
 				MXC_DVFSLTR2_EMAC_OFFSET;
-	__raw_writel(reg, MXC_DVFS_PER_LTR2);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR2);
 }
 
 /*!
@@ -175,29 +174,29 @@ static int init_dvfs_per_controller(void)
 {
 	u32 reg;
 
-	reg = __raw_readl(MXC_DVFS_PER_LTR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
 	/* DIV3CLK */
 	reg &= ~dvfsper_plt_data->div3_mask;
 	reg |= (dvfsper_plt_data->div3_div <<
 		  dvfsper_plt_data->div3_offset);
-	__raw_writel(reg, MXC_DVFS_PER_LTR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
 
-	reg = __raw_readl(MXC_DVFS_PER_LTR1);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
 	/* Set load tracking buffer register source */
 	reg &= ~MXC_DVFSLTR1_LTBRSR;
 	reg |= MXC_DVFSLTR1_LTBRSR;
 	reg &= ~MXC_DVFSLTR1_LTBRSH;
-	__raw_writel(reg, MXC_DVFS_PER_LTR1);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
 
 	/* Enable all the peripheral signals, but VPU and IPU panic*/
-	__raw_writel(0x30000, MXC_DVFS_PER_PMCR1);
+	__raw_writel(0x30000, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR1);
 	/* Disable weighted load tracking signals */
-	__raw_writel(0, MXC_DVFS_PER_LTR3);
+	__raw_writel(0, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR3);
 
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	reg &= ~MXC_DVFSPMCR0_DVFEV;
 	reg |= MXC_DVFSPMCR0_LBMI;
-	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 
 	/* DVFS loading config */
 	dvfs_per_load_config();
@@ -220,14 +219,22 @@ static void dump_dvfs_per_regs(void)
 	if (diff < 90000)
 		printk(KERN_INFO "diff = %d\n", diff);
 
-	printk(KERN_INFO "LTRO = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR0));
-	printk(KERN_INFO "LTR1 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR1));
-	printk(KERN_INFO "LTR2 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR2));
-	printk(KERN_INFO "LTR3 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTR3));
-	printk(KERN_INFO "LBTR0 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTBR0));
-	printk(KERN_INFO "LBTR1 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_LTBR1));
-	printk(KERN_INFO "PMCR0 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_PMCR0));
-	printk(KERN_INFO "PMCR1 = 0x%08x\n", __raw_readl(MXC_DVFS_PER_PMCR1));
+	printk(KERN_INFO "LTRO = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0));
+	printk(KERN_INFO "LTR1 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1));
+	printk(KERN_INFO "LTR2 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR2));
+	printk(KERN_INFO "LTR3 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR3));
+	printk(KERN_INFO "LBTR0 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTBR0));
+	printk(KERN_INFO "LBTR1 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTBR1));
+	printk(KERN_INFO "PMCR0 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0));
+	printk(KERN_INFO "PMCR1 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR1));
 }
 #endif
 
@@ -240,21 +247,22 @@ static irqreturn_t dvfs_per_irq(int irq, void *dev_id)
 						MXC_GPCCNTR_DVFS1CR) == 0)
 		return IRQ_NONE;
 	/* Mask DVFS irq */
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	/* FSVAIM=1 */
 	reg |= MXC_DVFSPMCR0_FSVAIM;
-	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	/* Mask GPC1 irq */
 	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
 	reg |= MXC_GPCCNTR_GPCIRQM | 0x1000000;
 	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
 
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	if (reg & MXC_DVFSPMCR0_LBFL) {
 		/* clear LBFL */
 		reg = (reg & ~MXC_DVFSPMCR0_LBFL);
 		reg |= MXC_DVFSPMCR0_LBFL;
-		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 	}
 	schedule_delayed_work(&dvfs_per_work, 0);
 	return IRQ_HANDLED;
@@ -269,7 +277,7 @@ static void dvfs_per_handler(struct work_struct *work)
 	int retry = 20;
 
 	/* Check DVFS frequency adjustment interrupt status */
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	fsvai = (reg & MXC_DVFSPMCR0_FSVAI_MASK) >> MXC_DVFSPMCR0_FSVAI_OFFSET;
 	/* Check FSVAI, FSVAI=0 is error */
 	if (fsvai == FSVAI_FREQ_NOCHANGE) {
@@ -290,9 +298,11 @@ static void dvfs_per_handler(struct work_struct *work)
 
 #ifndef DVFS_SW_WORKAROUND
 		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
-		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 		reg &= ~MXC_DVFSPMCR0_UDCS;
-		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 
 		/* Set the peripheral divider */
 		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
@@ -367,9 +377,11 @@ static void dvfs_per_handler(struct work_struct *work)
 
 #ifndef DVFS_SW_WORKAROUND
 		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
-		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 		reg |= MXC_DVFSPMCR0_UDCS;
-		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 
 		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
 		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
@@ -432,13 +444,15 @@ END:
 	dump_dvfs_per_regs(void)();
 #endif
 	if (dvfs_per_is_active) {
-		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 		/* Enable dVFS interrupt */
 		/* FSVAIM=0 */
 		reg &= ~MXC_DVFSPMCR0_FSVAI_MASK;
 		reg |= FSVAI_FREQ_NOCHANGE;
 		reg = (reg & ~MXC_DVFSPMCR0_FSVAIM);
-		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 		/*Unmask GPC1 IRQ */
 		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
 		reg &= ~MXC_GPCCNTR_GPCIRQM;
@@ -453,9 +467,9 @@ static void force_freq_change(void)
 
 	freq_increased = 0;
 
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	reg |= MXC_DVFSPMCR0_UDCS;
-	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 
 	if (cpu_is_mx51()) {
 		/*Change the DDR freq to 133Mhz. */
@@ -513,7 +527,8 @@ static int start(void)
 
 	if (bus_freq_scaling_is_active) {
 		dvfs_per_is_paused = 1;
-		printk(KERN_INFO "Cannot start DVFS-PER since bus_freq_scaling is active\n");
+		printk(KERN_INFO "Cannot start DVFS-PER since bus_freq_scaling\
+			is active\n");
 		return 0;
 	}
 
@@ -539,7 +554,7 @@ static int start(void)
 	reg &= ~MXC_GPCCNTR_ADU;
 	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
 
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	/* Select ARM domain */
 	reg |= MXC_DVFSPMCR0_DVFIS;
 	/* Set the UDCS bit */
@@ -550,7 +565,7 @@ static int start(void)
 	/*Set the FSVAI to no_freq_change */
 	reg &= ~MXC_DVFSPMCR0_FSVAI_MASK;
 	reg |= FSVAI_FREQ_NOCHANGE << MXC_DVFSPMCR0_FSVAI_OFFSET;
-	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 
 	/* config reg GPC_CNTR */
 	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
@@ -560,9 +575,9 @@ static int start(void)
 	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
 
 	/* Enable DVFS */
-	reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 	reg |= MXC_DVFSPMCR0_DVFEN;
-	__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
 
 	dvfs_per_is_active = 1;
 	spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
@@ -598,17 +613,21 @@ static void stop(void)
 		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
 
 		/* Mask dvfs irq, disable DVFS */
-		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 		/* FSVAIM=1 */
 		reg |= MXC_DVFSPMCR0_FSVAIM;
-		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 
 		if (cur_setpoint != 0)
 			force_freq_change();
 
-		reg = __raw_readl(MXC_DVFS_PER_PMCR0);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 		reg = (reg & ~MXC_DVFSPMCR0_DVFEN);
-		__raw_writel(reg, MXC_DVFS_PER_PMCR0);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
 
 		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
 		clk_disable(dvfs_clk);
@@ -770,7 +789,8 @@ static int __devinit mxc_dvfsper_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto err1;
 	}
-	dvfs_per_base = gpc_base + 0x1C4;
+	dvfsper_plt_data->membase = ioremap(res->start,
+					    res->end - res->start + 1);
 
 	/*
 	 * Request the DVFSPER interrupt
diff --git a/arch/arm/plat-mxc/include/mach/mx37.h b/arch/arm/plat-mxc/include/mach/mx37.h
index 3013d19..d83bdfd 100644
--- a/arch/arm/plat-mxc/include/mach/mx37.h
+++ b/arch/arm/plat-mxc/include/mach/mx37.h
@@ -225,6 +225,9 @@
 #define WEIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DA000)
 #define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DB000)
 
+#define DPTCLP_BASE_ADDR 	(GPC_BASE_ADDR + 0x80)
+#define DPTCGP_BASE_ADDR 	(GPC_BASE_ADDR + 0x100)
+#define DVFSCORE_BASE_ADDR 	(GPC_BASE_ADDR + 0x180)
 #define DVFSPER_BASE_ADDR 	(GPC_BASE_ADDR + 0x1C4)
 
 /*
diff --git a/arch/arm/plat-mxc/include/mach/mxc_dvfs.h b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
index fd0179b..43bcd2f 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
@@ -101,6 +101,25 @@ extern void __iomem *gpc_base;
 #define MXC_DVFSPMCR1_P4PM		0x00020000
 #define MXC_DVFSPMCR1_P2PM		0x00010000
 
+/* DVFS CORE register offsets*/
+#define MXC_DVFSCORE_THRS		0x00
+#define MXC_DVFSCORE_COUN		0x04
+#define MXC_DVFSCORE_SIG1		0x08
+#define MXC_DVFSCORE_SIG0		0x0C
+#define MXC_DVFSCORE_GPC0		0x10
+#define MXC_DVFSCORE_GPC1		0x14
+#define MXC_DVFSCORE_GPBT		0x18
+#define MXC_DVFSCORE_EMAC		0x1C
+#define MXC_DVFSCORE_CNTR		0x20
+#define MXC_DVFSCORE_LTR0_0		0x24
+#define MXC_DVFSCORE_LTR0_1		0x28
+#define MXC_DVFSCORE_LTR1_0		0x2C
+#define MXC_DVFSCORE_LTR1_1		0x30
+#define MXC_DVFSCORE_PT0 		0x34
+#define MXC_DVFSCORE_PT1 		0x38
+#define MXC_DVFSCORE_PT2 		0x3C
+#define MXC_DVFSCORE_PT3 		0x40
+
 /*
  * DVFS structure
  */
@@ -120,6 +139,10 @@ struct mxc_dvfs_platform_data {
 	char *clk1_id;
 	/* DVFS clock name string */
 	char *clk2_id;
+	/* The base address of the DVFS core */
+	void __iomem *membase;
+	/* The interrupt number used by the DVFS core */
+	int irq;
 	/* GPC control reg address */
 	void __iomem *gpc_cntr_reg_addr;
 	/* GPC voltage counter reg address */
@@ -130,14 +153,6 @@ struct mxc_dvfs_platform_data {
 	void __iomem *ccm_cacrr_reg_addr;
 	/* CCM divider handshake in-progree reg address */
 	void __iomem *ccm_cdhipr_reg_addr;
-	/* DVFS threshold reg address */
-	void __iomem *dvfs_thrs_reg_addr;
-	/* DVFS counters reg address */
-	void __iomem *dvfs_coun_reg_addr;
-	/* DVFS EMAC reg address */
-	void __iomem *dvfs_emac_reg_addr;
-	/* DVFS control reg address */
-	void __iomem *dvfs_cntr_reg_addr;
 	/* PREDIV mask */
 	u32 prediv_mask;
 	/* PREDIV offset */
@@ -182,6 +197,8 @@ struct mxc_dvfsper_data {
 	char *reg_id;
 	/* DVFS clock name string */
 	char *clk_id;
+	/* The base address of the DVFS per */
+	void __iomem *membase;
 	/* GPC control reg address */
 	void __iomem *gpc_cntr_reg_addr;
 	/* GPC VCR reg address */
-- 
1.5.4.4

