From eb8615f2539ab82c65dc871ee599ef4ab35112e9 Mon Sep 17 00:00:00 2001
From: Rob Herring <r.herring@freescale.com>
Date: Wed, 7 Jul 2010 17:51:47 -0500
Subject: [PATCH] ENGR00124849-3 mx5: add mx50 support

Add support for i.MX50 and arm2 board with lpddr/mddr.

Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
Signed-off-by: Rob Herring <r.herring@freescale.com>
---
 arch/arm/configs/imx5_defconfig            |    2 +
 arch/arm/mach-mx5/Kconfig                  |   13 +-
 arch/arm/mach-mx5/Makefile                 |   14 +-
 arch/arm/mach-mx5/Makefile.boot            |    3 +
 arch/arm/mach-mx5/bus_freq.c               |    7 +-
 arch/arm/mach-mx5/clock.c                  |   46 +-
 arch/arm/mach-mx5/clock_mx50.c             | 3135 ++++++++++++++++++++++++++++
 arch/arm/mach-mx5/cpu.c                    |   21 +-
 arch/arm/mach-mx5/devices.c                |   79 +-
 arch/arm/mach-mx5/devices.h                |    4 +
 arch/arm/mach-mx5/dma.c                    |   69 +-
 arch/arm/mach-mx5/iomux.c                  |   14 +-
 arch/arm/mach-mx5/mm.c                     |    2 +-
 arch/arm/mach-mx5/mx50_arm2.c              |  433 ++++
 arch/arm/mach-mx5/mx50_arm2_gpio.c         |  591 ++++++
 arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c |  419 ++++
 arch/arm/mach-mx5/mx50_pins.h              |  340 +++
 arch/arm/mach-mx5/sdma_script_code_mx50.h  |  130 ++
 arch/arm/mach-mx5/sdram_autogating.c       |    5 +
 arch/arm/mach-mx5/serial.c                 |    2 +-
 arch/arm/mach-mx5/usb_h1.c                 |   35 +-
 arch/arm/plat-mxc/include/mach/arc_otg.h   |    7 +-
 arch/arm/plat-mxc/include/mach/common.h    |    1 +
 arch/arm/plat-mxc/include/mach/memory.h    |    4 +
 arch/arm/plat-mxc/include/mach/mx5x.h      |   58 +-
 arch/arm/plat-mxc/include/mach/mxc.h       |   15 +-
 arch/arm/plat-mxc/pwm.c                    |    2 +-
 arch/arm/plat-mxc/usb_common.c             |   39 +-
 arch/arm/tools/mach-types                  |  439 ++++-
 29 files changed, 5848 insertions(+), 81 deletions(-)

diff --git a/arch/arm/configs/imx5_defconfig b/arch/arm/configs/imx5_defconfig
index 5b8f801..2886679 100644
--- a/arch/arm/configs/imx5_defconfig
+++ b/arch/arm/configs/imx5_defconfig
@@ -197,11 +197,13 @@ CONFIG_FORCE_MAX_ZONEORDER=13
 CONFIG_ARCH_MXC_HAS_NFC_V3=y
 CONFIG_ARCH_MX51=y
 CONFIG_ARCH_MX53=y
+CONFIG_ARCH_MX50=y
 CONFIG_MX5_OPTIONS=y
 CONFIG_MX5_MULTI_ARCH=y
 CONFIG_MACH_MX51_3DS=y
 CONFIG_MACH_MX51_BABBAGE=y
 CONFIG_MACH_MX53_EVK=y
+CONFIG_MACH_MX50_ARM2=y
 
 #
 # MX5x Options:
diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
index 5c07a3a..341b447 100644
--- a/arch/arm/mach-mx5/Kconfig
+++ b/arch/arm/mach-mx5/Kconfig
@@ -6,6 +6,9 @@ config ARCH_MX51
 config ARCH_MX53
 	bool
 
+config ARCH_MX50
+	bool
+
 config FORCE_MAX_ZONEORDER
     int "MAX_ORDER"
     default "13"
@@ -21,7 +24,8 @@ config MX5_MULTI_ARCH
 	bool
 	default y
 	select RUNTIME_PHYS_OFFSET
-	depends on ARCH_MX51 && ARCH_MX53
+	depends on ARCH_MX51
+	depends on ARCH_MX50 || ARCH_MX53
 
 config MACH_MX51_3DS
 	bool "Support MX51 3-Stack platform"
@@ -44,6 +48,13 @@ config MACH_MX53_EVK
 	  Include support for MX53 EVK platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX50_ARM2
+	bool "Support MX50 Armadillo2 platform"
+	select ARCH_MX50
+	help
+	  Include support for MX50 EVK platform. This includes specific
+	  configurations for the board and its peripherals.
+
 comment "MX5x Options:"
 
 config MXC_SDMA_API
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
index 446823e..5de332e 100644
--- a/arch/arm/mach-mx5/Makefile
+++ b/arch/arm/mach-mx5/Makefile
@@ -5,10 +5,14 @@
 # Object file lists.
 
 
-obj-y   := system.o iomux.o cpu.o mm.o clock.o devices.o serial.o dma.o lpmodes.o pm.o \
-sdram_autogating.o bus_freq.o usb_dr.o usb_h1.o usb_h2.o dummy_gpio.o wfi.o suspend.o
+obj-y   := system.o iomux.o cpu.o mm.o devices.o serial.o dma.o lpmodes.o pm.o \
+sdram_autogating.o bus_freq.o usb_dr.o usb_h1.o usb_h2.o dummy_gpio.o wfi.o suspend.o early_setup.o
 
-obj-$(CONFIG_MACH_MX51_3DS) += mx51_3stack.o mx51_3stack_gpio.o mx51_3stack_pmic_mc13892.o
-obj-$(CONFIG_MACH_MX51_BABBAGE) += mx51_babbage.o mx51_babbage_gpio.o mx51_babbage_pmic_mc13892.o early_setup.o
-obj-$(CONFIG_MACH_MX53_EVK) += mx53_evk.o mx53_evk_gpio.o mx53_evk_pmic_mc13892.o early_setup.o
+obj-$(CONFIG_ARCH_MX51) += clock.o
+obj-$(CONFIG_ARCH_MX53) += clock.o
+obj-$(CONFIG_ARCH_MX50) += clock_mx50.o
 
+obj-$(CONFIG_MACH_MX51_3DS) += mx51_3stack.o mx51_3stack_gpio.o mx51_3stack_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX51_BABBAGE) += mx51_babbage.o mx51_babbage_gpio.o mx51_babbage_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX53_EVK) += mx53_evk.o mx53_evk_gpio.o mx53_evk_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX50_ARM2) += mx50_arm2.o mx50_arm2_gpio.o mx50_arm2_pmic_mc13892.o
diff --git a/arch/arm/mach-mx5/Makefile.boot b/arch/arm/mach-mx5/Makefile.boot
index 741f604..434ef85 100644
--- a/arch/arm/mach-mx5/Makefile.boot
+++ b/arch/arm/mach-mx5/Makefile.boot
@@ -4,3 +4,6 @@ initrd_phys-$(CONFIG_ARCH_MX51)	:= 0x90800000
    zreladdr-$(CONFIG_ARCH_MX53)	:= 0x70008000
 params_phys-$(CONFIG_ARCH_MX53)	:= 0x70000100
 initrd_phys-$(CONFIG_ARCH_MX53)	:= 0x70800000
+   zreladdr-$(CONFIG_ARCH_MX50)	:= 0x70008000
+params_phys-$(CONFIG_ARCH_MX50)	:= 0x70000100
+initrd_phys-$(CONFIG_ARCH_MX50)	:= 0x70800000
diff --git a/arch/arm/mach-mx5/bus_freq.c b/arch/arm/mach-mx5/bus_freq.c
index 4ab60ec..ce5faad 100644
--- a/arch/arm/mach-mx5/bus_freq.c
+++ b/arch/arm/mach-mx5/bus_freq.c
@@ -80,11 +80,12 @@ static int busfreq_suspended;
 /* True if bus_frequency is scaled not using DVFS-PER */
 int bus_freq_scaling_is_active;
 
-extern int lp_high_freq;
-extern int lp_med_freq;
+int cpu_wp_nr;
+int lp_high_freq;
+int lp_med_freq;
+
 extern int dvfs_core_is_active;
 extern struct cpu_wp *(*get_cpu_wp)(int *wp);
-extern int cpu_wp_nr;
 
 struct dvfs_wp dvfs_core_setpoint[] = {
 						{33, 8, 33, 10, 10, 0x08},
diff --git a/arch/arm/mach-mx5/clock.c b/arch/arm/mach-mx5/clock.c
index 04f1208..b1b2d58 100644
--- a/arch/arm/mach-mx5/clock.c
+++ b/arch/arm/mach-mx5/clock.c
@@ -53,14 +53,14 @@ static struct clk vpu_clk[];
 static int cpu_curr_wp;
 static struct cpu_wp *cpu_wp_tbl;
 
-void __iomem *pll1_base;
-void __iomem *pll2_base;
-void __iomem *pll3_base;
-void __iomem *pll4_base;
-
-int cpu_wp_nr;
-int lp_high_freq;
-int lp_med_freq;
+static void __iomem *pll1_base;
+static void __iomem *pll2_base;
+static void __iomem *pll3_base;
+static void __iomem *pll4_base;
+
+extern int cpu_wp_nr;
+extern int lp_high_freq;
+extern int lp_med_freq;
 int max_axi_a_clk;
 int max_axi_b_clk;
 
@@ -81,8 +81,8 @@ extern int low_bus_freq_mode;
 
 static int cpu_clk_set_wp(int wp);
 extern void propagate_rate(struct clk *tclk);
-struct cpu_wp *(*get_cpu_wp)(int *wp);
-void (*set_num_cpu_wp)(int num);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
 
 static struct clk esdhc3_clk[];
 
@@ -1016,7 +1016,7 @@ static int _clk_max_enable(struct clk *clk)
 	if (cpu_is_mx51())
 		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
 	else
-		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX53;
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 
 	return 0;
@@ -1034,7 +1034,7 @@ static void _clk_max_disable(struct clk *clk)
 	if (cpu_is_mx51())
 		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
 	else
-		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX53;
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 }
 
@@ -1365,7 +1365,7 @@ static int _clk_sdma_enable(struct clk *clk)
 	if (cpu_is_mx51())
 		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
 	else
-		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX53;
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 
 	return 0;
@@ -1381,7 +1381,7 @@ static void _clk_sdma_disable(struct clk *clk)
 	if (cpu_is_mx51())
 		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
 	else
-		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX53;
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 }
 
@@ -5042,27 +5042,27 @@ static int cpu_clk_set_wp(int wp)
 		__raw_writel(reg, MXC_CCM_CCSR);
 
 		/* Stop the PLL */
-		reg = __raw_readl(MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
 		reg &= ~MXC_PLL_DP_CTL_UPEN;
-		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
 
 		/* PDF and MFI */
 		reg = p->pdf | p->mfi << MXC_PLL_DP_OP_MFI_OFFSET;
-		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_OP);
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_OP);
 
 		/* MFD */
-		__raw_writel(p->mfd, MXC_DPLL1_BASE + MXC_PLL_DP_MFD);
+		__raw_writel(p->mfd, pll1_base + MXC_PLL_DP_MFD);
 
 		/* MFI */
-		__raw_writel(p->mfn, MXC_DPLL1_BASE + MXC_PLL_DP_MFN);
+		__raw_writel(p->mfn, pll1_base + MXC_PLL_DP_MFN);
 
-		reg = __raw_readl(MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
 		reg |= MXC_PLL_DP_CTL_UPEN;
 		/* Set the UPEN bits */
-		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
 		/* Forcefully restart the PLL */
 		reg |= MXC_PLL_DP_CTL_RST;
-		__raw_writel(reg, MXC_DPLL1_BASE + MXC_PLL_DP_CTL);
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
 
 		/* Wait for the PLL to lock */
 		getnstimeofday(&nstimeofday);
@@ -5070,7 +5070,7 @@ static int cpu_clk_set_wp(int wp)
 			getnstimeofday(&curtime);
 			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
 				panic("pll1 relock failed\n");
-			stat = __raw_readl(MXC_DPLL1_BASE + MXC_PLL_DP_CTL) &
+			stat = __raw_readl(pll1_base + MXC_PLL_DP_CTL) &
 			    MXC_PLL_DP_CTL_LRF;
 		} while (!stat);
 
diff --git a/arch/arm/mach-mx5/clock_mx50.c b/arch/arm/mach-mx5/clock_mx50.c
new file mode 100644
index 0000000..6e59096
--- /dev/null
+++ b/arch/arm/mach-mx5/clock_mx50.c
@@ -0,0 +1,3135 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/hrtimer.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+
+#include "crm_regs.h"
+
+static struct clk pll1_main_clk;
+static struct clk pll1_sw_clk;
+static struct clk pll2_sw_clk;
+static struct clk pll3_sw_clk;
+static struct clk pll4_sw_clk;
+static struct clk lp_apm_clk;
+static struct clk weim_clk;
+static struct clk ddr_clk;
+static struct clk axi_a_clk;
+static struct clk axi_b_clk;
+static struct clk gpu2d_clk;
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+
+static void __iomem *pll1_base;
+static void __iomem *pll2_base;
+static void __iomem *pll3_base;
+static void __iomem *pll4_base;
+
+extern int cpu_wp_nr;
+extern int lp_high_freq;
+extern int lp_med_freq;
+
+#define SPIN_DELAY	1000000 /* in nanoseconds */
+
+extern int mxc_jtag_enabled;
+extern int uart_at_24;
+extern int cpufreq_trig_needed;
+extern int low_bus_freq_mode;
+
+static int cpu_clk_set_wp(int wp);
+extern void propagate_rate(struct clk *tclk);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+
+static struct clk esdhc3_clk[];
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 8) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div < 8) {
+		*pre = div;
+		*post = 1;
+	}
+}
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGR_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq++;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq++;
+
+	return 0;
+}
+
+static int _clk_enable_inrun(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGR_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGR_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq--;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq--;
+}
+
+static void _clk_disable_inwait(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGR_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static unsigned long _clk_round_rate_div(struct clk *clk,
+						unsigned long rate,
+						u32 max_div,
+						u32 *new_div)
+{
+	u32 div;
+
+	div = DIV_ROUND_UP(clk->parent->rate, rate);
+	if (div > max_div)
+		div = max_div;
+	else if (div == 0)
+		div++;
+	if (new_div != NULL)
+		*new_div = div;
+
+	return clk->parent->rate / div;
+}
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else
+		BUG();
+
+	return 0;
+}
+
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux8(struct clk *parent, struct clk *m0, struct clk *m1,
+			    struct clk *m2, struct clk *m3, struct clk *m4,
+			    struct clk *m5, struct clk *m6, struct clk *m7)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else if (parent == m5)
+		return 5;
+	else if (parent == m6)
+		return 6;
+	else if (parent == m7)
+		return 7;
+	else
+		BUG();
+
+	return 0;
+}
+
+static inline void __iomem *_get_pll_base(struct clk *pll)
+{
+	if (pll == &pll1_main_clk)
+		return pll1_base;
+	else if (pll == &pll2_sw_clk)
+		return pll2_base;
+	else if (pll == &pll3_sw_clk)
+		return pll3_base;
+	else if (pll == &pll4_sw_clk)
+		return pll4_base;
+	else
+		BUG();
+
+	return NULL;
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ckih2_clk = {
+	.name = "ckih2",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk osc_clk = {
+	.name = "osc",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk apll_clk = {
+	.name = "apll",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd0_clk = {
+	.name = "pfd0",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd1_clk = {
+	.name = "pfd1",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd2_clk = {
+	.name = "pfd2",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd3_clk = {
+	.name = "pfd3",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd4_clk = {
+	.name = "pfd4",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd5_clk = {
+	.name = "pfd5",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd6_clk = {
+	.name = "pfd6",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd7_clk = {
+	.name = "pfd7",
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_pll_recalc(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;
+	void __iomem *pllbase;
+	s64 temp;
+
+	pllbase = _get_pll_base(clk);
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	dbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;
+
+	if (pll_hfsm == 0) {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);
+	} else {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	pdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfd = dp_mfd & MXC_PLL_DP_MFD_MASK;
+	mfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;
+	/* Sign extend to 32-bits */
+	if (mfn >= 0x04000000) {
+		mfn |= 0xFC000000;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk = 2 * clk->parent->rate;
+	if (dbl != 0)
+		ref_clk *= 2;
+
+	ref_clk /= (pdf + 1);
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	clk->rate = temp;
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, reg1;
+	void __iomem *pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	long mfi, pdf, mfn, mfd = 999999;
+	s64 temp64;
+	unsigned long quad_parent_rate;
+	unsigned long pll_hfsm, dp_ctl;
+
+	pllbase = _get_pll_base(clk);
+
+	quad_parent_rate = 4*clk->parent->rate;
+	pdf = mfi = -1;
+	while (++pdf < 16 && mfi < 5)
+		mfi = rate * (pdf+1) / quad_parent_rate;
+	if (mfi > 15)
+		return -1;
+	pdf--;
+
+	temp64 = rate*(pdf+1) - quad_parent_rate*mfi;
+	do_div(temp64, quad_parent_rate/1000000);
+	mfn = (long)temp64;
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	/* use dpdck0_2 */
+	__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	if (pll_hfsm == 0) {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_MFN);
+	} else {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_HFS_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	/* If auto restart is disabled, restart the PLL and
+	  * wait for it to lock.
+	  */
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	if (reg & MXC_PLL_DP_CTL_UPEN) {
+		reg = __raw_readl(pllbase + MXC_PLL_DP_CONFIG);
+		if (!(reg & MXC_PLL_DP_CONFIG_AREN)) {
+			reg1 = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+			reg1 |= MXC_PLL_DP_CTL_RST;
+			__raw_writel(reg1, pllbase + MXC_PLL_DP_CTL);
+		}
+		/* Wait for lock */
+		getnstimeofday(&nstimeofday);
+		while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL)
+					& MXC_PLL_DP_CTL_LRF)) {
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+				panic("pll_set_rate: pll relock failed\n");
+		}
+	}
+	clk->rate = rate;
+	return 0;
+}
+
+static int _clk_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+
+	/* Wait for lock */
+	getnstimeofday(&nstimeofday);
+	while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL) & MXC_PLL_DP_CTL_LRF)) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll relock failed\n");
+	}
+	return 0;
+}
+
+static void _clk_pll_disable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+}
+
+static struct clk pll1_main_clk = {
+	.name = "pll1_main_clk",
+	.parent = &osc_clk,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll1_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll1_main_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+		/* Set the step_clk parent to be lp_apm, to save power. */
+		mux = _get_mux(&lp_apm_clk, &lp_apm_clk, NULL, &pll2_sw_clk,
+			       &pll3_sw_clk);
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+		    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+	} else {
+		if (parent == &lp_apm_clk) {
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+			reg = __raw_readl(MXC_CCM_CCSR);
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+		} else {
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+			__raw_writel(reg, MXC_CCM_CCSR);
+			reg = __raw_readl(MXC_CCM_CCSR);
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+
+		}
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static void _clk_pll1_sw_recalc(struct clk *clk)
+{
+	u32 reg, div;
+	div = 1;
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (clk->parent == &pll2_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL2_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL2_PODF_OFFSET) + 1;
+	} else if (clk->parent == &pll3_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL3_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL3_PODF_OFFSET) + 1;
+	}
+	clk->rate = clk->parent->rate / div;
+}
+
+/* pll1 switch clock */
+static struct clk pll1_sw_clk = {
+	.name = "pll1_sw_clk",
+	.parent = &pll1_main_clk,
+	.set_parent = _clk_pll1_sw_set_parent,
+	.recalc = _clk_pll1_sw_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll2_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll2_sw_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	} else {
+		reg = (reg & ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL);
+		reg |= MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+	return 0;
+}
+
+/* same as pll2_main_clk. These two clocks should always be the same */
+static struct clk pll2_sw_clk = {
+	.name = "pll2",
+	.parent = &osc_clk,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.set_rate = _clk_pll_set_rate,
+	.set_parent = _clk_pll2_sw_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll3_main_clk. These two clocks should always be the same */
+static struct clk pll3_sw_clk = {
+	.name = "pll3",
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll4_main_clk. These two clocks should always be the same */
+static struct clk pll4_sw_clk = {
+	.name = "pll4",
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &osc_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;
+	else if (parent == &apll_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) | MXC_CCM_CCSR_LP_APM_SEL;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static struct clk lp_apm_clk = {
+	.name = "lp_apm",
+	.parent = &osc_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_arm_recalc(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+	if (i >= cpu_wp_nr)
+		return -EINVAL;
+	cpu_clk_set_wp(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 wp;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_wp_nr)
+		wp = 0;
+
+	return cpu_wp_tbl[wp].cpu_rate;
+}
+
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &pll1_sw_clk,
+	.recalc = _clk_arm_recalc,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
+/* TODO: Need to sync with GPC to determine if DVFS is in place so that
+ * the DVFS_PODF divider can be applied in CDCR register.
+ */
+static void _clk_main_bus_recalc(struct clk *clk)
+{
+	u32 div = 0;
+
+	if (dvfs_per_divider_active() || low_bus_freq_mode)
+		div  = (__raw_readl(MXC_CCM_CDCR) & 0x3);
+	clk->rate = clk->parent->rate / (div + 1);
+}
+
+static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			&lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CBCDR) & ~MX50_CCM_CBCDR_PERIPH_CLK_SEL_MASK;
+	reg |= mux;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	return 0;
+}
+
+static struct clk main_bus_clk = {
+	.name = "main_bus_clk",
+	.parent = &pll2_sw_clk,
+	.set_parent = _clk_main_bus_set_parent,
+	.recalc = _clk_main_bus_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_axi_a_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_axi_a_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_A_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_A_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_axi_a_set_rate failed\n");
+	}
+	clk->rate = rate;
+
+	return 0;
+}
+
+static unsigned long _clk_axi_a_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
+
+static struct clk axi_a_clk = {
+	.name = "axi_a_clk",
+	.parent = &main_bus_clk,
+	.recalc = _clk_axi_a_recalc,
+	.set_rate = _clk_axi_a_set_rate,
+	.round_rate = _clk_axi_a_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_axi_b_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_axi_b_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_B_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_B_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_axi_b_set_rate failed\n");
+	}
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+static unsigned long _clk_axi_b_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
+
+static struct clk axi_b_clk = {
+	.name = "axi_b_clk",
+	.parent = &main_bus_clk,
+	.recalc = _clk_axi_b_recalc,
+	.set_rate = _clk_axi_b_set_rate,
+	.round_rate = _clk_axi_b_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_ahb_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AHB_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AHB_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+
+static int _clk_ahb_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AHB_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AHB_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AHB_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_ahb_set_rate failed\n");
+	}
+	clk->rate = rate;
+
+	return 0;
+}
+
+static unsigned long _clk_ahb_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &main_bus_clk,
+	.recalc = _clk_ahb_recalc,
+	.set_rate = _clk_ahb_set_rate,
+	.round_rate = _clk_ahb_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_max_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with MAX when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+
+static void _clk_max_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable_inwait(clk);
+
+	/* No Handshake with MAX when LPM is entered as its disabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk ahb_max_clk = {
+	.name = "max_clk",
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG14_OFFSET,
+	.enable = _clk_max_enable,
+	.disable = _clk_max_disable,
+};
+
+static int _clk_weim_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if (parent == &ahb_clk)
+		reg |= MX50_CCM_CBCDR_WEIM_CLK_SEL;
+	else if (parent == &main_bus_clk)
+		reg &= ~MX50_CCM_CBCDR_WEIM_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	return 0;
+}
+
+static void _clk_weim_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>
+	       MXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static int _clk_weim_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_EMI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_EMI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_EMI_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_emi_slow_set_rate failed\n");
+	}
+	clk->rate = rate;
+
+	return 0;
+}
+
+static unsigned long _clk_weim_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
+
+static struct clk weim_clk = {
+	.name = "weim_clk",
+	.parent = &main_bus_clk,
+	.set_parent = _clk_weim_set_parent,
+	.recalc = _clk_weim_recalc,
+	.set_rate = _clk_weim_set_rate,
+	.round_rate = _clk_weim_round_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahbmux1_clk = {
+	.name = "ahbmux1_clk",
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_IPG_PODF_MASK) >>
+	       MXC_CCM_CBCDR_IPG_PODF_OFFSET) + 1;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_ipg_per_recalc(struct clk *clk)
+{
+	u32 reg, prediv1, prediv2, podf;
+
+	if (clk->parent == &main_bus_clk || clk->parent == &lp_apm_clk) {
+		/* the main_bus_clk is the one before the DVFS engine */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		prediv1 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET) + 1;
+		prediv2 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>
+			MXC_CCM_CBCDR_PERCLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (prediv1 * prediv2 * podf);
+	} else if (clk->parent == &ipg_clk) {
+		clk->rate = ipg_clk.rate;
+	} else {
+		BUG();
+	}
+}
+
+static int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &main_bus_clk, &lp_apm_clk, &ipg_clk, NULL);
+	if (mux == 2) {
+		reg |= MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+		if (mux == 0)
+			reg &= ~MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+		else
+			reg |= MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk ipg_perclk = {
+	.name = "ipg_perclk",
+	.parent = &lp_apm_clk,
+	.recalc = _clk_ipg_per_recalc,
+	.set_parent = _clk_ipg_per_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ipmux1_clk = {
+	.name = "ipmux1",
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG6_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk ipmux2_clk = {
+	.name = "ipmux2",
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_ocram_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void _clk_ocram_disable(struct clk *clk)
+{
+}
+
+static struct clk ocram_clk = {
+	.name = "ocram_clk",
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG1_OFFSET,
+	.enable = _clk_ocram_enable,
+	.disable = _clk_ocram_disable,
+};
+
+
+static struct clk aips_tz1_clk = {
+	.name = "aips_tz1_clk",
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk aips_tz2_clk = {
+	.name = "aips_tz2_clk",
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGR0_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk gpc_dvfs_clk = {
+	.name = "gpc_dvfs_clk",
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_sdma_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with SDMA when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_sdma_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with SDMA as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG15_OFFSET,
+	 .enable = _clk_sdma_enable,
+	 .disable = _clk_sdma_disable,
+	 },
+	{
+	 .name = "sdma_ipg_clk",
+	 .parent = &ipg_clk,
+	 },
+};
+
+static struct clk spba_clk = {
+	.name = "spba_clk",
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static void _clk_uart_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_UART_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk uart_main_clk = {
+	.name = "uart_main_clk",
+	.parent = &pll2_sw_clk,
+	.recalc = _clk_uart_recalc,
+	.set_parent = _clk_uart_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk uart1_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART1_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+#ifdef UART1_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG3_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart2_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART2_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+#ifdef UART2_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart3_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart3_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART3_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart4_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart4_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART4_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart5_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart5_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART5_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk gpt_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &gpt_clk[1],
+	 },
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "gpt_32k_clk",
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm1_clk[] = {
+	{
+	 .name = "pwm",
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm1_clk[1],
+	 },
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG5_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "pwm_32k_clk",
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm2_clk[] = {
+	{
+	 .name = "pwm",
+	 .parent = &ipg_perclk,
+	 .id = 1,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm2_clk[1],
+	 },
+	{
+	 .name = "pwm_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG7_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "pwm_32k_clk",
+	 .id = 1,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static void _clk_cspi_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk cspi_main_clk = {
+	.name = "cspi_main_clk",
+	.parent = &pll3_sw_clk,
+	.recalc = _clk_cspi_recalc,
+	.set_parent = _clk_cspi_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG9_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG12_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG11_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi3_clk = {
+	 .name = "cspi_clk",
+	 .id = 2,
+	.parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGR4_CG13_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &aips_tz2_clk,
+};
+
+static int _clk_ssi_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ckih_clk, &lp_apm_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_lp_apm_clk = {
+	.name = "ssi_lp_apm_clk",
+	.parent = &ckih_clk,
+	.set_parent = _clk_ssi_lp_apm_set_parent,
+};
+
+static void _clk_ssi1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi1_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .secondary = &ssi1_clk[1],
+	 .recalc = _clk_ssi1_recalc,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi1_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_dep_clk",
+	 .id = 0,
+	 .parent = &aips_tz2_clk,
+	 },
+};
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi2_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .secondary = &ssi2_clk[1],
+	 .recalc = _clk_ssi2_recalc,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi2_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "ssi_dep_clk",
+	 .id = 1,
+	 .parent = &spba_clk,
+	 },
+};
+
+static void _clk_ssi_ext1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	clk->rate = clk->parent->rate;
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS1CDR);
+		prediv = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK) >>
+			  MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (prediv * podf);
+	}
+}
+
+static int _clk_ssi_ext1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || div > 512)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~(MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK |
+		 MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi1_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_ssi_ext1_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+
+	if (clk->parent->rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+}
+
+static struct clk ssi_ext1_clk = {
+	.name = "ssi_ext1_clk",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext1_set_parent,
+	.set_rate = _clk_ssi_ext1_set_rate,
+	.round_rate = _clk_ssi_ext1_round_rate,
+	.recalc = _clk_ssi_ext1_recalc,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGR3_CG14_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static void _clk_ssi_ext2_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	clk->rate = clk->parent->rate;
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS2CDR);
+		prediv = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK) >>
+			  MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK) >>
+			MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / (prediv * podf);
+	}
+}
+
+static int _clk_ssi_ext2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi2_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext2_clk = {
+	.name = "ssi_ext2_clk",
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext2_set_parent,
+	.recalc = _clk_ssi_ext2_recalc,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGR3_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax2_clk = {
+	 .name = "tmax2_clk",
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG1_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk usb_ahb_clk = {
+	 .name = "usb_ahb_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGR2_CG13_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk usb_phy_clk[] = {
+	{
+	.name = "usb_phy1_clk",
+	.id = 0,
+	.parent = &osc_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG5_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	.name = "usb_phy2_clk",
+	.id = 1,
+	.parent = &osc_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG6_OFFSET,
+	.disable = _clk_disable,
+	}
+};
+
+static struct clk esdhc_dep_clks = {
+	 .name = "sd_dep_clk",
+	 .parent = &spba_clk,
+};
+
+static void _clk_esdhc1_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_esdhc1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = reg & ~MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+
+static int _clk_esdhc1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	 __calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set sdhc1 clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR1) &
+		~(MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static struct clk esdhc1_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 0,
+	 .parent = &pll2_sw_clk,
+	 .set_parent = _clk_esdhc1_set_parent,
+	 .recalc = _clk_esdhc1_recalc,
+	 .set_rate = _clk_esdhc1_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG1_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc1_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc1_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+
+};
+
+static int _clk_esdhc2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &esdhc1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+	else if (parent == &esdhc3_clk[0])
+		reg |= MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk esdhc2_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 1,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc2_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG3_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc2_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc2_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG2_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	mux = _get_mux8(parent, &pll1_sw_clk, &pll2_sw_clk,
+			&pll3_sw_clk, &lp_apm_clk, &pfd0_clk,
+			&pfd1_clk, &pfd4_clk, &osc_clk);
+	reg = reg & ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static void _clk_esdhc3_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_esdhc3_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set sdhc1 clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR1) &
+		~(MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET;
+	 __raw_writel(reg, MXC_CCM_CSCDR1);
+
+	clk->rate = rate;
+	return 0;
+}
+
+
+static struct clk esdhc3_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 2,
+	 .parent = &pll2_sw_clk,
+	 .set_parent = _clk_esdhc3_set_parent,
+	 .recalc = _clk_esdhc3_recalc,
+	 .set_rate = _clk_esdhc3_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG5_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc3_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc3_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &ahb_max_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &esdhc1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+	else if (parent == &esdhc3_clk[0])
+		reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc4_clk[] = {
+	{
+	 .name = "esdhc_clk",
+	 .id = 3,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc4_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG7_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc4_clk[1],
+	 },
+	{
+	 .name = "esdhc_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc4_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGR3_CG6_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esdhc_sec_clk",
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CLK_DDR);
+	if (parent == &pfd0_clk)
+		reg |= MXC_CCM_CLK_DDR_DDR_PFD_SEL;
+	else if (parent == &pll1_sw_clk)
+		reg &= ~MXC_CCM_CLK_DDR_DDR_PFD_SEL;
+	else
+		return -EINVAL;
+	return 0;
+}
+
+static void _clk_ddr_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CLK_DDR);
+	div = (reg & MXC_CCM_CLK_DDR_DDR_DIV_PLL_MASK) >>
+		MXC_CCM_CLK_DDR_DDR_DIV_PLL_OFFSET;
+	if (div)
+		clk->rate = clk->parent->rate / div;
+	else
+		clk->rate = 0;
+}
+
+static struct clk ddr_clk = {
+	.name = "ddr_clk",
+	.parent = &pll1_sw_clk,
+	.set_parent = _clk_ddr_set_parent,
+	.recalc = _clk_ddr_recalc,
+	.flags = RATE_PROPAGATES,
+};
+
+static void _clk_pgc_recalc(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	div = (reg & MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK) >>
+	    MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET;
+	div = 1 >> div;
+	clk->rate = clk->parent->rate / div;
+}
+
+static struct clk pgc_clk = {
+	.name = "pgc_clk",
+	.parent = &ipg_clk,
+	.recalc = _clk_pgc_recalc,
+};
+
+/*usb OTG clock */
+
+static struct clk usb_clk = {
+	.name = "usb_clk",
+	.rate = 60000000,
+};
+
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ckil_clk,
+	.secondary = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG14_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &ipg_perclk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGR2_CG11_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static struct clk fec_clk[] = {
+	{
+	.name = "fec_clk",
+	.parent = &ipg_clk,
+	.secondary = &fec_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGR2_CG12_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .name = "fec_sec1_clk",
+	 .parent = &tmax2_clk,
+	 .secondary = &fec_clk[2],
+	},
+	{
+	 .name = "fec_sec2_clk",
+	 .parent = &aips_tz2_clk,
+	},
+};
+
+static int _clk_gpu2d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &weim_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu2d_clk = {
+	.name = "gpu2d_clk",
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu2d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG7_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk apbh_dma_clk = {
+	.name = "apbh_dma_clk",
+	.parent = &pll1_sw_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGR7_CG10_OFFSET,
+};
+
+static int _clk_display_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd2_clk, &pll1_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static void _clk_display_axi_recalc(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_DISPLAY_AXI);
+	div &= MXC_CCM_DISPLAY_AXI_DIV_MASK;
+	if (div == 0) { /* gated off */
+		clk->rate = clk->parent->rate;
+	} else {
+		clk->rate = clk->parent->rate / div;
+	}
+}
+
+static unsigned long _clk_display_axi_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 max_div = (2 << 6) - 1;
+	return _clk_round_rate_div(clk, rate, max_div, NULL);
+}
+
+static int _clk_display_axi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div, max_div;
+	u32 reg;
+
+	max_div = (2 << 6) - 1;
+	clk->rate = _clk_round_rate_div(clk, rate, max_div, &new_div);
+
+	reg = __raw_readl(MXC_CCM_DISPLAY_AXI);
+	reg &= ~MXC_CCM_DISPLAY_AXI_DIV_MASK;
+	reg |= new_div << MXC_CCM_DISPLAY_AXI_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_DISPLAY_AXI);
+
+#if 0
+	while (__raw_readl(MXC_CCM_CSR2) & MXC_CCM_CSR2_DISPLAY_AXI_BUSY)
+		;
+#endif
+
+	return 0;
+}
+
+static struct clk display_axi_clk = {
+	.name = "display_axi",
+	.parent = &osc_clk,
+	.set_parent = _clk_display_axi_set_parent,
+	.recalc = _clk_display_axi_recalc,
+	.set_rate = _clk_display_axi_set_rate,
+	.round_rate = _clk_display_axi_round_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_DISPLAY_AXI,
+	.enable_shift = MXC_CCM_DISPLAY_AXI_CLKGATE_OFFSET,
+};
+
+/* TODO: check Auto-Slow Mode */
+static struct clk pxp_axi_clk = {
+	.name = "pxp_axi",
+	.parent = &display_axi_clk,
+	.secondary = &apbh_dma_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG9_OFFSET,
+};
+
+static struct clk elcdif_axi_clk = {
+	.name = "elcdif_axi",
+	.parent = &display_axi_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG10_OFFSET,
+};
+
+static int _clk_elcdif_pix_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd6_clk, &pll1_sw_clk, &ckih_clk);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static void _clk_elcdif_pix_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_ELCDIFPIX);
+	prediv = ((reg & MXC_CCM_ELCDIFPIX_CLK_PRED_MASK) >>
+		  MXC_CCM_ELCDIFPIX_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_ELCDIFPIX_CLK_PODF_MASK) >>
+		MXC_CCM_ELCDIFPIX_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static unsigned long _clk_elcdif_pix_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 max_div = (2 << 12) - 1;
+	return _clk_round_rate_div(clk, rate, max_div, NULL);
+}
+
+static int _clk_elcdif_pix_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div, max_div;
+	u32 reg;
+
+	max_div = (2 << 12) - 1;
+	clk->rate = _clk_round_rate_div(clk, rate, max_div, &new_div);
+
+	reg = __raw_readl(MXC_CCM_ELCDIFPIX);
+	/* Pre-divider set to 1 - only use PODF for clk dividing */
+	reg &= ~MXC_CCM_ELCDIFPIX_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_ELCDIFPIX_CLK_PRED_OFFSET;
+	reg &= ~MXC_CCM_ELCDIFPIX_CLK_PODF_MASK;
+	reg |= new_div << MXC_CCM_ELCDIFPIX_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_ELCDIFPIX);
+
+	return 0;
+}
+
+static struct clk elcdif_pix_clk = {
+	.name = "elcdif_pix",
+	.parent = &osc_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG6_OFFSET,
+	.set_parent = _clk_elcdif_pix_set_parent,
+	.recalc = _clk_elcdif_pix_recalc,
+	.round_rate = _clk_elcdif_pix_round_rate,
+	.set_rate = _clk_elcdif_pix_set_rate,
+};
+
+static int _clk_epdc_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd3_clk, &pll1_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static void _clk_epdc_axi_recalc(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_EPDC_AXI);
+	div &= MXC_CCM_EPDC_AXI_DIV_MASK;
+	if (div == 0) { /* gated off */
+		clk->rate = clk->parent->rate;
+	} else {
+		clk->rate = clk->parent->rate / div;
+	}
+}
+
+static unsigned long _clk_epdc_axi_round_rate_div(struct clk *clk,
+						unsigned long rate,
+						u32 *new_div)
+{
+	u32 div, max_div;
+
+	max_div = (2 << 6) - 1;
+	div = DIV_ROUND_UP(clk->parent->rate, rate);
+	if (div > max_div)
+		div = max_div;
+	else if (div == 0)
+		div++;
+	if (new_div != NULL)
+		*new_div = div;
+	return clk->parent->rate / div;
+}
+
+static unsigned long _clk_epdc_axi_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	return _clk_epdc_axi_round_rate_div(clk, rate, NULL);
+}
+
+static int _clk_epdc_axi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div;
+	u32 reg;
+
+	clk->rate = _clk_epdc_axi_round_rate_div(clk, rate, &new_div);
+
+	reg = __raw_readl(MXC_CCM_EPDC_AXI);
+	reg &= ~MXC_CCM_EPDC_AXI_DIV_MASK;
+	reg |= new_div << MXC_CCM_EPDC_AXI_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_EPDC_AXI);
+
+	while (__raw_readl(MXC_CCM_CSR2) & MXC_CCM_CSR2_EPDC_AXI_BUSY)
+		;
+
+	return 0;
+}
+
+static int _clk_epdc_axi_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg |= MXC_CCM_CCGR6_CG8_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDC_AXI);
+	reg |= MXC_CCM_EPDC_AXI_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDC_AXI);
+
+	return 0;
+}
+
+static void _clk_epdc_axi_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg &= ~MXC_CCM_CCGR6_CG8_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDC_AXI);
+	reg &= ~MXC_CCM_EPDC_AXI_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDC_AXI);
+}
+
+/* TODO: check Auto-Slow Mode */
+static struct clk epdc_axi_clk = {
+	.name = "epdc_axi",
+	.parent = &apbh_dma_clk,
+	.set_parent = _clk_epdc_axi_set_parent,
+	.recalc = _clk_epdc_axi_recalc,
+	.set_rate = _clk_epdc_axi_set_rate,
+	.round_rate = _clk_epdc_axi_round_rate,
+	.enable = _clk_epdc_axi_enable,
+	.disable = _clk_epdc_axi_disable,
+};
+
+
+static int _clk_epdc_pix_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd5_clk, &pll1_sw_clk, &ckih_clk);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static void _clk_epdc_pix_recalc(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_EPDCPIX);
+	div &= MXC_CCM_EPDC_PIX_CLK_PODF_MASK;
+	if (div == 0) { /* gated off */
+		clk->rate = clk->parent->rate;
+	} else {
+		clk->rate = clk->parent->rate / div;
+	}
+}
+
+static unsigned long _clk_epdc_pix_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 max_div = (2 << 12) - 1;
+	return _clk_round_rate_div(clk, rate, max_div, NULL);
+}
+
+static int _clk_epdc_pix_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div, max_div;
+	u32 reg;
+
+	max_div = (2 << 12) - 1;
+	clk->rate = _clk_round_rate_div(clk, rate, max_div, &new_div);
+
+	reg = __raw_readl(MXC_CCM_EPDCPIX);
+	/* Pre-divider set to 1 - only use PODF for clk dividing */
+	reg &= ~MXC_CCM_EPDC_PIX_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_EPDC_PIX_CLK_PRED_OFFSET;
+	reg &= ~MXC_CCM_EPDC_PIX_CLK_PODF_MASK;
+	reg |= new_div << MXC_CCM_EPDC_PIX_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_EPDCPIX);
+
+	while (__raw_readl(MXC_CCM_CSR2) & MXC_CCM_CSR2_EPDC_PIX_BUSY)
+		;
+
+	return 0;
+}
+
+static int _clk_epdc_pix_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg |= MXC_CCM_CCGR6_CG5_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDCPIX);
+	reg |= MXC_CCM_EPDC_PIX_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDCPIX);
+
+	return 0;
+}
+
+static void _clk_epdc_pix_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg &= ~MXC_CCM_CCGR6_CG5_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDCPIX);
+	reg &= ~MXC_CCM_EPDC_PIX_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDCPIX);
+}
+
+/* TODO: check Auto-Slow Mode */
+static struct clk epdc_pix_clk = {
+	.name = "epdc_pix",
+	.parent = &osc_clk,
+	.set_parent = _clk_epdc_pix_set_parent,
+	.recalc = _clk_epdc_pix_recalc,
+	.set_rate = _clk_epdc_pix_set_rate,
+	.round_rate = _clk_epdc_pix_round_rate,
+	.enable = _clk_epdc_pix_enable,
+	.disable = _clk_epdc_pix_disable,
+};
+
+static void cko1_recalc(struct clk *clk)
+{
+	unsigned long rate;
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= MX50_CCM_CCOSR_CKO1_DIV_MASK;
+	reg = reg >> MX50_CCM_CCOSR_CKO1_DIV_OFFSET;
+	rate = clk->parent->rate;
+	clk->rate = rate / (reg + 1);
+}
+
+static int cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg |= MX50_CCM_CCOSR_CKO1_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static void cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MX50_CCM_CCOSR_CKO1_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+}
+
+static int cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	div = (clk->parent->rate/rate - 1) & 0x7;
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MX50_CCM_CCOSR_CKO1_DIV_MASK;
+	reg |= div << MX50_CCM_CCOSR_CKO1_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static unsigned long cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	div = div < 1 ? 1 : div;
+	div = div > 8 ? 8 : div;
+	return clk->parent->rate / div;
+}
+
+static int cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 sel, reg, fast;
+
+	if (parent == &cpu_clk) {
+		sel = 0;
+		fast = 1;
+	} else if (parent == &pll1_sw_clk) {
+		sel = 1;
+		fast = 1;
+	} else if (parent == &pll2_sw_clk) {
+		sel = 2;
+		fast = 1;
+	} else if (parent == &pll3_sw_clk) {
+		sel = 3;
+		fast = 1;
+	} else if (parent == &apll_clk) {
+		sel = 0;
+		fast = 0;
+	} else if (parent == &pfd0_clk) {
+		sel = 1;
+		fast = 0;
+	} else if (parent == &pfd1_clk) {
+		sel = 2;
+		fast = 0;
+	} else if (parent == &pfd2_clk) {
+		sel = 3;
+		fast = 0;
+	} else if (parent == &pfd3_clk) {
+		sel = 4;
+		fast = 0;
+	} else if (parent == &pfd4_clk) {
+		sel = 5;
+		fast = 0;
+	} else if (parent == &pfd5_clk) {
+		sel = 6;
+		fast = 0;
+	} else if (parent == &pfd6_clk) {
+		sel = 7;
+		fast = 0;
+	} else if (parent == &weim_clk) {
+		sel = 10;
+		fast = 0;
+	} else if (parent == &ahb_clk) {
+		sel = 11;
+		fast = 0;
+	} else if (parent == &ipg_clk) {
+		sel = 12;
+		fast = 0;
+	} else if (parent == &ipg_perclk) {
+		sel = 13;
+		fast = 0;
+	} else if (parent == &pfd7_clk) {
+		sel = 15;
+		fast = 0;
+	} else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MX50_CCM_CCOSR_CKO1_SEL_MASK;
+	reg |= sel << MX50_CCM_CCOSR_CKO1_SEL_OFFSET;
+	if (fast)
+		reg &= ~MX50_CCM_CCOSR_CKO1_SLOW_SEL;
+	else
+		reg |= MX50_CCM_CCOSR_CKO1_SLOW_SEL;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+static struct clk cko1_clk = {
+	.name = "cko1_clk",
+	.parent = &pll1_sw_clk,
+	.recalc = cko1_recalc,
+	.enable = cko1_enable,
+	.disable = cko1_disable,
+	.set_rate = cko1_set_rate,
+	.round_rate = cko1_round_rate,
+	.set_parent = cko1_set_parent,
+};
+
+static struct clk *mxc_clks[] = {
+	&osc_clk,
+	&ckih_clk,
+	&ckih2_clk,
+	&ckil_clk,
+	&pll1_main_clk,
+	&pll1_sw_clk,
+	&pll2_sw_clk,
+	&pll3_sw_clk,
+	&ipmux1_clk,
+	&ipmux2_clk,
+	&gpc_dvfs_clk,
+	&lp_apm_clk,
+	&cpu_clk,
+	&main_bus_clk,
+	&axi_a_clk,
+	&axi_b_clk,
+	&ahb_clk,
+	&ahb_max_clk,
+	&ipg_clk,
+	&ipg_perclk,
+	&ahbmux1_clk,
+	&aips_tz1_clk,
+	&aips_tz2_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&uart_main_clk,
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&spba_clk,
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&gpt_clk[0],
+	&gpt_clk[1],
+	&gpt_clk[2],
+	&pwm1_clk[0],
+	&pwm1_clk[1],
+	&pwm1_clk[2],
+	&pwm2_clk[0],
+	&pwm2_clk[1],
+	&pwm2_clk[2],
+	&cspi_main_clk,
+	&cspi1_clk[0],
+	&cspi1_clk[1],
+	&cspi2_clk[0],
+	&cspi2_clk[1],
+	&cspi3_clk,
+	&ssi_lp_apm_clk,
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi1_clk[2],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+	&ssi2_clk[2],
+	&ssi_ext1_clk,
+	&ssi_ext2_clk,
+	&tmax2_clk,
+	&usb_ahb_clk,
+	&usb_phy_clk[0],
+	&usb_clk,
+	&esdhc1_clk[0],
+	&esdhc1_clk[1],
+	&esdhc2_clk[0],
+	&esdhc2_clk[1],
+	&esdhc3_clk[0],
+	&esdhc3_clk[1],
+	&esdhc4_clk[0],
+	&esdhc4_clk[1],
+	&esdhc_dep_clks,
+	&weim_clk,
+	&ddr_clk,
+	&pgc_clk,
+	&rtc_clk,
+	&owire_clk,
+	&fec_clk[0],
+	&fec_clk[1],
+	&fec_clk[2],
+	&gpu2d_clk,
+	&cko1_clk,
+	&display_axi_clk,
+	&pxp_axi_clk,
+	&elcdif_axi_clk,
+	&epdc_axi_clk,
+	&epdc_pix_clk,
+	&elcdif_pix_clk,
+};
+
+static void clk_tree_init(void)
+{
+	u32 reg;
+
+	ipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);
+
+	/*
+	 *Initialise the IPG PER CLK dividers to 3. IPG_PER_CLK should be at
+	 * 8MHz, its derived from lp_apm.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED1_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED2_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;
+	reg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	/* set pll1_main_clk parent */
+	pll1_main_clk.parent = &osc_clk;
+
+	/* set pll2_sw_clk parent */
+	pll2_sw_clk.parent = &osc_clk;
+
+	/* set pll3_clk parent */
+	pll3_sw_clk.parent = &osc_clk;
+
+	/* set weim_clk parent */
+	weim_clk.parent = &main_bus_clk;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if ((reg & MX50_CCM_CBCDR_WEIM_CLK_SEL) != 0)
+		weim_clk.parent = &ahb_clk;
+
+	/* set ipg_perclk parent */
+	ipg_perclk.parent = &lp_apm_clk;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	if ((reg & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL) != 0) {
+		ipg_perclk.parent = &ipg_clk;
+	} else {
+		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
+			ipg_perclk.parent = &main_bus_clk;
+	}
+}
+
+int __init mx50_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1)
+{
+	__iomem void *base;
+	struct clk **clkp;
+	int i = 0, j = 0, reg;
+	int wp_cnt = 0;
+
+	pll1_base = ioremap(MX53_BASE_ADDR(PLL1_BASE_ADDR), SZ_4K);
+	pll2_base = ioremap(MX53_BASE_ADDR(PLL2_BASE_ADDR), SZ_4K);
+	pll3_base = ioremap(MX53_BASE_ADDR(PLL3_BASE_ADDR), SZ_4K);
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGR0_CG0_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG2_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG3_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG4_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG8_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG12_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG13_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGR0_CG0_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG3_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG8_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG12_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG13_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(0, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGR5_CG6_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG8_OFFSET |
+		     3 << MXC_CCM_CCGR5_CG9_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(3 << MXC_CCM_CCGR6_CG0_OFFSET |
+				3 << MXC_CCM_CCGR6_CG1_OFFSET |
+				3 << MXC_CCM_CCGR6_CG4_OFFSET |
+				3 << MXC_CCM_CCGR6_CG8_OFFSET |
+				3 << MXC_CCM_CCGR6_CG9_OFFSET |
+				3 << MXC_CCM_CCGR6_CG12_OFFSET |
+				3 << MXC_CCM_CCGR6_CG13_OFFSET , MXC_CCM_CCGR6);
+
+	__raw_writel(0, MXC_CCM_CCGR7);
+
+	ckil_clk.rate = ckil;
+	osc_clk.rate = osc;
+	ckih_clk.rate = ckih1;
+
+	usb_phy_clk[0].enable_reg = MXC_CCM_CCGR4;
+	usb_phy_clk[0].enable_shift = MXC_CCM_CCGR4_CG5_OFFSET;
+
+	clk_tree_init();
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	clk_register(&uart4_clk[0]);
+	clk_register(&uart4_clk[1]);
+	clk_register(&uart5_clk[0]);
+	clk_register(&uart5_clk[1]);
+	clk_register(&i2c_clk[2]);
+	clk_register(&usb_phy_clk[1]);
+	clk_register(&ocram_clk);
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CLK_DDR) &
+				MXC_CCM_CLK_DDR_DDR_PFD_SEL;
+	if (reg)
+		clk_set_parent(&ddr_clk, &pfd0_clk);
+	else
+		clk_set_parent(&ddr_clk, &pll1_sw_clk);
+
+	clk_set_parent(&esdhc1_clk[0], &pll2_sw_clk);
+	clk_set_parent(&esdhc1_clk[2], &tmax2_clk);
+	clk_set_parent(&esdhc2_clk[0], &esdhc1_clk[0]);
+	clk_set_parent(&esdhc3_clk[0], &pll2_sw_clk);
+
+	clk_register(&apbh_dma_clk);
+
+	clk_set_parent(&epdc_axi_clk, &pll1_sw_clk);
+	/* Set EPDC AXI to 200MHz */
+	/*
+	clk_set_rate(&epdc_axi_clk, 200000000);
+	*/
+	__raw_writel(0xC0000008, MXC_CCM_EPDC_AXI);
+	clk_set_parent(&epdc_pix_clk, &pll1_sw_clk);
+
+	reg = __raw_readl(MXC_CCM_ELCDIFPIX);
+	reg &= ~MXC_CCM_ELCDIFPIX_CLKGATE_MASK;
+	reg = 0x3 << MXC_CCM_ELCDIFPIX_CLKGATE_OFFSET;
+	__raw_writel(reg, MXC_CCM_ELCDIFPIX);
+	clk_set_parent(&elcdif_pix_clk, &pll1_sw_clk);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&osc_clk);
+	propagate_rate(&ckih_clk);
+	propagate_rate(&ckil_clk);
+	propagate_rate(&pll1_sw_clk);
+	propagate_rate(&pll2_sw_clk);
+	propagate_rate(&pll3_sw_clk);
+
+	clk_enable(&cpu_clk);
+
+	clk_enable(&main_bus_clk);
+
+	clk_enable(&apbh_dma_clk);
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+
+	clk_set_parent(&gpu2d_clk, &axi_a_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+
+	/* set DISPLAY_AXI to 200Mhz */
+	clk_set_parent(&display_axi_clk, &pll1_sw_clk);
+	clk_set_rate(&display_axi_clk, 200000000);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from PLL2 for camera */
+	clk_disable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext1_clk, &pll2_sw_clk);
+	clk_set_rate(&ssi_ext1_clk, 24000000);
+	clk_enable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+	clk_set_parent(&usb_phy_clk[1], &osc_clk);
+
+	/* set SDHC root clock as 200MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 200000000);
+	clk_set_rate(&esdhc3_clk[0], 200000000);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	if (pll1_main_clk.rate <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (pll1_main_clk.rate <= cpu_wp_tbl[1].cpu_rate &&
+				pll1_main_clk.rate > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = pll1_main_clk.rate;
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+
+	for (j = 0; j < cpu_wp_nr; j++) {
+		/* Change the CPU podf divider based on the boot up
+		 * pll1 rate.
+		 */
+		cpu_wp_tbl[j].cpu_podf = max(
+			(int)((pll1_main_clk.rate / cpu_wp_tbl[j].cpu_rate)
+			- 1), 0);
+		if (pll1_main_clk.rate/(cpu_wp_tbl[j].cpu_podf + 1) >
+				cpu_wp_tbl[j].cpu_rate) {
+			cpu_wp_tbl[j].cpu_podf++;
+			cpu_wp_tbl[j].cpu_rate =
+				 pll1_main_clk.rate/
+				 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+			cpu_wp_tbl[j].cpu_rate *= 1000;
+		}
+		if (pll1_main_clk.rate/(cpu_wp_tbl[j].cpu_podf + 1) <
+					cpu_wp_tbl[j].cpu_rate) {
+			cpu_wp_tbl[j].cpu_rate = pll1_main_clk.rate;
+		}
+		cpu_wp_tbl[j].pll_rate = pll1_main_clk.rate;
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	propagate_rate(&osc_clk);
+	propagate_rate(&pll1_sw_clk);
+	propagate_rate(&pll2_sw_clk);
+	propagate_rate(&pll3_sw_clk);
+
+	clk_set_parent(&uart_main_clk, &lp_apm_clk);
+	clk_set_parent(&gpu2d_clk, &axi_b_clk);
+
+	clk_set_parent(&weim_clk, &ahb_clk);
+	clk_set_rate(&weim_clk, clk_round_rate(&weim_clk, 130000000));
+
+	base = ioremap(MX53_BASE_ADDR(GPT1_BASE_ADDR), SZ_4K);
+	mxc_timer_init(&gpt_clk[0], base, MXC_INT_GPT);
+	return 0;
+}
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 reg;
+
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	p = &cpu_wp_tbl[wp];
+
+	/*
+	 * leave the PLL1 freq unchanged.
+	 */
+	reg = __raw_readl(MXC_CCM_CACRR);
+	reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+	reg |= cpu_wp_tbl[wp].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CACRR);
+	cpu_curr_wp = wp;
+	cpu_clk.rate = cpu_wp_tbl[wp].cpu_rate;
+
+#if defined(CONFIG_CPU_FREQ)
+	cpufreq_trig_needed = 1;
+#endif
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/cpu.c b/arch/arm/mach-mx5/cpu.c
index 275e54b..fe191e1 100644
--- a/arch/arm/mach-mx5/cpu.c
+++ b/arch/arm/mach-mx5/cpu.c
@@ -42,6 +42,9 @@
 void __iomem *arm_plat_base;
 void __iomem *gpc_base;
 
+struct cpu_wp *(*get_cpu_wp)(int *wp);
+void (*set_num_cpu_wp)(int num);
+
 static void __init mipi_hsc_disable(void)
 {
 	void __iomem *reg_hsc_mcd = ioremap(MIPI_HSC_BASE_ADDR, SZ_4K);
@@ -167,14 +170,16 @@ static int __init post_cpu_init(void)
 	__raw_writel(reg, base + 0x50);
 	iounmap(base);
 
-	/*Allow for automatic gating of the EMI internal clock.
-	 * If this is done, emi_intr CCGR bits should be set to 11.
-	 */
-	base = ioremap(MX53_BASE_ADDR(M4IF_BASE_ADDR), SZ_4K);
-	reg = __raw_readl(base + 0x8c);
-	reg &= ~0x1;
-	__raw_writel(reg, base + 0x8c);
-	iounmap(base);
+	if (cpu_is_mx51() || cpu_is_mx53()) {
+		/*Allow for automatic gating of the EMI internal clock.
+		 * If this is done, emi_intr CCGR bits should be set to 11.
+		 */
+		base = ioremap(MX53_BASE_ADDR(M4IF_BASE_ADDR), SZ_4K);
+		reg = __raw_readl(base + 0x8c);
+		reg &= ~0x1;
+		__raw_writel(reg, base + 0x8c);
+		iounmap(base);
+	}
 
 	return 0;
 }
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
index 09802b5..300f7a1 100644
--- a/arch/arm/mach-mx5/devices.c
+++ b/arch/arm/mach-mx5/devices.c
@@ -297,6 +297,52 @@ struct platform_device mxc_ipu_device = {
 	.resource = ipu_resources,
 };
 
+static struct resource epdc_resources[] = {
+	{
+	 .start = EPDC_BASE_ADDR,
+	 .end = EPDC_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	.start  = MXC_INT_EPDC,
+	.end = MXC_INT_EPDC,
+	.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device epdc_device = {
+	.name = "mxc_epdc_fb",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(epdc_resources),
+	.resource = epdc_resources,
+};
+
+static struct resource elcdif_resources[] = {
+	{
+	 .start = ELCDIF_BASE_ADDR,
+	 .end = ELCDIF_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	.start  = MXC_INT_ELCDIF,
+	.end = MXC_INT_ELCDIF,
+	.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device elcdif_device = {
+	.name = "mxc_elcdif_fb",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(elcdif_resources),
+	.resource = elcdif_resources,
+};
+
 struct platform_device mxc_fb_devices[] = {
 	{
 		.name = "mxc_sdc_fb",
@@ -712,6 +758,8 @@ int __init mxc_register_gpios(void)
 {
 	if (cpu_is_mx51())
 		return mxc_gpio_init(mxc_gpio_ports, 4);
+	else if (cpu_is_mx50())
+		return mxc_gpio_init(mxc_gpio_ports, 6);
 	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
 }
 
@@ -1173,6 +1221,30 @@ struct platform_device mxc_mlb_device = {
 	.resource = mlb_resources,
 };
 
+static struct resource pxp_resources[] = {
+	{
+	 .start = EPXP_BASE_ADDR,
+	 .end = EPXP_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_EPXP,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+struct platform_device mxc_pxp_device = {
+	.name = "mxc-pxp",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pxp_resources),
+	.resource = pxp_resources,
+};
+
+struct platform_device mxc_pxp_client_device = {
+	.name = "pxp-device",
+	.id = -1,
+};
+
 void __init mx5_init_irq(void)
 {
 	unsigned long tzic_addr;
@@ -1181,7 +1253,7 @@ void __init mx5_init_irq(void)
 		tzic_addr = MX51_TZIC_BASE_ADDR_T01;
 	else if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
 		tzic_addr = MX51_TZIC_BASE_ADDR;
-	else /* mx53 */
+	else /* mx53 and mx50 */
 		tzic_addr = MX53_TZIC_BASE_ADDR;
 
 	mxc_tzic_init_irq(tzic_addr);
@@ -1398,7 +1470,7 @@ exit:
 
 int __init mxc_init_devices(void)
 {
-	if (cpu_is_mx53()) {
+	if (cpu_is_mx53() || cpu_is_mx50()) {
 		sdma_resources[0].start -= MX53_OFFSET;
 		sdma_resources[0].end -= MX53_OFFSET;
 		mxc_w1_master_resources[0].start -= MX53_OFFSET;
@@ -1503,7 +1575,8 @@ int __init mxc_init_devices(void)
 	}
 
 
-	mxc_init_scc_iram();
+	if (cpu_is_mx51() || cpu_is_mx53())
+		mxc_init_scc_iram();
 	mxc_init_gpu2d();
 	return 0;
 }
diff --git a/arch/arm/mach-mx5/devices.h b/arch/arm/mach-mx5/devices.h
index 0b897f6..48ac078 100644
--- a/arch/arm/mach-mx5/devices.h
+++ b/arch/arm/mach-mx5/devices.h
@@ -66,3 +66,7 @@ extern struct platform_device mxc_usbh1_device;
 extern struct platform_device mxc_usbh2_device;
 extern struct platform_device mxc_mlb_device;
 extern struct platform_device mxc_nandv2_mtd_device;
+extern struct platform_device mxc_pxp_device;
+extern struct platform_device mxc_pxp_client_device;
+extern struct platform_device epdc_device;
+extern struct platform_device elcdif_device;
diff --git a/arch/arm/mach-mx5/dma.c b/arch/arm/mach-mx5/dma.c
index dfc72be..39b7776 100644
--- a/arch/arm/mach-mx5/dma.c
+++ b/arch/arm/mach-mx5/dma.c
@@ -20,6 +20,7 @@
 #include "serial.h"
 #include "sdma_script_code.h"
 #include "sdma_script_code_mx53.h"
+#include "sdma_script_code_mx50.h"
 
 #define MXC_MMC_BUFFER_ACCESS     0x20
 #define MXC_SDHC_MMC_WML          64
@@ -1351,11 +1352,77 @@ static void __init mx53_sdma_get_script_info(sdma_script_start_addrs *sdma_scrip
 	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_MX53;
 }
 
+static void __init mx50_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_MX50;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR_MX50;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = mcu_2_shp_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_MX50;
+
+	/* ATA use it's own DMA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = -1;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = -1;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = mcu_2_app_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_MX50;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = -1;
+
+	sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = -1;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = -1;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code_mx50;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_MX50;
+}
+
 void __init mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
 {
 	if (cpu_is_mx51())
 		mx51_sdma_get_script_info(sdma_script_addr);
-	else
+	else if (cpu_is_mx53())
 		mx53_sdma_get_script_info(sdma_script_addr);
+	else
+		mx50_sdma_get_script_info(sdma_script_addr);
 }
 
diff --git a/arch/arm/mach-mx5/iomux.c b/arch/arm/mach-mx5/iomux.c
index 2d01d8b..b67b1c5 100644
--- a/arch/arm/mach-mx5/iomux.c
+++ b/arch/arm/mach-mx5/iomux.c
@@ -37,6 +37,9 @@
 #define INPUT_CTL_START_MX53	0x730
 #define MUX_I_END_MX53		(PAD_I_START_MX53 - 4)
 
+#define PAD_I_START_MX50	0x2CC
+#define INPUT_CTL_START_MX50	0x6C4
+
 /*!
  * IOMUX register (base) addressesf
  */
@@ -52,8 +55,10 @@ static inline void *_get_sw_pad(void)
 {
 	if (cpu_is_mx51())
 		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX51;
-	else
+	else if (cpu_is_mx53())
 		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX53;
+	else
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX50;
 }
 
 static inline void * _get_mux_reg(iomux_pin_name_t pin)
@@ -102,6 +107,9 @@ static inline void * _get_pad_reg(iomux_pin_name_t pin)
 
 static inline void * _get_mux_end(void)
 {
+	if (cpu_is_mx50())
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x2C8;
+
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
 		return(IO_ADDRESS(IOMUXC_BASE_ADDR) + (0x3F8 - 4));
 	else
@@ -249,8 +257,10 @@ void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
 		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX51_TO1;
 	} else if (cpu_is_mx51()) {
 		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX51;
-	} else
+	} else if (cpu_is_mx53()) {
 		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX53;
+	} else
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX50;
 
 	BUG_ON(input >= MUX_INPUT_NUM_MUX);
 	__raw_writel(config, reg);
diff --git a/arch/arm/mach-mx5/mm.c b/arch/arm/mach-mx5/mm.c
index 810cb1b..226083e 100644
--- a/arch/arm/mach-mx5/mm.c
+++ b/arch/arm/mach-mx5/mm.c
@@ -56,7 +56,7 @@ void __init mx5_map_io(void)
 	int i;
 
 	/* Fixup the mappings for MX53 */
-	if (cpu_is_mx53()) {
+	if (cpu_is_mx53() || cpu_is_mx50()) {
 		for (i = 0; i < ARRAY_SIZE(mx5_io_desc); i++)
 			mx5_io_desc[i].pfn -= __phys_to_pfn(0x20000000);
 	}
diff --git a/arch/arm/mach-mx5/mx50_arm2.c b/arch/arm/mach-mx5/mx50_arm2.c
new file mode 100644
index 0000000..28d8d89
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_arm2.c
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <linux/fec.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/flash.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+#include "iomux.h"
+#include "mx50_pins.h"
+#include "devices.h"
+#include "usb.h"
+
+extern void __init mx50_arm2_io_init(void);
+extern int __init mx50_arm2_init_mc13892(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+static struct cpu_wp *mx50_arm2_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+static void mx50_arm2_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static struct fec_platform_data fec_data = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+};
+
+extern void mx50_arm2_gpio_spi_chipselect_active(int cspi_mode, int status,
+						    int chipselect);
+extern void mx50_arm2_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+						      int chipselect);
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx50_arm2_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx50_arm2_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_spi_master mxcspi3_data = {
+	.maxchipselect = 4,
+	.spi_version = 7,
+	.chipselect_active = mx50_arm2_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx50_arm2_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = OCOTP_CTRL_BASE_ADDR + 0x80,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "backlight-i2c",
+	 .addr = 0x2c,
+	 },
+	{
+	 .type = "eeprom",
+	 .addr = 0x50,
+	 },
+};
+
+static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
+	{
+	 I2C_BOARD_INFO("max17135", 0x48),
+	 },
+};
+
+static struct mtd_partition mxc_dataflash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 0x000100000,},
+	{
+	 .name = "kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,},
+};
+
+static struct flash_platform_data mxc_spi_flash_data[] = {
+	{
+	 .name = "mxc_dataflash",
+	 .parts = mxc_dataflash_partitions,
+	 .nr_parts = ARRAY_SIZE(mxc_dataflash_partitions),
+	 .type = "at45db321d",}
+};
+
+
+static struct spi_board_info mxc_dataflash_device[] __initdata = {
+	{
+	 .modalias = "mxc_dataflash",
+	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
+	 .bus_num = 3,
+	 .chip_select = 1,
+	 .platform_data = &mxc_spi_flash_data[0],},
+};
+
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (to_platform_device(dev)->id == 0)
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX50_PIN_ECSPI2_SS0));
+	else
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX50_PIN_SD2_WP));
+
+	return rc;
+}
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+	if (to_platform_device(dev)->id == 0)
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX50_PIN_EIM_CRE));
+	else
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX50_PIN_SD2_CD));
+
+	return ret;
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+/* TO DO */
+	return 0;
+}
+
+static int headphone_det_status(void)
+{
+	return (gpio_get_value(IOMUX_TO_GPIO(MX50_PIN_ECSPI1_SS0)) != 0);
+}
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_irq = IOMUX_TO_IRQ(MX50_PIN_ECSPI1_SS0),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.sysclk = 12288000,
+};
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
+
+static void wvga_reset(void)
+{
+	/* ELCDIF D0 */
+	mxc_free_iomux(MX50_PIN_DISP_D0, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D0, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D1 */
+	mxc_free_iomux(MX50_PIN_DISP_D1, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D1, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D2 */
+	mxc_free_iomux(MX50_PIN_DISP_D2, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D2, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D3 */
+	mxc_free_iomux(MX50_PIN_DISP_D3, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D3, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D4 */
+	mxc_free_iomux(MX50_PIN_DISP_D4, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D4, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D5 */
+	mxc_free_iomux(MX50_PIN_DISP_D5, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D5, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D6 */
+	mxc_free_iomux(MX50_PIN_DISP_D6, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D6, IOMUX_CONFIG_ALT0);
+	/* ELCDIF D7 */
+	mxc_free_iomux(MX50_PIN_DISP_D7, IOMUX_CONFIG_ALT2);
+	mxc_request_iomux(MX50_PIN_DISP_D7, IOMUX_CONFIG_ALT0);
+	return;
+}
+
+static struct mxc_lcd_platform_data lcd_wvga_data = {
+	.reset = wvga_reset,
+};
+
+static struct platform_device lcd_wvga_device = {
+	.name = "lcd_claa",
+	.dev = {
+		.platform_data = &lcd_wvga_data,
+		},
+};
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 800x480 @ 55 Hz , pixel clk @ 25MHz */
+	 "CLAA-WVGA", 55, 800, 480, 40000, 40, 40, 5, 5, 20, 10,
+	 FB_SYNC_CLK_LAT_FALL,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = V4L2_PIX_FMT_RGB565,
+	 .mode_str = "CLAA-WVGA",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+};
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_set_cpu_type(MXC_CPU_MX50);
+
+	get_cpu_wp = mx50_arm2_get_cpu_wp;
+	set_num_cpu_wp = mx50_arm2_set_num_cpu_wp;
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	/* SD card detect irqs */
+	mxcsdhc2_device.resource[2].start = IOMUX_TO_IRQ(MX50_PIN_SD2_CD);
+	mxcsdhc2_device.resource[2].end = IOMUX_TO_IRQ(MX50_PIN_SD2_CD);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ(MX50_PIN_EIM_CRE);
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ(MX50_PIN_EIM_CRE);
+
+	mxc_cpu_common_init();
+	mxc_register_gpios();
+	mx50_arm2_io_init();
+
+	mxc_register_device(&mxc_dma_device, NULL);
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxcspi3_device, &mxcspi3_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[2], &mxci2c_data);
+
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mxc_pxp_device, NULL);
+	mxc_register_device(&mxc_pxp_client_device, NULL);
+	/*
+	mxc_register_device(&mx53_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	*/
+
+/*	mxc_register_device(&mxc_keypad_device, &keypad_plat_data); */
+
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc2_device, &mmc2_data);
+	mxc_register_device(&mxc_ssi1_device, NULL);
+	mxc_register_device(&mxc_ssi2_device, NULL);
+	mxc_register_device(&mxc_fec_device, &fec_data);
+	spi_register_board_info(mxc_dataflash_device,
+				ARRAY_SIZE(mxc_dataflash_device));
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+	i2c_register_board_info(2, mxc_i2c2_board_info,
+				ARRAY_SIZE(mxc_i2c2_board_info));
+
+	mxc_register_device(&epdc_device, NULL);
+	mxc_register_device(&lcd_wvga_device, &lcd_wvga_data);
+	mxc_register_device(&elcdif_device, &fb_data[0]);
+
+	mx50_arm2_init_mc13892();
+/*
+	pm_power_off = mxc_power_off;
+	*/
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+	mx5_usb_dr_init();
+	mx5_usbh1_init();
+}
+
+static void __init mx50_arm2_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	mx50_clocks_init(32768, 24000000, 22579200);
+
+	uart_clk = clk_get(NULL, "uart_clk.0");
+	early_console_setup(MX53_BASE_ADDR(UART1_BASE_ADDR), uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx50_arm2_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX50_ARM2 data structure.
+ */
+MACHINE_START(MX50_ARM2, "Freescale MX50 ARM2 Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.fixup = fixup_mxc_board,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx50_arm2_gpio.c b/arch/arm/mach-mx5/mx50_arm2_gpio.c
new file mode 100644
index 0000000..89e0315
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_arm2_gpio.c
@@ -0,0 +1,591 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "iomux.h"
+#include "mx50_pins.h"
+
+/*!
+ * @file mach-mx5/mx50_arm2_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+static struct mxc_iomux_pin_cfg __initdata mxc_iomux_pins[] = {
+	{		/* SD1 WP */
+	 MX50_PIN_ECSPI2_SS0, IOMUX_CONFIG_GPIO,
+	 },
+	{		/* SD1 CD */
+	 MX50_PIN_EIM_CRE, IOMUX_CONFIG_GPIO,
+	 },
+	{		/* SD1 CMD */
+	 MX50_PIN_SD1_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD1 CLK */
+	 MX50_PIN_SD1_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD1 D0 */
+	 MX50_PIN_SD1_D0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD1 D1 */
+	 MX50_PIN_SD1_D1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD1 D2 */
+	 MX50_PIN_SD1_D2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD1 D3 */
+	 MX50_PIN_SD1_D3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 CD */
+	 MX50_PIN_SD2_CD, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 WP */
+	 MX50_PIN_SD2_WP, IOMUX_CONFIG_GPIO,
+	 },
+	{		/* SD2 CMD */
+	 MX50_PIN_SD2_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 CLK */
+	 MX50_PIN_SD2_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D0 */
+	 MX50_PIN_SD2_D0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D1 */
+	 MX50_PIN_SD2_D1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D2 */
+	 MX50_PIN_SD2_D2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D3 */
+	 MX50_PIN_SD2_D3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D4 */
+	 MX50_PIN_SD2_D4, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D5 */
+	 MX50_PIN_SD2_D5, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D6 */
+	 MX50_PIN_SD2_D6, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{		/* SD2 D7 */
+	 MX50_PIN_SD2_D7, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX50_PIN_SSI_TXD, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX50_PIN_SSI_RXD, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX50_PIN_SSI_TXC, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX50_PIN_SSI_TXFS, IOMUX_CONFIG_ALT0,
+	 },
+	/* LINE1_DETECT (headphone detect) */
+	{
+	 MX50_PIN_ECSPI1_SS0, IOMUX_CONFIG_GPIO, PAD_CTL_100K_PU,
+	 },
+	{
+	 MX50_PIN_ECSPI2_MISO, IOMUX_CONFIG_GPIO, PAD_CTL_100K_PU,
+	 },
+	 /* UART pad setting */
+	{
+	 MX50_PIN_UART1_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 },
+	{
+	 MX50_PIN_UART1_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	},
+	{
+	 MX50_PIN_UART1_CTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 },
+	{
+	 MX50_PIN_UART1_RTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	  MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	},
+	{
+	 MX50_PIN_UART2_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 },
+	{
+	 MX50_PIN_UART2_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	},
+	{
+	 MX50_PIN_UART2_CTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 },
+	{
+	 MX50_PIN_UART2_RTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_ODE_OPENDRAIN_NONE),
+	 MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	},
+	{ /* I2C1 SDA */
+	 MX50_PIN_I2C1_SDA, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE),
+	 },
+	{ /* I2C1 SCL */
+	 MX50_PIN_I2C1_SCL, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE),
+	 },
+	{ /* I2C2 SDA */
+	 MX50_PIN_I2C2_SDA, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE),
+	 },
+	{ /* I2C2 SCL */
+	 MX50_PIN_I2C2_SCL, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE),
+	 },
+	{ /* I2C3 SDA */
+	 MX50_PIN_I2C3_SDA, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE),
+	 },
+	{ /* I2C3 SCL */
+	 MX50_PIN_I2C3_SCL, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE),
+	 },
+	 /* EPDC pins */
+	{ /* EPDC D0 */
+	 MX50_PIN_EPDC_D0, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D1 */
+	 MX50_PIN_EPDC_D1, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D2 */
+	 MX50_PIN_EPDC_D2, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D3 */
+	 MX50_PIN_EPDC_D3, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D4 */
+	 MX50_PIN_EPDC_D4, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D5 */
+	 MX50_PIN_EPDC_D5, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D6 */
+	 MX50_PIN_EPDC_D6, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC D7 */
+	 MX50_PIN_EPDC_D7, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC GDCLK */
+	 MX50_PIN_EPDC_GDCLK, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC GDSP */
+	 MX50_PIN_EPDC_GDSP, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC GDOE */
+	 MX50_PIN_EPDC_GDOE, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC GDRL */
+	 MX50_PIN_EPDC_GDRL, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDCLK */
+	 MX50_PIN_EPDC_SDCLK, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDOE */
+	 MX50_PIN_EPDC_SDOE, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDLE */
+	 MX50_PIN_EPDC_SDLE, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDSHR */
+	 MX50_PIN_EPDC_SDSHR, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC BDR0 */
+	 MX50_PIN_EPDC_BDR0, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDCE0 */
+	 MX50_PIN_EPDC_SDCE0, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDCE1 */
+	 MX50_PIN_EPDC_SDCE1, IOMUX_CONFIG_ALT0,
+	 },
+	{ /* EPDC SDCE2 */
+	 MX50_PIN_EPDC_SDCE2, IOMUX_CONFIG_ALT0,
+	 },
+	 /* EPD PMIC pins */
+	{ /* EPDC PWRSTAT - GPIO3[28] for PWR_GOOD status */
+	 MX50_PIN_EPDC_PWRSTAT, IOMUX_CONFIG_ALT1,
+	 },
+	{ /* EPDC VCOM0 - GPIO4[21] for VCOM control */
+	 MX50_PIN_EPDC_VCOM0, IOMUX_CONFIG_ALT1,
+	 },
+	{ /* ELCDIF D8 */
+	 MX50_PIN_DISP_D8, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_8_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D9 */
+	 MX50_PIN_DISP_D9, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_9_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D10 */
+	 MX50_PIN_DISP_D10, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_10_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D11 */
+	 MX50_PIN_DISP_D11, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_11_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D12 */
+	 MX50_PIN_DISP_D12, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_12_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D13 */
+	 MX50_PIN_DISP_D13, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_13_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D14 */
+	 MX50_PIN_DISP_D14, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_14_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF D15 */
+	 MX50_PIN_DISP_D15, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_RXDATA_15_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* ELCDIF VSYNC */
+	 MX50_PIN_DISP_RS, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_VSYNC_I_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	 },
+	{ /* ELCDIF contrast */
+	 MX50_PIN_DISP_BUSY, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 },
+	{ /* ELCDIF HSYNC */
+	 MX50_PIN_DISP_CS, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 MUX_IN_ELCDIF_LCDIF_BUSY_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	 },
+	{ /* ELCDIF DRDY */
+	 MX50_PIN_DISP_RD, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 },
+	{ /* ELCDIF PIXCLK */
+	 MX50_PIN_DISP_WR, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	 PAD_CTL_DRV_HIGH),
+	 },
+	{ /* UART4 TXD - GPIO6[16] for EPD PMIC WAKEUP */
+	 MX50_PIN_UART4_TXD, IOMUX_CONFIG_ALT1,
+	 },
+	{ /* UART4 RXD - GPIO6[17] for EPD PMIC intr */
+	 MX50_PIN_UART4_RXD, IOMUX_CONFIG_ALT1,
+	 },
+	/* USB_H1_PWR */
+	{
+	 MX50_PIN_EPITO, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH,
+	},
+	/* FIXME: USB_H1_OC, need to comment below line if
+	 * one needs to debug owire.
+	 */
+	{
+	 MX50_PIN_OWIRE, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH,
+	},
+	/* USB_OTG_PWR */
+	{
+	 MX50_PIN_PWM2, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH,
+	},
+	/*
+	 * Set USB_OTG_OC, the pad value is the default value
+	 * according to IC suggestion.
+	 */
+	{
+	 MX50_PIN_PWM1, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH,
+	 MUX_IN_USBOH1_IPP_IND_OTG_OC_SELECT_INPUT, INPUT_CTL_PATH1,
+	},
+	{ /* FEC_MDIO */
+	 MX50_PIN_SSI_RXC, IOMUX_CONFIG_ALT6,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_22K_PU | PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH),
+	 MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	 },
+	{ /* FEC_TX_CLK */
+	 MX50_PIN_DISP_D0, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE),
+	 },
+	{ /* FEC_RX_ER */
+	 MX50_PIN_DISP_D1, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE),
+	 MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* FEC_CRS_DV */
+	 MX50_PIN_DISP_D2, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE),
+	 MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* FEC_RXD1 */
+	 MX50_PIN_DISP_D3, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE),
+	 MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* FEC_RXD0 */
+	 MX50_PIN_DISP_D4, IOMUX_CONFIG_ALT2,
+	(PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE),
+	 MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{ /* FEC_TX_EN */
+	 MX50_PIN_DISP_D5, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{ /* FEC_TXD1 */
+	 MX50_PIN_DISP_D6, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{ /* FEC_TXD0 */
+	 MX50_PIN_DISP_D7, IOMUX_CONFIG_ALT2,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{ /* FEC_MDC */
+	 MX50_PIN_SSI_RXFS, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{ /* CSPI SS0 */
+	 MX50_PIN_CSPI_SS0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL | PAD_CTL_DRV_HIGH),
+	 },
+	{ /* CSPI SS1 */
+	 MX50_PIN_ECSPI1_MOSI, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_22K_PU | PAD_CTL_DRV_HIGH),
+	 },
+	{
+	 MX50_PIN_CSPI_MOSI, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX50_PIN_CSPI_MISO, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX50_PIN_CSPI_SCLK, IOMUX_CONFIG_ALT0,
+	 },
+};
+
+void __init mx50_arm2_io_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_iomux_pins); i++) {
+		mxc_request_iomux(mxc_iomux_pins[i].pin,
+				  mxc_iomux_pins[i].mux_mode);
+		if (mxc_iomux_pins[i].pad_cfg)
+			mxc_iomux_set_pad(mxc_iomux_pins[i].pin,
+					  mxc_iomux_pins[i].pad_cfg);
+		if (mxc_iomux_pins[i].in_select)
+			mxc_iomux_set_input(mxc_iomux_pins[i].in_select,
+					    mxc_iomux_pins[i].in_mode);
+	}
+
+	/* SD1 WP */
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_ECSPI2_SS0), "ecspi2_ss0");
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_ECSPI2_SS0));
+
+	/* SD1 CD */
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_EIM_CRE), "eim_cre");
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_EIM_CRE));
+
+	/* SD2 WP */
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_SD2_WP), "sd2_wp");
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_SD2_WP));
+
+	/* SD2 CD */
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_SD2_CD), "sd2_cd");
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_SD2_CD));
+
+	/* LINE1_DETECT (headphone detect) */
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_ECSPI1_SS0));
+
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_ECSPI2_MISO));
+
+	/* EPDC PMIC */
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_UART4_TXD), "uart4_txd");
+	gpio_direction_output(IOMUX_TO_GPIO(MX50_PIN_UART4_TXD), 0);
+
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_EPDC_VCOM0), "epdc_vcom");
+	gpio_direction_output(IOMUX_TO_GPIO(MX50_PIN_EPDC_VCOM0), 0);
+
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_UART4_RXD), "uart4_rxd");
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_UART4_RXD));
+
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_EPDC_PWRSTAT), "epdc_pwrstat");
+	gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_EPDC_PWRSTAT));
+
+	/* ELCDIF backlight */
+	gpio_request(IOMUX_TO_GPIO(MX50_PIN_DISP_BUSY), "gp2_18");
+	gpio_direction_output(IOMUX_TO_GPIO(MX50_PIN_DISP_BUSY), 1);
+}
+
+/* workaround for cspi chipselect pin may not keep correct level when idle */
+void mx50_arm2_gpio_spi_chipselect_active(int cspi_mode, int status,
+					     int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		break;
+	case 2:
+		break;
+	case 3:
+		switch (chipselect) {
+		case 0x1:
+			/* enable ss0 */
+			mxc_request_iomux(MX50_PIN_CSPI_SS0, IOMUX_CONFIG_ALT0);
+			/*disable other ss */
+			mxc_request_iomux(MX50_PIN_ECSPI1_MOSI, IOMUX_CONFIG_GPIO);
+			/* pull up/down deassert it */
+			gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_ECSPI1_MOSI));
+			break;
+		case 0x2:
+			/* enable ss1 */
+			mxc_request_iomux(MX50_PIN_ECSPI1_MOSI, IOMUX_CONFIG_ALT2);
+			/*disable other ss */
+			mxc_request_iomux(MX50_PIN_CSPI_SS0, IOMUX_CONFIG_GPIO);
+			/* pull up/down deassert it */
+			gpio_direction_input(IOMUX_TO_GPIO(MX50_PIN_CSPI_SS0));
+			break;
+		default:
+			break;
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+void mx50_arm2_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+					       int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		break;
+	case 2:
+		break;
+	case 3:
+		switch (chipselect) {
+		case 0x1:
+			mxc_free_iomux(MX50_PIN_ECSPI1_MOSI, IOMUX_CONFIG_GPIO);
+			break;
+		case 0x2:
+			mxc_free_iomux(MX50_PIN_CSPI_SS0, IOMUX_CONFIG_GPIO);
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+}
diff --git a/arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c b/arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c
new file mode 100644
index 0000000..d852fb0
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+#include "mx50_pins.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+/* Coin cell charger enable */
+#define COINCHEN_LSH	23
+#define COINCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* regulator standby mask */
+#define GEN1_STBY_MASK		(1 << 1)
+#define IOHI_STBY_MASK		(1 << 4)
+#define DIG_STBY_MASK		(1 << 10)
+#define GEN2_STBY_MASK		(1 << 13)
+#define PLL_STBY_MASK		(1 << 16)
+#define USB2_STBY_MASK		(1 << 19)
+
+#define GEN3_STBY_MASK		(1 << 1)
+#define CAM_STBY_MASK		(1 << 7)
+#define VIDEO_STBY_MASK		(1 << 13)
+#define AUDIO_STBY_MASK		(1 << 16)
+#define SD_STBY_MASK		(1 << 19)
+
+/* 0x92412 */
+#define REG_MODE_0_ALL_MASK	(GEN1_STBY_MASK |\
+				DIG_STBY_MASK | GEN2_STBY_MASK |\
+				PLL_STBY_MASK)
+/* 0x92082 */
+#define REG_MODE_1_ALL_MASK	(CAM_STBY_MASK | VIDEO_STBY_MASK |\
+				AUDIO_STBY_MASK | SD_STBY_MASK)
+
+/* switch mode setting */
+#define	SW1MODE_LSB	0
+#define	SW2MODE_LSB	10
+#define	SW3MODE_LSB	0
+#define	SW4MODE_LSB	8
+
+#define	SWMODE_MASK	0xF
+#define SWMODE_AUTO	0x8
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+static struct regulator_consumer_supply vgen1_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDA",
+		.dev_name = "1-000a",
+	},
+	{
+		/* sgtl5000 */
+		.supply = "VDDIO",
+		.dev_name = "1-000a",
+	},
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(1200),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	},
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2775),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.apply_uV = 1,
+	},
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(3000),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vgen1_consumers),
+	.consumer_supplies = vgen1_consumers,
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value, register_mask;
+	printk("Initializing regulators for mx50 arm2.\n");
+	sw2_init.constraints.state_mem.uV = 1200000;
+	sw1_init.constraints.state_mem.uV = 1000000;
+
+	/* enable standby controll for all regulators */
+	pmic_read_reg(REG_MODE_0, &value, 0xffffff);
+	value |= REG_MODE_0_ALL_MASK;
+	pmic_write_reg(REG_MODE_0, value, 0xffffff);
+
+	pmic_read_reg(REG_MODE_1, &value, 0xffffff);
+	value |= REG_MODE_1_ALL_MASK;
+	pmic_write_reg(REG_MODE_1, value, 0xffffff);
+
+	/* enable switch audo mode */
+	pmic_read_reg(REG_IDENTIFICATION, &value, 0xffffff);
+	/* only for mc13892 2.0A */
+	if ((value & 0x0000FFFF) == 0x45d0) {
+		pmic_read_reg(REG_SW_4, &value, 0xffffff);
+		register_mask = (SWMODE_MASK << SW1MODE_LSB) |
+		       (SWMODE_MASK << SW2MODE_LSB);
+		value &= ~register_mask;
+		value |= (SWMODE_AUTO << SW1MODE_LSB) |
+			(SWMODE_AUTO << SW2MODE_LSB);
+		pmic_write_reg(REG_SW_4, value, 0xffffff);
+
+		pmic_read_reg(REG_SW_5, &value, 0xffffff);
+		register_mask = (SWMODE_MASK << SW3MODE_LSB) |
+			(SWMODE_MASK << SW4MODE_LSB);
+		value &= ~register_mask;
+		value |= (SWMODE_AUTO << SW3MODE_LSB) |
+			(SWMODE_AUTO << SW4MODE_LSB);
+		pmic_write_reg(REG_SW_5, value, 0xffffff);
+	}
+
+	/* Enable coin cell charger */
+	value = BITFVAL(COINCHEN, 1) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(COINCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	regulator_has_full_constraints();
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct spi_board_info __initdata mc13892_spi_device = {
+	.modalias = "pmic_spi",
+	.irq = IOMUX_TO_IRQ(MX50_PIN_ECSPI2_MISO),
+	.max_speed_hz = 6000000,	/* max spi SCK clock speed in HZ */
+	.bus_num = 3,
+	.chip_select = 0,
+	.platform_data = &mc13892_plat,
+};
+
+
+int __init mx50_arm2_init_mc13892(void)
+{
+	return spi_register_board_info(&mc13892_spi_device, 1);
+}
diff --git a/arch/arm/mach-mx5/mx50_pins.h b/arch/arm/mach-mx5/mx50_pins.h
new file mode 100644
index 0000000..75d6544
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_pins.h
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_MXC_MX50_PINS_H__
+#define __ASM_ARCH_MXC_MX50_PINS_H__
+#include "iomux.h"
+
+/*!
+ * @file mach-mx5/mx50_pins.h
+ *
+ * @brief MX50 I/O Pin List
+ *
+ * @ingroup GPIO_MX50
+ */
+
+#ifndef __ASSEMBLY__
+
+#define PAD_I_START_MX50		0x2CC
+
+#define _MXC_BUILD_PIN_MX50(gp, gi, ga, mi, pi) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+	((mi) << MUX_I) | \
+	((pi - PAD_I_START_MX50) << PAD_I) | \
+	((ga) << GPIO_I))
+
+#define _MXC_BUILD_GPIO_PIN_MX50(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN_MX50(gp, gi, ga, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN_MX50(mi, pi) \
+    _MXC_BUILD_PIN_MX50(NON_GPIO_PORT, 0, 0, mi, pi)
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX50 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+enum iomux_pins {
+	MX50_PIN_KEY_COL0 = _MXC_BUILD_GPIO_PIN_MX50(3, 0, 1, 0x20, 0x2CC),
+	MX50_PIN_KEY_ROW0 = _MXC_BUILD_GPIO_PIN_MX50(3, 1, 1, 0x24, 0x2D0),
+	MX50_PIN_KEY_COL1 = _MXC_BUILD_GPIO_PIN_MX50(3, 2, 1, 0x28, 0x2D4),
+	MX50_PIN_KEY_ROW1 = _MXC_BUILD_GPIO_PIN_MX50(3, 3, 1, 0x2C, 0x2D8),
+	MX50_PIN_KEY_COL2 = _MXC_BUILD_GPIO_PIN_MX50(3, 4, 1, 0x30, 0x2DC),
+	MX50_PIN_KEY_ROW2 = _MXC_BUILD_GPIO_PIN_MX50(3, 5, 1, 0x34, 0x2E0),
+	MX50_PIN_KEY_COL3 = _MXC_BUILD_GPIO_PIN_MX50(3, 6, 1, 0x38, 0x2E4),
+	MX50_PIN_KEY_ROW3 = _MXC_BUILD_GPIO_PIN_MX50(3, 7, 1, 0x3C, 0x2E8),
+	MX50_PIN_I2C1_SCL = _MXC_BUILD_GPIO_PIN_MX50(5, 18, 1, 0x40, 0x2EC),
+	MX50_PIN_I2C1_SDA = _MXC_BUILD_GPIO_PIN_MX50(5, 19, 1, 0x44, 0x2F0),
+	MX50_PIN_I2C2_SCL = _MXC_BUILD_GPIO_PIN_MX50(5, 20, 1, 0x48, 0x2F4),
+	MX50_PIN_I2C2_SDA = _MXC_BUILD_GPIO_PIN_MX50(5, 21, 1, 0x4C, 0x2F8),
+	MX50_PIN_I2C3_SCL = _MXC_BUILD_GPIO_PIN_MX50(5, 22, 1, 0x50, 0x2FC),
+	MX50_PIN_I2C3_SDA = _MXC_BUILD_GPIO_PIN_MX50(5, 23, 1, 0x54, 0x300),
+	MX50_PIN_PWM1 = _MXC_BUILD_GPIO_PIN_MX50(5, 24, 1, 0x58, 0x304),
+	MX50_PIN_PWM2 = _MXC_BUILD_GPIO_PIN_MX50(5, 25, 1, 0x5C, 0x308),
+	MX50_PIN_OWIRE = _MXC_BUILD_GPIO_PIN_MX50(5, 26, 1, 0x60, 0x30C),
+	MX50_PIN_EPITO = _MXC_BUILD_GPIO_PIN_MX50(5, 27, 1, 0x64, 0x310),
+	MX50_PIN_WDOG = _MXC_BUILD_GPIO_PIN_MX50(5, 28, 1, 0x68, 0x314),
+	MX50_PIN_SSI_TXFS = _MXC_BUILD_GPIO_PIN_MX50(5, 0, 1, 0x6C, 0x318),
+	MX50_PIN_SSI_TXC = _MXC_BUILD_GPIO_PIN_MX50(5, 1, 1, 0x70, 0x31C),
+	MX50_PIN_SSI_TXD = _MXC_BUILD_GPIO_PIN_MX50(5, 2, 1, 0x74, 0x320),
+	MX50_PIN_SSI_RXD = _MXC_BUILD_GPIO_PIN_MX50(5, 3, 1, 0x78, 0x324),
+	MX50_PIN_SSI_RXFS = _MXC_BUILD_GPIO_PIN_MX50(5, 4, 1, 0x7C, 0x328),
+	MX50_PIN_SSI_RXC = _MXC_BUILD_GPIO_PIN_MX50(5, 5, 1, 0x80, 0x32C),
+	MX50_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN_MX50(5, 6, 1, 0x84, 0x330),
+	MX50_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN_MX50(5, 7, 1, 0x88, 0x334),
+	MX50_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN_MX50(5, 8, 1, 0x8C, 0x338),
+	MX50_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN_MX50(5, 9, 1, 0x90, 0x33C),
+	MX50_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN_MX50(5, 10, 1, 0x94, 0x340),
+	MX50_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN_MX50(5, 11, 1, 0x98, 0x344),
+	MX50_PIN_UART2_CTS = _MXC_BUILD_GPIO_PIN_MX50(5, 12, 1, 0x9C, 0x348),
+	MX50_PIN_UART2_RTS = _MXC_BUILD_GPIO_PIN_MX50(5, 13, 1, 0xA0, 0x34C),
+	MX50_PIN_UART3_TXD = _MXC_BUILD_GPIO_PIN_MX50(5, 14, 1, 0xA4, 0x350),
+	MX50_PIN_UART3_RXD = _MXC_BUILD_GPIO_PIN_MX50(5, 15, 1, 0xA8, 0x354),
+	MX50_PIN_UART4_TXD = _MXC_BUILD_GPIO_PIN_MX50(5, 16, 1, 0xAC, 0x358),
+	MX50_PIN_UART4_RXD = _MXC_BUILD_GPIO_PIN_MX50(5, 17, 1, 0xB0, 0x35C),
+	MX50_PIN_CSPI_SCLK = _MXC_BUILD_GPIO_PIN_MX50(3, 8, 1, 0xB4, 0x360),
+	MX50_PIN_CSPI_MOSI = _MXC_BUILD_GPIO_PIN_MX50(3, 9, 1, 0xB8, 0x364),
+	MX50_PIN_CSPI_MISO = _MXC_BUILD_GPIO_PIN_MX50(3, 10, 1, 0xBC, 0x368),
+	MX50_PIN_CSPI_SS0 = _MXC_BUILD_GPIO_PIN_MX50(3, 11, 1, 0xC0, 0x36C),
+	MX50_PIN_ECSPI1_SCLK = _MXC_BUILD_GPIO_PIN_MX50(3, 12, 1, 0xC4, 0x370),
+	MX50_PIN_ECSPI1_MOSI = _MXC_BUILD_GPIO_PIN_MX50(3, 13, 1, 0xC8, 0x374),
+	MX50_PIN_ECSPI1_MISO = _MXC_BUILD_GPIO_PIN_MX50(3, 14, 1, 0xCC, 0x378),
+	MX50_PIN_ECSPI1_SS0 = _MXC_BUILD_GPIO_PIN_MX50(3, 15, 1, 0xD0, 0x37C),
+	MX50_PIN_ECSPI2_SCLK = _MXC_BUILD_GPIO_PIN_MX50(3, 16, 1, 0xD4, 0x380),
+	MX50_PIN_ECSPI2_MOSI = _MXC_BUILD_GPIO_PIN_MX50(3, 17, 1, 0xD8, 0x384),
+	MX50_PIN_ECSPI2_MISO = _MXC_BUILD_GPIO_PIN_MX50(3, 18, 1, 0xDC, 0x388),
+	MX50_PIN_ECSPI2_SS0 = _MXC_BUILD_GPIO_PIN_MX50(3, 19, 1, 0xE0, 0x38C),
+	MX50_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN_MX50(4, 0, 1, 0xE4, 0x390),
+	MX50_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN_MX50(4, 1, 1, 0xE8, 0x394),
+	MX50_PIN_SD1_D0 = _MXC_BUILD_GPIO_PIN_MX50(4, 2, 1, 0xEC, 0x398),
+	MX50_PIN_SD1_D1 = _MXC_BUILD_GPIO_PIN_MX50(4, 3, 1, 0xF0, 0x39C),
+	MX50_PIN_SD1_D2 = _MXC_BUILD_GPIO_PIN_MX50(4, 4, 1, 0xF4, 0x3A0),
+	MX50_PIN_SD1_D3 = _MXC_BUILD_GPIO_PIN_MX50(4, 5, 1, 0xF8, 0x3A4),
+	MX50_PIN_SD2_CLK = _MXC_BUILD_GPIO_PIN_MX50(4, 6, 1, 0xFC, 0x3A8),
+	MX50_PIN_SD2_CMD = _MXC_BUILD_GPIO_PIN_MX50(4, 7, 1, 0x100, 0x3AC),
+	MX50_PIN_SD2_D0 = _MXC_BUILD_GPIO_PIN_MX50(4, 8, 1, 0x104, 0x3B0),
+	MX50_PIN_SD2_D1 = _MXC_BUILD_GPIO_PIN_MX50(4, 9, 1, 0x108, 0x3B4),
+	MX50_PIN_SD2_D2 = _MXC_BUILD_GPIO_PIN_MX50(4, 10, 1, 0x10C, 0x3B8),
+	MX50_PIN_SD2_D3 = _MXC_BUILD_GPIO_PIN_MX50(4, 11, 1, 0x110, 0x3BC),
+	MX50_PIN_SD2_D4 = _MXC_BUILD_GPIO_PIN_MX50(4, 12, 1, 0x114, 0x3C0),
+	MX50_PIN_SD2_D5 = _MXC_BUILD_GPIO_PIN_MX50(4, 13, 1, 0x118, 0x3C4),
+	MX50_PIN_SD2_D6 = _MXC_BUILD_GPIO_PIN_MX50(4, 14, 1, 0x11C, 0x3C8),
+	MX50_PIN_SD2_D7 = _MXC_BUILD_GPIO_PIN_MX50(4, 15, 1, 0x120, 0x3CC),
+	MX50_PIN_SD2_WP = _MXC_BUILD_GPIO_PIN_MX50(4, 16, 1, 0x124, 0x3D0),
+	MX50_PIN_SD2_CD = _MXC_BUILD_GPIO_PIN_MX50(4, 17, 1, 0x128, 0x3D4),
+
+	MX50_PIN_PMIC_ON_REQ = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3D8),
+	MX50_PIN_PMIC_STBY_REQ = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3DC),
+	MX50_PIN_PMIC_PORT_B = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3E0),
+	MX50_PIN_PMIC_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3E4),
+	MX50_PIN_PMIC_RESET_IN_B = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3E8),
+	MX50_PIN_PMIC_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3EC),
+	MX50_PIN_PMIC_TEST_MODE = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3F0),
+	MX50_PIN_PMIC_JTAG_TMS = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3F4),
+	MX50_PIN_PMIC_JTAG_MOD = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3F8),
+	MX50_PIN_PMIC_JTAG_TRSTB = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x3FC),
+	MX50_PIN_PMIC_JTAG_TDI = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x400),
+	MX50_PIN_PMIC_JTAG_TCK = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x404),
+	MX50_PIN_PMIC_JTAG_TDO = _MXC_BUILD_NON_GPIO_PIN_MX50(NON_MUX_I, 0x408),
+
+	MX50_PIN_DISP_D0 = _MXC_BUILD_GPIO_PIN_MX50(1, 0, 1, 0x12C, 0x40C),
+	MX50_PIN_DISP_D1 = _MXC_BUILD_GPIO_PIN_MX50(1, 1, 1, 0x130, 0x410),
+	MX50_PIN_DISP_D2 = _MXC_BUILD_GPIO_PIN_MX50(1, 2, 1, 0x134, 0x414),
+	MX50_PIN_DISP_D3 = _MXC_BUILD_GPIO_PIN_MX50(1, 3, 1, 0x138, 0x418),
+	MX50_PIN_DISP_D4 = _MXC_BUILD_GPIO_PIN_MX50(1, 4, 1, 0x13C, 0x41C),
+	MX50_PIN_DISP_D5 = _MXC_BUILD_GPIO_PIN_MX50(1, 5, 1, 0x140, 0x420),
+	MX50_PIN_DISP_D6 = _MXC_BUILD_GPIO_PIN_MX50(1, 6, 1, 0x144, 0x424),
+	MX50_PIN_DISP_D7 = _MXC_BUILD_GPIO_PIN_MX50(1, 7, 1, 0x148, 0x428),
+	MX50_PIN_DISP_WR = _MXC_BUILD_GPIO_PIN_MX50(1, 16, 1, 0x14C, 0x42C),
+	MX50_PIN_DISP_RD = _MXC_BUILD_GPIO_PIN_MX50(1, 19, 1, 0x150, 0x430),
+	MX50_PIN_DISP_RS = _MXC_BUILD_GPIO_PIN_MX50(1, 17, 1, 0x154, 0x434),
+	MX50_PIN_DISP_CS = _MXC_BUILD_GPIO_PIN_MX50(1, 21, 1, 0x158, 0x438),
+	MX50_PIN_DISP_BUSY = _MXC_BUILD_GPIO_PIN_MX50(1, 18, 1, 0x15C, 0x43C),
+	MX50_PIN_DISP_RESET = _MXC_BUILD_GPIO_PIN_MX50(1, 20, 1, 0x160, 0x440),
+	MX50_PIN_SD3_CMD = _MXC_BUILD_GPIO_PIN_MX50(4, 18, 1, 0x164, 0x444),
+	MX50_PIN_SD3_CLK = _MXC_BUILD_GPIO_PIN_MX50(4, 19, 1, 0x168, 0x448),
+	MX50_PIN_SD3_D0 = _MXC_BUILD_GPIO_PIN_MX50(4, 20, 1, 0x16C, 0x44C),
+	MX50_PIN_SD3_D1 = _MXC_BUILD_GPIO_PIN_MX50(4, 21, 1, 0x170, 0x450),
+	MX50_PIN_SD3_D2 = _MXC_BUILD_GPIO_PIN_MX50(4, 22, 1, 0x174, 0x454),
+	MX50_PIN_SD3_D3 = _MXC_BUILD_GPIO_PIN_MX50(4, 23, 1, 0x178, 0x458),
+	MX50_PIN_SD3_D4 = _MXC_BUILD_GPIO_PIN_MX50(4, 24, 1, 0x17C, 0x45C),
+	MX50_PIN_SD3_D5 = _MXC_BUILD_GPIO_PIN_MX50(4, 25, 1, 0x180, 0x460),
+	MX50_PIN_SD3_D6 = _MXC_BUILD_GPIO_PIN_MX50(4, 26, 1, 0x184, 0x464),
+	MX50_PIN_SD3_D7 = _MXC_BUILD_GPIO_PIN_MX50(4, 27, 1, 0x188, 0x468),
+	MX50_PIN_SD3_WP = _MXC_BUILD_GPIO_PIN_MX50(4, 28, 1, 0x18C, 0x46C),
+	MX50_PIN_DISP_D8 = _MXC_BUILD_GPIO_PIN_MX50(1, 8, 1, 0x190, 0x470),
+	MX50_PIN_DISP_D9 = _MXC_BUILD_GPIO_PIN_MX50(1, 9, 1, 0x194, 0x474),
+	MX50_PIN_DISP_D10 = _MXC_BUILD_GPIO_PIN_MX50(1, 10, 1, 0x198, 0x478),
+	MX50_PIN_DISP_D11 = _MXC_BUILD_GPIO_PIN_MX50(1, 11, 1, 0x19C, 0x47C),
+	MX50_PIN_DISP_D12 = _MXC_BUILD_GPIO_PIN_MX50(1, 12, 1, 0x1A0, 0x480),
+	MX50_PIN_DISP_D13 = _MXC_BUILD_GPIO_PIN_MX50(1, 13, 1, 0x1A4, 0x484),
+	MX50_PIN_DISP_D14 = _MXC_BUILD_GPIO_PIN_MX50(1, 14, 1, 0x1A8, 0x488),
+	MX50_PIN_DISP_D15 = _MXC_BUILD_GPIO_PIN_MX50(1, 15, 1, 0x1AC, 0x48C),
+
+	MX50_PIN_EPDC_D0 = _MXC_BUILD_GPIO_PIN_MX50(2, 0, 1, 0x1B0, 0x54C),
+	MX50_PIN_EPDC_D1 = _MXC_BUILD_GPIO_PIN_MX50(2, 1, 1, 0x1B4, 0x550),
+	MX50_PIN_EPDC_D2 = _MXC_BUILD_GPIO_PIN_MX50(2, 2, 1, 0x1B8, 0x554),
+	MX50_PIN_EPDC_D3 = _MXC_BUILD_GPIO_PIN_MX50(2, 3, 1, 0x1BC, 0x558),
+	MX50_PIN_EPDC_D4 = _MXC_BUILD_GPIO_PIN_MX50(2, 4, 1, 0x1C0, 0x55C),
+	MX50_PIN_EPDC_D5 = _MXC_BUILD_GPIO_PIN_MX50(2, 5, 1, 0x1C4, 0x560),
+	MX50_PIN_EPDC_D6 = _MXC_BUILD_GPIO_PIN_MX50(2, 6, 1, 0x1C8, 0x564),
+	MX50_PIN_EPDC_D7 = _MXC_BUILD_GPIO_PIN_MX50(2, 7, 1, 0x1CC, 0x568),
+	MX50_PIN_EPDC_D8 = _MXC_BUILD_GPIO_PIN_MX50(2, 8, 1, 0x1D0, 0x56C),
+	MX50_PIN_EPDC_D9 = _MXC_BUILD_GPIO_PIN_MX50(2, 9, 1, 0x1D4, 0x570),
+	MX50_PIN_EPDC_D10 = _MXC_BUILD_GPIO_PIN_MX50(2, 10, 1, 0x1D8, 0x574),
+	MX50_PIN_EPDC_D11 = _MXC_BUILD_GPIO_PIN_MX50(2, 11, 1, 0x1DC, 0x578),
+	MX50_PIN_EPDC_D12 = _MXC_BUILD_GPIO_PIN_MX50(2, 12, 1, 0x1E0, 0x57C),
+	MX50_PIN_EPDC_D13 = _MXC_BUILD_GPIO_PIN_MX50(2, 13, 1, 0x1E4, 0x580),
+	MX50_PIN_EPDC_D14 = _MXC_BUILD_GPIO_PIN_MX50(2, 14, 1, 0x1E8, 0x584),
+	MX50_PIN_EPDC_D15 = _MXC_BUILD_GPIO_PIN_MX50(2, 15, 1, 0x1EC, 0x588),
+	MX50_PIN_EPDC_GDCLK = _MXC_BUILD_GPIO_PIN_MX50(2, 16, 1, 0x1F0, 0x58C),
+	MX50_PIN_EPDC_GDSP = _MXC_BUILD_GPIO_PIN_MX50(2, 17, 1, 0x1F4, 0x590),
+	MX50_PIN_EPDC_GDOE = _MXC_BUILD_GPIO_PIN_MX50(2, 18, 1, 0x1F8, 0x594),
+	MX50_PIN_EPDC_GDRL = _MXC_BUILD_GPIO_PIN_MX50(2, 19, 1, 0x1FC, 0x598),
+	MX50_PIN_EPDC_SDCLK = _MXC_BUILD_GPIO_PIN_MX50(2, 20, 1, 0x200, 0x59C),
+	MX50_PIN_EPDC_SDOEZ = _MXC_BUILD_GPIO_PIN_MX50(2, 21, 1, 0x204, 0x5A0),
+	MX50_PIN_EPDC_SDOED = _MXC_BUILD_GPIO_PIN_MX50(2, 22, 1, 0x208, 0x5A4),
+	MX50_PIN_EPDC_SDOE = _MXC_BUILD_GPIO_PIN_MX50(2, 23, 1, 0x20C, 0x5A8),
+	MX50_PIN_EPDC_SDLE = _MXC_BUILD_GPIO_PIN_MX50(2, 24, 1, 0x210, 0x5AC),
+	MX50_PIN_EPDC_SDCLKN = _MXC_BUILD_GPIO_PIN_MX50(2, 25, 1, 0x214, 0x5B0),
+	MX50_PIN_EPDC_SDSHR = _MXC_BUILD_GPIO_PIN_MX50(2, 26, 1, 0x218, 0x5B4),
+	MX50_PIN_EPDC_PWRCOM = _MXC_BUILD_GPIO_PIN_MX50(2, 27, 1, 0x21C, 0x5B8),
+	MX50_PIN_EPDC_PWRSTAT = _MXC_BUILD_GPIO_PIN_MX50(2, 28, 1, 0x220, 0x5BC),
+	MX50_PIN_EPDC_PWRCTRL0 = _MXC_BUILD_GPIO_PIN_MX50(2, 29, 1, 0x224, 0x5C0),
+	MX50_PIN_EPDC_PWRCTRL1 = _MXC_BUILD_GPIO_PIN_MX50(2, 30, 1, 0x228, 0x5C4),
+	MX50_PIN_EPDC_PWRCTRL2 = _MXC_BUILD_GPIO_PIN_MX50(2, 31, 1, 0x22C, 0x5C8),
+	MX50_PIN_EPDC_PWRCTRL3 = _MXC_BUILD_GPIO_PIN_MX50(3, 20, 1, 0x230, 0x5CC),
+	MX50_PIN_EPDC_VCOM0 = _MXC_BUILD_GPIO_PIN_MX50(3, 21, 1, 0x234, 0x5D0),
+	MX50_PIN_EPDC_VCOM1 = _MXC_BUILD_GPIO_PIN_MX50(3, 22, 1, 0x238, 0x5D4),
+	MX50_PIN_EPDC_BDR0 = _MXC_BUILD_GPIO_PIN_MX50(3, 23, 1, 0x23C, 0x5D8),
+	MX50_PIN_EPDC_BDR1 = _MXC_BUILD_GPIO_PIN_MX50(3, 24, 1, 0x240, 0x5DC),
+	MX50_PIN_EPDC_SDCE0 = _MXC_BUILD_GPIO_PIN_MX50(3, 25, 1, 0x244, 0x5E0),
+	MX50_PIN_EPDC_SDCE1 = _MXC_BUILD_GPIO_PIN_MX50(3, 26, 1, 0x248, 0x5E4),
+	MX50_PIN_EPDC_SDCE2 = _MXC_BUILD_GPIO_PIN_MX50(3, 27, 1, 0x24C, 0x5E8),
+	MX50_PIN_EPDC_SDCE3 = _MXC_BUILD_GPIO_PIN_MX50(3, 28, 1, 0x250, 0x5EC),
+	MX50_PIN_EPDC_SDCE4 = _MXC_BUILD_GPIO_PIN_MX50(3, 29, 1, 0x254, 0x5F0),
+	MX50_PIN_EPDC_SDCE5 = _MXC_BUILD_GPIO_PIN_MX50(3, 30, 1, 0x258, 0x5F4),
+	MX50_PIN_EIM_DA0 = _MXC_BUILD_GPIO_PIN_MX50(0, 0, 1, 0x25C, 0x5F8),
+	MX50_PIN_EIM_DA1 = _MXC_BUILD_GPIO_PIN_MX50(0, 1, 1, 0x260, 0x5FC),
+	MX50_PIN_EIM_DA2 = _MXC_BUILD_GPIO_PIN_MX50(0, 2, 1, 0x264, 0x600),
+	MX50_PIN_EIM_DA3 = _MXC_BUILD_GPIO_PIN_MX50(0, 3, 1, 0x268, 0x604),
+	MX50_PIN_EIM_DA4 = _MXC_BUILD_GPIO_PIN_MX50(0, 4, 1, 0x26C, 0x608),
+	MX50_PIN_EIM_DA5 = _MXC_BUILD_GPIO_PIN_MX50(0, 5, 1, 0x270, 0x60C),
+	MX50_PIN_EIM_DA6 = _MXC_BUILD_GPIO_PIN_MX50(0, 6, 1, 0x274, 0x610),
+	MX50_PIN_EIM_DA7 = _MXC_BUILD_GPIO_PIN_MX50(0, 7, 1, 0x278, 0x614),
+	MX50_PIN_EIM_DA8 = _MXC_BUILD_GPIO_PIN_MX50(0, 8, 1, 0x27C, 0x618),
+	MX50_PIN_EIM_DA9 = _MXC_BUILD_GPIO_PIN_MX50(0, 9, 1, 0x280, 0x61C),
+	MX50_PIN_EIM_DA10 = _MXC_BUILD_GPIO_PIN_MX50(0, 10, 1, 0x284, 0x620),
+	MX50_PIN_EIM_DA11 = _MXC_BUILD_GPIO_PIN_MX50(0, 11, 1, 0x288, 0x624),
+	MX50_PIN_EIM_DA12 = _MXC_BUILD_GPIO_PIN_MX50(0, 12, 1, 0x28C, 0x628),
+	MX50_PIN_EIM_DA13 = _MXC_BUILD_GPIO_PIN_MX50(0, 13, 1, 0x290, 0x62C),
+	MX50_PIN_EIM_DA14 = _MXC_BUILD_GPIO_PIN_MX50(0, 14, 1, 0x294, 0x630),
+	MX50_PIN_EIM_DA15 = _MXC_BUILD_GPIO_PIN_MX50(0, 15, 1, 0x298, 0x634),
+	MX50_PIN_EIM_CS2 = _MXC_BUILD_GPIO_PIN_MX50(0, 16, 1, 0x29C, 0x638),
+	MX50_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN_MX50(0, 17, 1, 0x2A0, 0x63C),
+	MX50_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN_MX50(0, 18, 1, 0x2A4, 0x640),
+	MX50_PIN_EIM_EB0 = _MXC_BUILD_GPIO_PIN_MX50(0, 19, 1, 0x2A8, 0x644),
+	MX50_PIN_EIM_EB1 = _MXC_BUILD_GPIO_PIN_MX50(0, 20, 1, 0x2AC, 0x648),
+	MX50_PIN_EIM_WAIT = _MXC_BUILD_GPIO_PIN_MX50(0, 21, 1, 0x2B0, 0x64C),
+	MX50_PIN_EIM_BCLK = _MXC_BUILD_GPIO_PIN_MX50(0, 22, 1, 0x2B4, 0x650),
+	MX50_PIN_EIM_RDY = _MXC_BUILD_GPIO_PIN_MX50(0, 23, 1, 0x2B8, 0x654),
+	MX50_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN_MX50(0, 24, 1, 0x2BC, 0x658),
+	MX50_PIN_EIM_RW = _MXC_BUILD_GPIO_PIN_MX50(0, 25, 1, 0x2C0, 0x65C),
+	MX50_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN_MX50(0, 26, 1, 0x2C4, 0x660),
+	MX50_PIN_EIM_CRE = _MXC_BUILD_GPIO_PIN_MX50(0, 27, 1, 0x2C8, 0x664),
+
+};
+
+/*!
+ * various IOMUX input select register index
+ */
+enum iomux_input_select_mx50 {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL3_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_DATAREADY_B_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS1_B_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS2_B_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS3_B_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_BUSY_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_0_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_1_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_2_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_3_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_4_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_5_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_6_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_7_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_8_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_9_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_10_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_11_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_12_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_13_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_14_SELECT_INPUT,
+	MUX_IN_ELCDIF_LCDIF_RXDATA_15_SELECT_INPUT,
+	MUX_IN_ELCDIF_VSYNC_I_SELECT_INPUT,
+	MUX_IN_ESDHC2_IPP_CARD_DET_SELECT_INPUT,
+	MUX_IN_ESDHC2_IPP_WP_ON_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_CARD_CLK_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_CMD_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT0_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT1_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT2_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT3_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT4_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT5_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT6_IN_SELECT_INPUT,
+	MUX_IN_ESDHC4_IPP_DAT7_IN_SELECT_INPUT,
+	MUX_IN_FEC_FEC_COL_SELECT_INPUT,
+	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
+	MUX_IN_FEC_FEC_TX_CLK_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_4_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_4_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
+	MUX_IN_RAWNAND_U_GPMI_INPUT_GPMI_DQS_IN_SELECT_INPUT,
+	MUX_IN_RAWNAND_U_GPMI_INPUT_GPMI_RDY0_IN_SELECT_INPUT,
+	MUX_IN_SDMA_EVENTS_14_SELECT_INPUT,
+	MUX_IN_SDMA_EVENTS_15_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART4_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART4_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART5_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART5_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_USBOH1_IPP_IND_OTG_OC_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_0_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_1_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_2_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_3_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_4_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_5_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_6_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_7_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_8_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_9_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_10_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_11_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_12_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_13_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_14_SELECT_INPUT,
+	MUX_IN_WEIMV2_IPP_IND_READ_DATA_15_SELECT_INPUT,
+
+	MUX_INPUT_NUM_MUX,
+};
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX50_PINS_H__ */
diff --git a/arch/arm/mach-mx5/sdma_script_code_mx50.h b/arch/arm/mach-mx5/sdma_script_code_mx50.h
new file mode 100644
index 0000000..bac8c6f
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code_mx50.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+		SDMA RELEASE LABEL:     "SDMA_CODEX.01.00.00"
+
+*******************************************************************************/
+
+#ifndef SDMA_SCRIPT_CODE_MX50_H
+#define SDMA_SCRIPT_CODE_MX50_H
+
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_MX50   0
+#define start_SIZE_MX50   18
+
+#define core_ADDR_MX50   80
+#define core_SIZE_MX50   232
+
+#define common_ADDR_MX50   312
+#define common_SIZE_MX50   330
+
+#define ap_2_ap_ADDR_MX50   642
+#define ap_2_ap_SIZE_MX50   41
+
+#define app_2_mcu_ADDR_MX50   683
+#define app_2_mcu_SIZE_MX50   64
+
+#define mcu_2_app_ADDR_MX50   747
+#define mcu_2_app_SIZE_MX50   70
+
+#define uart_2_mcu_ADDR_MX50   817
+#define uart_2_mcu_SIZE_MX50   74
+
+#define shp_2_mcu_ADDR_MX50   891
+#define shp_2_mcu_SIZE_MX50   69
+
+#define mcu_2_shp_ADDR_MX50   960
+#define mcu_2_shp_SIZE_MX50   72
+
+#define uartsh_2_mcu_ADDR_MX50   1032
+#define uartsh_2_mcu_SIZE_MX50   68
+
+#define loop_DMAs_routines_ADDR_MX50   1100
+#define loop_DMAs_routines_SIZE_MX50   227
+
+#define test_ADDR_MX50   1327
+#define test_SIZE_MX50   63
+
+#define signature_ADDR_MX50   1023
+#define signature_SIZE_MX50   1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define mcu_2_ssiapp_ADDR_MX50   6144
+#define mcu_2_ssiapp_SIZE_MX50   96
+
+#define mcu_2_ssish_ADDR_MX50   6240
+#define mcu_2_ssish_SIZE_MX50   95
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_MX50     6144
+#define RAM_CODE_SIZE_MX50           191
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+static const short sdma_code_mx50[] =
+{
+0xc1e3, 0x57db, 0x52f3, 0x6a01, 0x008f, 0x00d5, 0x7d01, 0x008d,
+0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479, 0x7d2c, 0x7c36, 0x0479,
+0x7c1f, 0x56ee, 0x0f00, 0x0660, 0x7d05, 0x6509, 0x7e43, 0x620a,
+0x7e41, 0x981e, 0x620a, 0x7e3e, 0x6509, 0x7e3c, 0x0512, 0x0512,
+0x02ad, 0x0760, 0x7d03, 0x55fb, 0x6dd3, 0x9829, 0x55fb, 0x1d04,
+0x6dd3, 0x6ac8, 0x7f2f, 0x1f01, 0x2003, 0x4800, 0x7ce4, 0x9851,
+0x55fb, 0x6dd7, 0x0015, 0x7805, 0x6209, 0x6ac8, 0x6209, 0x6ac8,
+0x6dd7, 0x9850, 0x55fb, 0x6dd7, 0x0015, 0x0015, 0x7805, 0x620a,
+0x6ac8, 0x620a, 0x6ac8, 0x6dd7, 0x9850, 0x55fb, 0x6dd7, 0x0015,
+0x0015, 0x0015, 0x7805, 0x620b, 0x6ac8, 0x620b, 0x6ac8, 0x6dd7,
+0x7c09, 0x6ddf, 0x7f07, 0x0000, 0x55eb, 0x4d00, 0x7d07, 0xc1fa,
+0x57db, 0x9804, 0x0007, 0x68cc, 0x680c, 0xc213, 0xc20a, 0x9801,
+0xc1d9, 0xc1e3, 0x57db, 0x52f3, 0x6a21, 0x008f, 0x00d5, 0x7d01,
+0x008d, 0x05a0, 0x5deb, 0x56fb, 0x0478, 0x7d03, 0x0479, 0x7d32,
+0x7c39, 0x0479, 0x7c28, 0x0b70, 0x0311, 0x53eb, 0x0f00, 0x0360,
+0x7d05, 0x6509, 0x7e3f, 0x620a, 0x7e3d, 0x9882, 0x620a, 0x7e3a,
+0x6509, 0x7e38, 0x0512, 0x0512, 0x02ad, 0x0760, 0x7d0a, 0x5a06,
+0x7f31, 0x1f01, 0x2003, 0x4800, 0x7cea, 0x0b70, 0x0311, 0x5313,
+0x98b3, 0x5a26, 0x7f27, 0x1f01, 0x2003, 0x4800, 0x7ce0, 0x0b70,
+0x0311, 0x5313, 0x98b3, 0x0015, 0x7804, 0x6209, 0x5a06, 0x6209,
+0x5a26, 0x98b2, 0x0015, 0x0015, 0x7804, 0x620a, 0x5a06, 0x620a,
+0x5a26, 0x98b2, 0x0015, 0x0015, 0x0015, 0x7804, 0x620b, 0x5a06,
+0x620b, 0x5a26, 0x7c07, 0x0000, 0x55eb, 0x4d00, 0x7d06, 0xc1fa,
+0x57db, 0x9865, 0x0007, 0x680c, 0xc213, 0xc20a, 0x9862
+};
+#endif
diff --git a/arch/arm/mach-mx5/sdram_autogating.c b/arch/arm/mach-mx5/sdram_autogating.c
index fa9f0cc..0b05d79 100644
--- a/arch/arm/mach-mx5/sdram_autogating.c
+++ b/arch/arm/mach-mx5/sdram_autogating.c
@@ -80,6 +80,8 @@ int sdram_autogating_active()
 
 void start_sdram_autogating()
 {
+	if (cpu_is_mx50())
+		return;
 	if (sdram_autogating_paused) {
 		enable();
 		sdram_autogating_paused = 0;
@@ -88,6 +90,9 @@ void start_sdram_autogating()
 
 void  stop_sdram_autogating()
 {
+	if (cpu_is_mx50())
+		return;
+
 	if (sdram_autogating_is_active) {
 		sdram_autogating_paused = 1;
 		disable();
diff --git a/arch/arm/mach-mx5/serial.c b/arch/arm/mach-mx5/serial.c
index ec65140..123db39 100644
--- a/arch/arm/mach-mx5/serial.c
+++ b/arch/arm/mach-mx5/serial.c
@@ -244,7 +244,7 @@ static struct platform_device mxc_uart_device5 = {
 
 static int __init mxc_init_uart(void)
 {
-	if (cpu_is_mx53()) {
+	if (cpu_is_mx53() || cpu_is_mx50()) {
 		mxc_uart_resources1[0].start -= 0x20000000;
 		mxc_uart_resources1[0].end -= 0x20000000;
 		mxc_uart_resources2[0].start -= 0x20000000;
diff --git a/arch/arm/mach-mx5/usb_h1.c b/arch/arm/mach-mx5/usb_h1.c
index 7f0c463..f73cf76 100644
--- a/arch/arm/mach-mx5/usb_h1.c
+++ b/arch/arm/mach-mx5/usb_h1.c
@@ -76,19 +76,25 @@ static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
 
 static void usbotg_clock_gate(bool on)
 {
-	struct clk *usboh3_clk = clk_get(NULL, "usboh3_clk");
-	struct clk *usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
-
+	struct clk *usb_clk;
 	if (on) {
-		clk_enable(usb_ahb_clk);
-		clk_enable(usboh3_clk);
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
 	} else {
-		clk_disable(usboh3_clk);
-		clk_disable(usb_ahb_clk);
-	}
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
 
-	clk_put(usboh3_clk);
-	clk_put(usb_ahb_clk);
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
 }
 
 static int fsl_usb_host_init_ext(struct platform_device *pdev)
@@ -109,6 +115,10 @@ static int fsl_usb_host_init_ext(struct platform_device *pdev)
 		usb_clk = clk_get(NULL, "usb_utmi_clk");
 		clk_disable(usb_clk);
 		clk_put(usb_clk);
+	} else if (cpu_is_mx50()) {
+		usb_clk = clk_get(&pdev->dev, "usb_phy2_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
 	}
 
 	ret = fsl_usb_host_init(pdev);
@@ -143,7 +153,12 @@ static void fsl_usb_host_uninit_ext(struct fsl_usb2_platform_data *pdata)
 		usb_clk = clk_get(&pdata->pdev->dev, "usb_phy2_clk");
 		clk_disable(usb_clk);
 		clk_put(usb_clk);
+	} else if (cpu_is_mx50()) {
+		usb_clk = clk_get(&pdata->pdev->dev, "usb_phy2_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
 	}
+
 	fsl_usb_host_uninit(pdata);
 }
 
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index 1b25110..2a58492 100644
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -147,6 +147,7 @@
 #define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
 #define USBH1_PHY_CTRL0		USBOTHER_REG(0x1c)	/* USB Cotrol Register 1*/
 #define USBH1_PHY_CTRL1		USBOTHER_REG(0x20)	/* USB Cotrol Register 1*/
+#define USB_CLKONOFF_CTRL       USBOTHER_REG(0x24)      /* USB Clock on/off Control Register */
 
 /*
  * register bits
@@ -245,6 +246,7 @@
 #define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
 #define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
 #define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_O_PWR_POL	(1 << 24)	/* OTG power pin polarity */
 #define UCTRL_H2WIR		(1 << 23)	/* HOST2 wakeup intr request received */
 #define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
 #define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
@@ -329,6 +331,7 @@
 #define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
 #define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
 #define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+#define USB_UH1_OC_POL	(1 << 6)		/* UH1 Polarity of OC,Low active */
 /* USB_PHY_CTRL_FUNC2*/
 #define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
 #define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
@@ -355,6 +358,8 @@
 #define ULPIVW_WDATA_SHIFT	0
 
 #define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
-
+/* USB Clock on/off Control Register */
+#define OTG_AHBCLK_OFF          (0x1<<17)      /* 1: OFF */
+#define H1_AHBCLK_OFF           (0x1<<18)      /* 1: OFF */
 extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index 742fb43..990c3a0 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -34,6 +34,7 @@ extern int mx27_clocks_init(unsigned long fref);
 extern int mx31_clocks_init(unsigned long fref);
 extern int mx35_clocks_init(void);
 extern int mx37_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
+extern int mx50_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih);
 extern int mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
 extern int mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
 extern int mxc_init_devices(void);
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
index 3861342..ff05850 100644
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -32,6 +32,10 @@
 #define PHYS_OFFSET             UL(0x90000000)
 #endif
 
+#ifdef CONFIG_ARCH_MX50
+#define PHYS_OFFSET             UL(0x70000000)
+#endif
+
 #ifdef CONFIG_ARCH_MX53
 #define PHYS_OFFSET             UL(0x70000000)
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/mx5x.h b/arch/arm/plat-mxc/include/mach/mx5x.h
index 44a5da1..3b9728e 100644
--- a/arch/arm/plat-mxc/include/mach/mx5x.h
+++ b/arch/arm/plat-mxc/include/mach/mx5x.h
@@ -144,6 +144,22 @@
 #define CTI3_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00007000)
 #define CORTEX_DBG_BASE_ADDR	(DEBUG_BASE_ADDR + 0x00008000)
 
+#define ABPHDMA_BASE_ADDR	 (DEBUG_BASE_ADDR + 0x01000000)
+#define OCOTP_CTRL_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01002000)
+#define DIGCTL_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01004000)
+#define GPMI_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01006000)
+#define BCH_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01008000)
+#define ELCDIF_BASE_ADDR	(DEBUG_BASE_ADDR + 0x0100A000)
+#define EPXP_BASE_ADDR		(DEBUG_BASE_ADDR + 0x0100C000)
+#define DCP_BASE_ADDR		(DEBUG_BASE_ADDR + 0x0100E000)
+#define EPDC_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01010000)
+#define QOSC_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01012000)
+#define PERFMON_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01014000)
+#define SSP_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01016000)
+#define ANATOP_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01018000)
+
+#define MX50_NIC_BASE_ADDR	(DEBUG_BASE_ADDR + 0x08000000)
+
 /*
  * SPBA global module enabled #0
  */
@@ -368,7 +384,7 @@
 #define AIPS2_IO_ADDRESS(x)  \
 	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
 
-#define MX53_BASE_ADDR(x) (cpu_is_mx53() ? (x) - 0x20000000 : (x))
+#define MX53_BASE_ADDR(x) (cpu_is_mx53() || cpu_is_mx50() ? (x) - 0x20000000 : (x))
 
 #define IS_MEM_DEVICE_NONSHARED(x)		0
 
@@ -385,6 +401,8 @@
 #define DMA_REQ_SLIM_B_TX				42 /* MX51 */
 #define DMA_REQ_UART3_TX_MX51		44
 #define DMA_REQ_UART3_RX_MX51		43
+#define DMA_REQ_UART3_TX_MX50		43
+#define DMA_REQ_UART3_RX_MX50		42
 #define DMA_REQ_ESAI_TX				41
 #define DMA_REQ_SDHC4_MX51			41
 #define DMA_REQ_ESAI_RX				40
@@ -431,9 +449,13 @@
 #define DMA_REQ_UART5_RX				16
 #define DMA_REQ_SPDIF_TX				15
 #define DMA_REQ_SPDIF_RX				14
+#define DMA_REQ_EXTREQ0_MX50				14
+#define DMA_REQ_EXTREQ1_MX50				15
 /* UART2 is shared w/FIRI on MX53 */
 #define DMA_REQ_FIRI_TX					13
 #define DMA_REQ_FIRI_RX				12
+#define DMA_REQ_UART2_TX_MX50				13
+#define DMA_REQ_UART2_RX_MX50				12
 #define DMA_REQ_SDHC4_MX53			11
 
 #define DMA_REQ_HS_I2C_RX				11 /* MX51 */
@@ -450,7 +472,9 @@
 #define DMA_REQ_SLIM_B					5 /* MX51 */
 #define DMA_REQ_ATA_TX_END			4
 #define DMA_REQ_ATA_TX					3
+#define DMA_REQ_UART4_TX_MX50				3
 #define DMA_REQ_ATA_RX					2
+#define DMA_REQ_UART4_RX_MX50				2
 #define DMA_REQ_GPC					1
 #define DMA_REQ_VPU					0
 
@@ -478,16 +502,21 @@
 #define MXC_INT_USB_H3		17
 #define MXC_INT_USB_OTG	18
 #define MXC_INT_SAHARA_H0	19
+#define MXC_INT_DATABAHN	19 /* MX50 */
 #define MXC_INT_SAHARA_H1	20
+#define MXC_INT_ELCDIF		20 /* MX50 */
 #define MXC_INT_SCC_SMN	21
+#define MXC_INT_EPXP		21 /* MX50 */
 #define MXC_INT_SCC_STZ	22
 #define MXC_INT_SCC_SCM	23
 #define MXC_INT_SRTC_NTZ	24
 #define MXC_INT_SRTC_TZ	25
 #define MXC_INT_RTIC		26
 #define MXC_INT_CSU		27
+#define MXC_INT_EPDC		27 /* MX50 */
 #define MXC_INT_SATA		28
 #define MXC_INT_SLIM_B		28 /* MX51 */
+#define MXC_INT_NIC		28 /* MX50 Perfmon IRQ */
 #define MXC_INT_SSI1		29
 #define MXC_INT_SSI2		30
 #define MXC_INT_UART1		31
@@ -531,6 +560,10 @@
 #define MXC_INT_SIM_IPB		67
 #define MXC_INT_SIM_DAT		68
 #define MXC_INT_IIM		69
+#define MXC_INT_ANATOP1		66 /* MX50 what's it? */
+#define MXC_INT_ANATOP2		67
+#define MXC_INT_ANATOP3		68
+#define MXC_INT_ANATOP4		69
 #define MXC_INT_ATA		70
 #define MXC_INT_CCM1		71
 #define MXC_INT_CCM2		72
@@ -556,23 +589,46 @@
 #define MXC_INT_CTI1_TG2	89
 #define MXC_INT_SJC		90
 #define MXC_INT_SPDIF_MX51		91
+#define MXC_INT_DCP_CHAN1_3	91 /* MX50 */
 #define MXC_INT_TVE		92
+#define MXC_INT_DCP_CHAN0	92 /* MX50 */
 #define MXC_INT_FIRI		93
+#define MXC_INT_DCP_CHAN0_3_SEC	93 /* MX50 */
 #define MXC_INT_PWM2		94
 #define MXC_INT_SLIM_EXP		95
 #define MXC_INT_SSI3		96
 #define MXC_INT_EMI_BOOT		97
+#define MXC_INT_RNGB_BLOCK	97 /* MX50 */
 #define MXC_INT_CTI1_TG3	98
 #define MXC_INT_SMC_RX			99
 #define MXC_INT_VPU_IDLE	100
+#define MXC_INT_RAWNAND_BCH	100 /* MX50 */
 #define MXC_INT_EMI_NFC	101
 #define MXC_INT_GPU_IDLE	102
+#define MXC_INT_RAWNAND_GPMI	102 /* MX50 */
 #define MXC_INT_GPIO5_LOW	103
 #define MXC_INT_GPIO5_HIGH	104
 #define MXC_INT_GPIO6_LOW	105
 #define MXC_INT_GPIO6_HIGH	106
 #define MXC_INT_GPIO7_LOW	107
 #define MXC_INT_GPIO7_HIGH	108
+#define MXC_INT_MSHC		109 /* MX50 */
+#define MXC_INT_APBHDMA_CHAN0	110
+#define MXC_INT_APBHDMA_CHAN1	111
+#define MXC_INT_APBHDMA_CHAN2	112
+#define MXC_INT_APBHDMA_CHAN3	113
+#define MXC_INT_APBHDMA_CHAN4	114
+#define MXC_INT_APBHDMA_CHAN5	115
+#define MXC_INT_APBHDMA_CHAN6	116
+#define MXC_INT_APBHDMA_CHAN7	117
+#define MXC_INT_APBHDMA_CHAN8	118
+#define MXC_INT_APBHDMA_CHAN9	119
+#define MXC_INT_APBHDMA_CHAN10	120
+#define MXC_INT_APBHDMA_CHAN11	121
+#define MXC_INT_APBHDMA_CHAN12	122
+#define MXC_INT_APBHDMA_CHAN13	123
+#define MXC_INT_APBHDMA_CHAN14	124
+#define MXC_INT_APBHDMA_CHAN15	125
 
 /* gpio and gpio based interrupt handling */
 #define GPIO_DR                 0x00
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 91a6483..c2262f5 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -34,6 +34,7 @@
 #define MXC_CPU_MX37		37
 #define MXC_CPU_MX51		51
 #define MXC_CPU_MX53		53
+#define MXC_CPU_MX50		50
 
 #ifndef __ASSEMBLY__
 extern unsigned int __mxc_cpu_type;
@@ -147,6 +148,18 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mx53()		(0)
 #endif
 
+#ifdef CONFIG_ARCH_MX50
+# ifdef mxc_cpu_type
+#  undef mxc_cpu_type
+#  define mxc_cpu_type __mxc_cpu_type
+# else
+#  define mxc_cpu_type MXC_CPU_MX50
+# endif
+# define cpu_is_mx50()		(mxc_cpu_type == MXC_CPU_MX50)
+#else
+# define cpu_is_mx50()		(0)
+#endif
+
 #define cpu_is_mx32()		(0)
 
 /*
@@ -655,7 +668,7 @@ void gpio_deactivate_esai_ports(void);
 #define CSCR_A(n) (IO_ADDRESS(WEIM_BASE_ADDR) + n * 0x10 + 0x8)
 #endif
 
-#define cpu_is_mx5()	(cpu_is_mx51() || cpu_is_mx53())
+#define cpu_is_mx5()	(cpu_is_mx51() || cpu_is_mx53() || cpu_is_mx50())
 #define cpu_is_mx3()	(cpu_is_mx31() || cpu_is_mx35())
 #define cpu_is_mx2()	(cpu_is_mx21() || cpu_is_mx27())
 
diff --git a/arch/arm/plat-mxc/pwm.c b/arch/arm/plat-mxc/pwm.c
index f159feb..77eb52c 100644
--- a/arch/arm/plat-mxc/pwm.c
+++ b/arch/arm/plat-mxc/pwm.c
@@ -61,7 +61,7 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 	if (pwm == NULL || period_ns == 0 || duty_ns > period_ns)
 		return -EINVAL;
 
-	if (cpu_is_mx27() || cpu_is_mx3() || cpu_is_mx51() || cpu_is_mx53()) {
+	if (cpu_is_mx27() || cpu_is_mx3() || cpu_is_mx5()) {
 		unsigned long long c;
 		unsigned long period_cycles, duty_cycles, prescale;
 		c = clk_get_rate(pwm->clk);
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index c8b8ba4..437c611 100644
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -275,21 +275,25 @@ static void usbh1_set_utmi_xcvr(void)
 	while ((UH1_USBCMD) & (UCMD_RESET))
 		;
 
-	/* MX53 EVK is not using OC */
-	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS;
-
-	USBCTRL &= ~UCTRL_H1PM;	/* OTG Power Mask */
-	USBCTRL &= ~UCTRL_H1WIE;	/* OTG Wakeup Intr Disable */
-
-	/* Over current disable */
-	USB_PHY_CTR_FUNC |= (0x1 << 5);
-
+	/* For OC and PWR, it is board level setting
+	 * The default setting is for mx53 evk
+	 */
+	USBCTRL &= ~UCTRL_H1PM;	/* Host1 Power Mask */
+	USBCTRL &= ~UCTRL_H1WIE; /* Host1 Wakeup Intr Disable */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* Over current disable */
+
+	if (machine_is_mx50_arm2()) {
+		USBCTRL |= UCTRL_H1PM; /* Host1 Power Mask */
+		USB_PHY_CTR_FUNC &= ~USB_UH1_OC_DIS; /* Over current enable */
+		/* Over current polarity low active */
+		USB_PHY_CTR_FUNC |= USB_UH1_OC_POL;
+	}
 	/* set UTMI xcvr */
 	tmp = UH1_PORTSC1 & ~PORTSC_PTS_MASK;
 	tmp |= PORTSC_PTS_UTMI;
 	UH1_PORTSC1 = tmp;
 
-	/* Set the PHY clock to 19.2MHz */
+	/* Set the PHY clock to 24MHz */
 	USBH1_PHY_CTRL1 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
 	USBH1_PHY_CTRL1 |= 0x01;
 
@@ -486,6 +490,10 @@ int fsl_usb_host_init(struct platform_device *pdev)
 		clk_put(usboh3_clk);
 	}
 
+	if (cpu_is_mx50())
+		/* Turn on AHB CLK for H1*/
+		USB_CLKONOFF_CTRL &= ~H1_AHBCLK_OFF;
+
 	/* enable board power supply for xcvr */
 	if (pdata->xcvr_pwr) {
 		if (pdata->xcvr_pwr->regu1)
@@ -705,6 +713,11 @@ static void otg_set_utmi_xcvr(void)
 	} else if (cpu_is_mx25()) {
 		USBCTRL |= UCTRL_OCPOL;
 		USBCTRL &= ~UCTRL_PP;
+	} else if (cpu_is_mx50()) {
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+		if (machine_is_mx50_arm2())
+			/* OTG Power pin polarity low */
+			USBCTRL |= UCTRL_O_PWR_POL;
 	} else {
 		/* USBOTG_PWR low active */
 		USBCTRL &= ~UCTRL_PP;
@@ -716,8 +729,9 @@ static void otg_set_utmi_xcvr(void)
 			USBCTRL |= UCTRL_OLOCKD;
 	}
 
-	if (!cpu_is_mx53())
+	if (cpu_is_mx51())
 		USBCTRL &= ~UCTRL_OPM;	/* OTG Power Mask */
+
 	USBCTRL &= ~UCTRL_OWIE;	/* OTG Wakeup Intr Disable */
 
 	/* set UTMI xcvr */
@@ -797,6 +811,9 @@ int usbotg_init(struct platform_device *pdev)
 	if (!otg_used) {
 		if (fsl_check_usbclk() != 0)
 			return -EINVAL;
+		if (cpu_is_mx50())
+			/* Turn on AHB CLK for OTG*/
+			USB_CLKONOFF_CTRL &= ~OTG_AHBCLK_OFF;
 
 		pr_debug("%s: grab pins\n", __func__);
 		if (pdata->gpio_usb_active && pdata->gpio_usb_active())
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index b411360..c56531d 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -12,7 +12,7 @@
 #
 #   http://www.arm.linux.org.uk/developer/machines/?action=new
 #
-# Last update: Mon Nov 16 06:33:51 2009
+# Last update: Sat Jul 3 02:20:26 2010
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
@@ -1319,7 +1319,7 @@ mistral			MACH_MISTRAL		MISTRAL			1315
 msm			MACH_MSM		MSM			1316
 ct5910			MACH_CT5910		CT5910			1317
 ct5912			MACH_CT5912		CT5912			1318
-hynet_ine		MACH_HYNET_INE		HYNET_INE		1319
+argonst_foundation	MACH_HYNET_INE		HYNET_INE		1319
 hynet_app		MACH_HYNET_APP		HYNET_APP		1320
 msm7200			MACH_MSM7200		MSM7200			1321
 msm7600			MACH_MSM7600		MSM7600			1322
@@ -1776,7 +1776,8 @@ cybook3			MACH_CYBOOK3		CYBOOK3			1784
 wdg002			MACH_WDG002		WDG002			1785
 sg560adsl		MACH_SG560ADSL		SG560ADSL		1786
 nextio_n2800_ica	MACH_NEXTIO_N2800_ICA	NEXTIO_N2800_ICA	1787
-marvell_newdb		MACH_MARVELL_NEWDB	MARVELL_NEWDB		1789
+dove_db			MACH_DOVE_DB		DOVE_DB			1788
+dove_avng		MACH_MARVELL_NEWDB	MARVELL_NEWDB		1789
 vandihud		MACH_VANDIHUD		VANDIHUD		1790
 magx_e8			MACH_MAGX_E8		MAGX_E8			1791
 magx_z6			MACH_MAGX_Z6		MAGX_Z6			1792
@@ -2256,7 +2257,7 @@ oratisalog		MACH_ORATISALOG		ORATISALOG		2268
 oratismadi		MACH_ORATISMADI		ORATISMADI		2269
 oratisot16		MACH_ORATISOT16		ORATISOT16		2270
 oratisdesk		MACH_ORATISDESK		ORATISDESK		2271
-v2_ca9			MACH_V2P_CA9		V2P_CA9			2272
+vexpress		MACH_VEXPRESS		VEXPRESS		2272
 sintexo			MACH_SINTEXO		SINTEXO			2273
 cm3389			MACH_CM3389		CM3389			2274
 omap3_cio		MACH_OMAP3_CIO		OMAP3_CIO		2275
@@ -2307,7 +2308,7 @@ ecac2378		MACH_ECAC2378		ECAC2378		2319
 tazkiosk		MACH_TAZKIOSK		TAZKIOSK		2320
 whiterabbit_mch		MACH_WHITERABBIT_MCH	WHITERABBIT_MCH		2321
 sbox9263		MACH_SBOX9263		SBOX9263		2322
-oreo			MACH_OREO		OREO			2323
+oreo_camera		MACH_OREO		OREO			2323
 smdk6442		MACH_SMDK6442		SMDK6442		2324
 openrd_base		MACH_OPENRD_BASE	OPENRD_BASE		2325
 incredible		MACH_INCREDIBLE		INCREDIBLE		2326
@@ -2373,7 +2374,7 @@ sch_m490		MACH_SCH_M490		SCH_M490		2386
 rbl01			MACH_RBL01		RBL01			2387
 omnifi			MACH_OMNIFI		OMNIFI			2388
 otavalo			MACH_OTAVALO		OTAVALO			2389
-sienna			MACH_SIENNA		SIENNA			2390
+siena			MACH_SIENNA		SIENNA			2390
 htc_excalibur_s620	MACH_HTC_EXCALIBUR_S620	HTC_EXCALIBUR_S620	2391
 htc_opal		MACH_HTC_OPAL		HTC_OPAL		2392
 touchbook		MACH_TOUCHBOOK		TOUCHBOOK		2393
@@ -2497,7 +2498,7 @@ hiram			MACH_HIRAM		HIRAM			2510
 phy3250			MACH_PHY3250		PHY3250			2511
 ea3250			MACH_EA3250		EA3250			2512
 fdi3250			MACH_FDI3250		FDI3250			2513
-whitestone		MACH_WHITESTONE		WHITESTONE		2514
+htcwhitestone		MACH_WHITESTONE		WHITESTONE		2514
 at91sam9263nit		MACH_AT91SAM9263NIT	AT91SAM9263NIT		2515
 ccmx51			MACH_CCMX51		CCMX51			2516
 ccmx51js		MACH_CCMX51JS		CCMX51JS		2517
@@ -2515,5 +2516,427 @@ swarco_itc3		MACH_SWARCO_ITC3	SWARCO_ITC3		2528
 tx51			MACH_TX51		TX51			2529
 dolby_cat1021		MACH_DOLBY_CAT1021	DOLBY_CAT1021		2530
 mx28evk			MACH_MX28EVK		MX28EVK			2531
+phoenix260		MACH_PHOENIX260		PHOENIX260		2532
+uvaca_stork		MACH_UVACA_STORK	UVACA_STORK		2533
+smartq5			MACH_SMARTQ5		SMARTQ5			2534
+all3078			MACH_ALL3078		ALL3078			2535
+ctera_2bay_ds		MACH_CTERA_2BAY_DS	CTERA_2BAY_DS		2536
+siogentoo3		MACH_SIOGENTOO3		SIOGENTOO3		2537
+epb5000			MACH_EPB5000		EPB5000			2538
+hy9263			MACH_HY9263		HY9263			2539
+acer_tempo_m900		MACH_ACER_TEMPO_M900	ACER_TEMPO_M900		2540
+acer_tempo_dx650	MACH_ACER_TEMPO_DX900	ACER_TEMPO_DX900	2541
+acer_tempo_x960		MACH_ACER_TEMPO_X960	ACER_TEMPO_X960		2542
+acer_eten_v900		MACH_ACER_ETEN_V900	ACER_ETEN_V900		2543
+acer_eten_x900		MACH_ACER_ETEN_X900	ACER_ETEN_X900		2544
+bonnell			MACH_BONNELL		BONNELL			2545
+oht_mx27		MACH_OHT_MX27		OHT_MX27		2546
+htcquartz		MACH_HTCQUARTZ		HTCQUARTZ		2547
+davinci_dm6467tevm	MACH_DAVINCI_DM6467TEVM	DAVINCI_DM6467TEVM	2548
+c3ax03			MACH_C3AX03		C3AX03			2549
+mxt_td60		MACH_MXT_TD60		MXT_TD60		2550
+esyx			MACH_ESYX		ESYX			2551
+dove_db2		MACH_DOVE_DB2		DOVE_DB2		2552
+bulldog			MACH_BULLDOG		BULLDOG			2553
+derell_me2000		MACH_DERELL_ME2000	DERELL_ME2000		2554
+bcmring_base		MACH_BCMRING_BASE	BCMRING_BASE		2555
+bcmring_evm		MACH_BCMRING_EVM	BCMRING_EVM		2556
+bcmring_evm_jazz	MACH_BCMRING_EVM_JAZZ	BCMRING_EVM_JAZZ	2557
+bcmring_sp		MACH_BCMRING_SP		BCMRING_SP		2558
+bcmring_sv		MACH_BCMRING_SV		BCMRING_SV		2559
+bcmring_sv_jazz		MACH_BCMRING_SV_JAZZ	BCMRING_SV_JAZZ		2560
+bcmring_tablet		MACH_BCMRING_TABLET	BCMRING_TABLET		2561
+bcmring_vp		MACH_BCMRING_VP		BCMRING_VP		2562
+bcmring_evm_seikor	MACH_BCMRING_EVM_SEIKOR	BCMRING_EVM_SEIKOR	2563
+bcmring_sp_wqvga	MACH_BCMRING_SP_WQVGA	BCMRING_SP_WQVGA	2564
+bcmring_custom		MACH_BCMRING_CUSTOM	BCMRING_CUSTOM		2565
+acer_s200		MACH_ACER_S200		ACER_S200		2566
+bt270			MACH_BT270		BT270			2567
+iseo			MACH_ISEO		ISEO			2568
+cezanne			MACH_CEZANNE		CEZANNE			2569
+lucca			MACH_LUCCA		LUCCA			2570
+supersmart		MACH_SUPERSMART		SUPERSMART		2571
+arm11_board		MACH_CS_MISANO		CS_MISANO		2572
+magnolia2		MACH_MAGNOLIA2		MAGNOLIA2		2573
+emxx			MACH_EMXX		EMXX			2574
+outlaw			MACH_OUTLAW		OUTLAW			2575
+riot_bei2		MACH_RIOT_BEI2		RIOT_BEI2		2576
+riot_vox		MACH_RIOT_VOX		RIOT_VOX		2577
+riot_x37		MACH_RIOT_X37		RIOT_X37		2578
+mega25mx		MACH_MEGA25MX		MEGA25MX		2579
+benzina2		MACH_BENZINA2		BENZINA2		2580
+ignite			MACH_IGNITE		IGNITE			2581
+foggia			MACH_FOGGIA		FOGGIA			2582
+arezzo			MACH_AREZZO		AREZZO			2583
+leica_skywalker		MACH_LEICA_SKYWALKER	LEICA_SKYWALKER		2584
+jacinto2_jamr		MACH_JACINTO2_JAMR	JACINTO2_JAMR		2585
+gts_nova		MACH_GTS_NOVA		GTS_NOVA		2586
+p3600			MACH_P3600		P3600			2587
+dlt2			MACH_DLT2		DLT2			2588
+df3120			MACH_DF3120		DF3120			2589
+ecucore_9g20		MACH_ECUCORE_9G20	ECUCORE_9G20		2590
+nautel_lpc3240		MACH_NAUTEL_LPC3240	NAUTEL_LPC3240		2591
+glacier			MACH_GLACIER		GLACIER			2592
+phrazer_bulldog		MACH_PHRAZER_BULLDOG	PHRAZER_BULLDOG		2593
+omap3_bulldog		MACH_OMAP3_BULLDOG	OMAP3_BULLDOG		2594
+pca101			MACH_PCA101		PCA101			2595
+buzzc			MACH_BUZZC		BUZZC			2596
+sasie2			MACH_SASIE2		SASIE2			2597
+davinci_dm6467_cio	MACH_DAVINCI_CIO	DAVINCI_CIO		2598
+smartmeter_dl		MACH_SMARTMETER_DL	SMARTMETER_DL		2599
+wzl6410			MACH_WZL6410		WZL6410			2600
+wzl6410m		MACH_WZL6410M		WZL6410M		2601
+wzl6410f		MACH_WZL6410F		WZL6410F		2602
+wzl6410i		MACH_WZL6410I		WZL6410I		2603
+spacecom1		MACH_SPACECOM1		SPACECOM1		2604
+pingu920		MACH_PINGU920		PINGU920		2605
+bravoc			MACH_BRAVOC		BRAVOC			2606
+cybo2440		MACH_CYBO2440		CYBO2440		2607
+vdssw			MACH_VDSSW		VDSSW			2608
+romulus			MACH_ROMULUS		ROMULUS			2609
+omap_magic		MACH_OMAP_MAGIC		OMAP_MAGIC		2610
+eltd100			MACH_ELTD100		ELTD100			2611
+capc7117		MACH_CAPC7117		CAPC7117		2612
+swan			MACH_SWAN		SWAN			2613
+veu			MACH_VEU		VEU			2614
+rm2			MACH_RM2		RM2			2615
+tt2100			MACH_TT2100		TT2100			2616
+venice			MACH_VENICE		VENICE			2617
+pc7323			MACH_PC7323		PC7323			2618
+masp			MACH_MASP		MASP			2619
+fujitsu_tvstbsoc0	MACH_FUJITSU_TVSTBSOC	FUJITSU_TVSTBSOC	2620
+fujitsu_tvstbsoc1	MACH_FUJITSU_TVSTBSOC1	FUJITSU_TVSTBSOC1	2621
+lexikon			MACH_LEXIKON		LEXIKON			2622
+mini2440v2		MACH_MINI2440V2		MINI2440V2		2623
+icontrol		MACH_ICONTROL		ICONTROL		2624
+gplugd			MACH_SHEEVAD		SHEEVAD			2625
+qsd8x50a_st1_1		MACH_QSD8X50A_ST1_1	QSD8X50A_ST1_1		2626
+qsd8x50a_st1_5		MACH_QSD8X50A_ST1_5	QSD8X50A_ST1_5		2627
+bee			MACH_BEE		BEE			2628
 mx23evk			MACH_MX23EVK		MX23EVK			2629
-mx53_evk                MACH_MX53_EVK	        MX53_EVK		2716
+ap4evb			MACH_AP4EVB		AP4EVB			2630
+stockholm		MACH_STOCKHOLM		STOCKHOLM		2631
+lpc_h3131		MACH_LPC_H3131		LPC_H3131		2632
+stingray		MACH_STINGRAY		STINGRAY		2633
+kraken			MACH_KRAKEN		KRAKEN			2634
+gw2388			MACH_GW2388		GW2388			2635
+jadecpu			MACH_JADECPU		JADECPU			2636
+carlisle		MACH_CARLISLE		CARLISLE		2637
+lux_sf9			MACH_LUX_SFT9		LUX_SFT9		2638
+nemid_tb		MACH_NEMID_TB		NEMID_TB		2639
+terrier			MACH_TERRIER		TERRIER			2640
+turbot			MACH_TURBOT		TURBOT			2641
+sanddab			MACH_SANDDAB		SANDDAB			2642
+mx35_cicada		MACH_MX35_CICADA	MX35_CICADA		2643
+ghi2703d		MACH_GHI2703D		GHI2703D		2644
+lux_sfx9		MACH_LUX_SFX9		LUX_SFX9		2645
+lux_sf9g		MACH_LUX_SF9G		LUX_SF9G		2646
+lux_edk9		MACH_LUX_EDK9		LUX_EDK9		2647
+hw90240			MACH_HW90240		HW90240			2648
+dm365_leopard		MACH_DM365_LEOPARD	DM365_LEOPARD		2649
+mityomapl138		MACH_MITYOMAPL138	MITYOMAPL138		2650
+scat110			MACH_SCAT110		SCAT110			2651
+acer_a1			MACH_ACER_A1		ACER_A1			2652
+cmcontrol		MACH_CMCONTROL		CMCONTROL		2653
+pelco_lamar		MACH_PELCO_LAMAR	PELCO_LAMAR		2654
+rfp43			MACH_RFP43		RFP43			2655
+sk86r0301		MACH_SK86R0301		SK86R0301		2656
+ctpxa			MACH_CTPXA		CTPXA			2657
+epb_arm9_a		MACH_EPB_ARM9_A		EPB_ARM9_A		2658
+guruplug		MACH_GURUPLUG		GURUPLUG		2659
+spear310		MACH_SPEAR310		SPEAR310		2660
+spear320		MACH_SPEAR320		SPEAR320		2661
+robotx			MACH_ROBOTX		ROBOTX			2662
+lsxhl			MACH_LSXHL		LSXHL			2663
+smartlite		MACH_SMARTLITE		SMARTLITE		2664
+cws2			MACH_CWS2		CWS2			2665
+m619			MACH_M619		M619			2666
+smartview		MACH_SMARTVIEW		SMARTVIEW		2667
+lsa_salsa		MACH_LSA_SALSA		LSA_SALSA		2668
+kizbox			MACH_KIZBOX		KIZBOX			2669
+htccharmer		MACH_HTCCHARMER		HTCCHARMER		2670
+guf_neso_lt		MACH_GUF_NESO_LT	GUF_NESO_LT		2671
+pm9g45			MACH_PM9G45		PM9G45			2672
+htcpanther		MACH_HTCPANTHER		HTCPANTHER		2673
+htcpanther_cdma		MACH_HTCPANTHER_CDMA	HTCPANTHER_CDMA		2674
+reb01			MACH_REB01		REB01			2675
+aquila			MACH_AQUILA		AQUILA			2676
+spark_sls_hw2		MACH_SPARK_SLS_HW2	SPARK_SLS_HW2		2677
+sheeva_esata		MACH_ESATA_SHEEVAPLUG	ESATA_SHEEVAPLUG	2678
+msm7x30_surf		MACH_MSM7X30_SURF	MSM7X30_SURF		2679
+micro2440		MACH_MICRO2440		MICRO2440		2680
+am2440			MACH_AM2440		AM2440			2681
+tq2440			MACH_TQ2440		TQ2440			2682
+lpc2478oem		MACH_LPC2478OEM		LPC2478OEM		2683
+ak880x			MACH_AK880X		AK880X			2684
+cobra3530		MACH_COBRA3530		COBRA3530		2685
+pmppb			MACH_PMPPB		PMPPB			2686
+u6715			MACH_U6715		U6715			2687
+axar1500_sender		MACH_AXAR1500_SENDER	AXAR1500_SENDER		2688
+g30_dvb			MACH_G30_DVB		G30_DVB			2689
+vc088x			MACH_VC088X		VC088X			2690
+mioa702			MACH_MIOA702		MIOA702			2691
+hpmin			MACH_HPMIN		HPMIN			2692
+ak880xak		MACH_AK880XAK		AK880XAK		2693
+arm926tomap850		MACH_ARM926TOMAP850	ARM926TOMAP850		2694
+lkevm			MACH_LKEVM		LKEVM			2695
+mw6410			MACH_MW6410		MW6410			2696
+terastation_wxl		MACH_TERASTATION_WXL	TERASTATION_WXL		2697
+cpu8000e		MACH_CPU8000E		CPU8000E		2698
+catania			MACH_CATANIA		CATANIA			2699
+tokyo			MACH_TOKYO		TOKYO			2700
+msm7201a_surf		MACH_MSM7201A_SURF	MSM7201A_SURF		2701
+msm7201a_ffa		MACH_MSM7201A_FFA	MSM7201A_FFA		2702
+msm7x25_surf		MACH_MSM7X25_SURF	MSM7X25_SURF		2703
+msm7x25_ffa		MACH_MSM7X25_FFA	MSM7X25_FFA		2704
+msm7x27_surf		MACH_MSM7X27_SURF	MSM7X27_SURF		2705
+msm7x27_ffa		MACH_MSM7X27_FFA	MSM7X27_FFA		2706
+msm7x30_ffa		MACH_MSM7X30_FFA	MSM7X30_FFA		2707
+qsd8x50_surf		MACH_QSD8X50_SURF	QSD8X50_SURF		2708
+qsd8x50_comet		MACH_QSD8X50_COMET	QSD8X50_COMET		2709
+qsd8x50_ffa		MACH_QSD8X50_FFA	QSD8X50_FFA		2710
+qsd8x50a_surf		MACH_QSD8X50A_SURF	QSD8X50A_SURF		2711
+qsd8x50a_ffa		MACH_QSD8X50A_FFA	QSD8X50A_FFA		2712
+adx_xgcp10		MACH_ADX_XGCP10		ADX_XGCP10		2713
+mcgwumts2a		MACH_MCGWUMTS2A		MCGWUMTS2A		2714
+mobikt			MACH_MOBIKT		MOBIKT			2715
+mx53_evk		MACH_MX53_EVK		MX53_EVK		2716
+igep0030		MACH_IGEP0030		IGEP0030		2717
+axell_h40_h50_ctrl	MACH_AXELL_H40_H50_CTRL	AXELL_H40_H50_CTRL	2718
+dtcommod		MACH_DTCOMMOD		DTCOMMOD		2719
+gould			MACH_GOULD		GOULD			2720
+siberia			MACH_SIBERIA		SIBERIA			2721
+sbc3530			MACH_SBC3530		SBC3530			2722
+qarm			MACH_QARM		QARM			2723
+mips			MACH_MIPS		MIPS			2724
+mx27grb			MACH_MX27GRB		MX27GRB			2725
+sbc8100			MACH_SBC8100		SBC8100			2726
+saarb			MACH_SAARB		SAARB			2727
+omap3mini		MACH_OMAP3MINI		OMAP3MINI		2728
+cnmbook7se		MACH_CNMBOOK7SE		CNMBOOK7SE		2729
+catan			MACH_CATAN		CATAN			2730
+harmony			MACH_HARMONY		HARMONY			2731
+tonga			MACH_TONGA		TONGA			2732
+cybook_orizon		MACH_CYBOOK_ORIZON	CYBOOK_ORIZON		2733
+htcrhodiumcdma		MACH_HTCRHODIUMCDMA	HTCRHODIUMCDMA		2734
+epc_g45			MACH_EPC_G45		EPC_G45			2735
+epc_lpc3250		MACH_EPC_LPC3250	EPC_LPC3250		2736
+mxc91341evb		MACH_MXC91341EVB	MXC91341EVB		2737
+rtw1000			MACH_RTW1000		RTW1000			2738
+bobcat			MACH_BOBCAT		BOBCAT			2739
+trizeps6		MACH_TRIZEPS6		TRIZEPS6		2740
+msm7x30_fluid		MACH_MSM7X30_FLUID	MSM7X30_FLUID		2741
+nedap9263		MACH_NEDAP9263		NEDAP9263		2742
+netgear_ms2110		MACH_NETGEAR_MS2110	NETGEAR_MS2110		2743
+bmx			MACH_BMX		BMX			2744
+netstream		MACH_NETSTREAM		NETSTREAM		2745
+vpnext_rcu		MACH_VPNEXT_RCU		VPNEXT_RCU		2746
+vpnext_mpu		MACH_VPNEXT_MPU		VPNEXT_MPU		2747
+bcmring_tablet_v1	MACH_BCMRING_TABLET_V1	BCMRING_TABLET_V1	2748
+sgarm10			MACH_SGARM10		SGARM10			2749
+cm_t3517		MACH_CM_T3517		CM_T3517		2750
+omap3_cps		MACH_OMAP3_CPS		OMAP3_CPS		2751
+axar1500_receiver	MACH_AXAR1500_RECEIVER	AXAR1500_RECEIVER	2752
+wbd222			MACH_WBD222		WBD222			2753
+mt65xx			MACH_MT65XX		MT65XX			2754
+msm8x60_surf		MACH_MSM8X60_SURF	MSM8X60_SURF		2755
+msm8x60_sim		MACH_MSM8X60_SIM	MSM8X60_SIM		2756
+vmc300			MACH_VMC300		VMC300			2757
+tcc8000_sdk		MACH_TCC8000_SDK	TCC8000_SDK		2758
+nanos			MACH_NANOS		NANOS			2759
+stamp9g10		MACH_STAMP9G10		STAMP9G10		2760
+stamp9g45		MACH_STAMP9G45		STAMP9G45		2761
+h6053			MACH_H6053		H6053			2762
+smint01			MACH_SMINT01		SMINT01			2763
+prtlvt2			MACH_PRTLVT2		PRTLVT2			2764
+ap420			MACH_AP420		AP420			2765
+htcclio			MACH_HTCSHIFT		HTCSHIFT		2766
+davinci_dm365_fc	MACH_DAVINCI_DM365_FC	DAVINCI_DM365_FC	2767
+msm8x55_surf		MACH_MSM8X55_SURF	MSM8X55_SURF		2768
+msm8x55_ffa		MACH_MSM8X55_FFA	MSM8X55_FFA		2769
+esl_vamana		MACH_ESL_VAMANA		ESL_VAMANA		2770
+sbc35			MACH_SBC35		SBC35			2771
+mpx6446			MACH_MPX6446		MPX6446			2772
+oreo_controller		MACH_OREO_CONTROLLER	OREO_CONTROLLER		2773
+kopin_models		MACH_KOPIN_MODELS	KOPIN_MODELS		2774
+ttc_vision2		MACH_TTC_VISION2	TTC_VISION2		2775
+cns3420vb		MACH_CNS3420VB		CNS3420VB		2776
+lpc_evo			MACH_LPC2		LPC2			2777
+olympus			MACH_OLYMPUS		OLYMPUS			2778
+vortex			MACH_VORTEX		VORTEX			2779
+s5pc200			MACH_S5PC200		S5PC200			2780
+ecucore_9263		MACH_ECUCORE_9263	ECUCORE_9263		2781
+smdkc200		MACH_SMDKC200		SMDKC200		2782
+emsiso_sx27		MACH_EMSISO_SX27	EMSISO_SX27		2783
+apx_som9g45_ek		MACH_APX_SOM9G45_EK	APX_SOM9G45_EK		2784
+songshan		MACH_SONGSHAN		SONGSHAN		2785
+tianshan		MACH_TIANSHAN		TIANSHAN		2786
+vpx500			MACH_VPX500		VPX500			2787
+am3517sam		MACH_AM3517SAM		AM3517SAM		2788
+skat91_sim508		MACH_SKAT91_SIM508	SKAT91_SIM508		2789
+skat91_s3e		MACH_SKAT91_S3E		SKAT91_S3E		2790
+omap4_panda		MACH_OMAP4_PANDA	OMAP4_PANDA		2791
+df7220			MACH_DF7220		DF7220			2792
+nemini			MACH_NEMINI		NEMINI			2793
+t8200			MACH_T8200		T8200			2794
+apf51			MACH_APF51		APF51			2795
+dr_rc_unit		MACH_DR_RC_UNIT		DR_RC_UNIT		2796
+bordeaux		MACH_BORDEAUX		BORDEAUX		2797
+catania_b		MACH_CATANIA_B		CATANIA_B		2798
+mx51_ocean		MACH_MX51_OCEAN		MX51_OCEAN		2799
+ti8168evm		MACH_TI8168EVM		TI8168EVM		2800
+neocoreomap		MACH_NEOCOREOMAP	NEOCOREOMAP		2801
+withings_wbp		MACH_WITHINGS_WBP	WITHINGS_WBP		2802
+dbps			MACH_DBPS		DBPS			2803
+at91sam9261		MACH_SBC9261		SBC9261			2804
+pcbfp0001		MACH_PCBFP0001		PCBFP0001		2805
+speedy			MACH_SPEEDY		SPEEDY			2806
+chrysaor		MACH_CHRYSAOR		CHRYSAOR		2807
+tango			MACH_TANGO		TANGO			2808
+synology_dsx11		MACH_SYNOLOGY_DSX11	SYNOLOGY_DSX11		2809
+hanlin_v3ext		MACH_HANLIN_V3EXT	HANLIN_V3EXT		2810
+hanlin_v5		MACH_HANLIN_V5		HANLIN_V5		2811
+hanlin_v3plus		MACH_HANLIN_V3PLUS	HANLIN_V3PLUS		2812
+iriver_story		MACH_IRIVER_STORY	IRIVER_STORY		2813
+irex_iliad		MACH_IREX_ILIAD		IREX_ILIAD		2814
+irex_dr1000		MACH_IREX_DR1000	IREX_DR1000		2815
+teton_bga		MACH_TETON_BGA		TETON_BGA		2816
+snapper9g45		MACH_SNAPPER9G45	SNAPPER9G45		2817
+tam3517			MACH_TAM3517		TAM3517			2818
+pdc100			MACH_PDC100		PDC100			2819
+eukrea_cpuimx25sd	MACH_EUKREA_CPUIMX25	EUKREA_CPUIMX25		2820
+eukrea_cpuimx35sd	MACH_EUKREA_CPUIMX35	EUKREA_CPUIMX35		2821
+eukrea_cpuimx51sd	MACH_EUKREA_CPUIMX51SD	EUKREA_CPUIMX51SD	2822
+eukrea_cpuimx51		MACH_EUKREA_CPUIMX51	EUKREA_CPUIMX51		2823
+p565			MACH_P565		P565			2824
+acer_a4			MACH_ACER_A4		ACER_A4			2825
+davinci_dm368_bip	MACH_DAVINCI_DM368_BIP	DAVINCI_DM368_BIP	2826
+eshare			MACH_ESHARE		ESHARE			2827
+hw_omapl138_europa	MACH_HW_OMAPL138_EUROPA	HW_OMAPL138_EUROPA	2828
+wlbargn			MACH_WLBARGN		WLBARGN			2829
+bm170			MACH_BM170		BM170			2830
+netspace_mini_v2	MACH_NETSPACE_MINI_V2	NETSPACE_MINI_V2	2831
+netspace_plug_v2	MACH_NETSPACE_PLUG_V2	NETSPACE_PLUG_V2	2832
+siemens_l1		MACH_SIEMENS_L1		SIEMENS_L1		2833
+elv_lcu1		MACH_ELV_LCU1		ELV_LCU1		2834
+mcu1			MACH_MCU1		MCU1			2835
+omap3_tao3530		MACH_OMAP3_TAO3530	OMAP3_TAO3530		2836
+omap3_pcutouch		MACH_OMAP3_PCUTOUCH	OMAP3_PCUTOUCH		2837
+smdkc210		MACH_SMDKC210		SMDKC210		2838
+omap3_braillo		MACH_OMAP3_BRAILLO	OMAP3_BRAILLO		2839
+spyplug			MACH_SPYPLUG		SPYPLUG			2840
+ginger			MACH_GINGER		GINGER			2841
+tny_t3530		MACH_TNY_T3530		TNY_T3530		2842
+pca102			MACH_PCA102		PCA102			2843
+spade			MACH_SPADE		SPADE			2844
+mxc25_topaz		MACH_MXC25_TOPAZ	MXC25_TOPAZ		2845
+t5325			MACH_T5325		T5325			2846
+gw2361			MACH_GW2361		GW2361			2847
+elog			MACH_ELOG		ELOG			2848
+income			MACH_INCOME		INCOME			2849
+bcm589x			MACH_BCM589X		BCM589X			2850
+etna			MACH_ETNA		ETNA			2851
+hawks			MACH_HAWKS		HAWKS			2852
+meson			MACH_MESON		MESON			2853
+xsbase255		MACH_XSBASE255		XSBASE255		2854
+pvm2030			MACH_PVM2030		PVM2030			2855
+mioa502			MACH_MIOA502		MIOA502			2856
+vvbox_sdorig2		MACH_VVBOX_SDORIG2	VVBOX_SDORIG2		2857
+vvbox_sdlite2		MACH_VVBOX_SDLITE2	VVBOX_SDLITE2		2858
+vvbox_sdpro4		MACH_VVBOX_SDPRO4	VVBOX_SDPRO4		2859
+htc_spv_m700		MACH_HTC_SPV_M700	HTC_SPV_M700		2860
+mx257sx			MACH_MX257SX		MX257SX			2861
+goni			MACH_GONI		GONI			2862
+msm8x55_svlte_ffa	MACH_MSM8X55_SVLTE_FFA	MSM8X55_SVLTE_FFA	2863
+msm8x55_svlte_surf	MACH_MSM8X55_SVLTE_SURF	MSM8X55_SVLTE_SURF	2864
+quickstep		MACH_QUICKSTEP		QUICKSTEP		2865
+dmw96			MACH_DMW96		DMW96			2866
+hammerhead		MACH_HAMMERHEAD		HAMMERHEAD		2867
+trident			MACH_TRIDENT		TRIDENT			2868
+lightning		MACH_LIGHTNING		LIGHTNING		2869
+iconnect		MACH_ICONNECT		ICONNECT		2870
+autobot			MACH_AUTOBOT		AUTOBOT			2871
+coconut			MACH_COCONUT		COCONUT			2872
+durian			MACH_DURIAN		DURIAN			2873
+cayenne			MACH_CAYENNE		CAYENNE			2874
+fuji			MACH_FUJI		FUJI			2875
+synology_6282		MACH_SYNOLOGY_6282	SYNOLOGY_6282		2876
+em1sy			MACH_EM1SY		EM1SY			2877
+m502			MACH_M502		M502			2878
+matrix518		MACH_MATRIX518		MATRIX518		2879
+tiny_gurnard		MACH_TINY_GURNARD	TINY_GURNARD		2880
+spear1310		MACH_SPEAR1310		SPEAR1310		2881
+bv07			MACH_BV07		BV07			2882
+mxt_td61		MACH_MXT_TD61		MXT_TD61		2883
+openrd_ultimate		MACH_OPENRD_ULTIMATE	OPENRD_ULTIMATE		2884
+devixp			MACH_DEVIXP		DEVIXP			2885
+miccpt			MACH_MICCPT		MICCPT			2886
+mic256			MACH_MIC256		MIC256			2887
+as1167			MACH_AS1167		AS1167			2888
+omap3_ibiza		MACH_OMAP3_IBIZA	OMAP3_IBIZA		2889
+u5500			MACH_U5500		U5500			2890
+davinci_picto		MACH_DAVINCI_PICTO	DAVINCI_PICTO		2891
+mecha			MACH_MECHA		MECHA			2892
+bubba3			MACH_BUBBA3		BUBBA3			2893
+pupitre			MACH_PUPITRE		PUPITRE			2894
+tegra_harmony		MACH_TEGRA_HARMONY	TEGRA_HARMONY		2895
+tegra_vogue		MACH_TEGRA_VOGUE	TEGRA_VOGUE		2896
+tegra_e1165		MACH_TEGRA_E1165	TEGRA_E1165		2897
+simplenet		MACH_SIMPLENET		SIMPLENET		2898
+ec4350tbm		MACH_EC4350TBM		EC4350TBM		2899
+pec_tc			MACH_PEC_TC		PEC_TC			2900
+pec_hc2			MACH_PEC_HC2		PEC_HC2			2901
+esl_mobilis_a		MACH_ESL_MOBILIS_A	ESL_MOBILIS_A		2902
+esl_mobilis_b		MACH_ESL_MOBILIS_B	ESL_MOBILIS_B		2903
+esl_wave_a		MACH_ESL_WAVE_A		ESL_WAVE_A		2904
+esl_wave_b		MACH_ESL_WAVE_B		ESL_WAVE_B		2905
+unisense_mmm		MACH_UNISENSE_MMM	UNISENSE_MMM		2906
+blueshark		MACH_BLUESHARK		BLUESHARK		2907
+e10			MACH_E10		E10			2908
+app3k_robin		MACH_APP3K_ROBIN	APP3K_ROBIN		2909
+pov15hd			MACH_POV15HD		POV15HD			2910
+stella			MACH_STELLA		STELLA			2911
+htc_iolite		MACH_MACH_HTC_IOLITE	MACH_HTC_IOLITE		2912
+linkstation_lschl	MACH_LINKSTATION_LSCHL	LINKSTATION_LSCHL	2913
+netwalker		MACH_NETWALKER		NETWALKER		2914
+acsx106			MACH_ACSX106		ACSX106			2915
+atlas5_c1		MACH_ATLAS5_C1		ATLAS5_C1		2916
+nsb3ast			MACH_NSB3AST		NSB3AST			2917
+gnet_slc		MACH_GNET_SLC		GNET_SLC		2918
+af4000			MACH_AF4000		AF4000			2919
+ark9431			MACH_ARK9431		ARK9431			2920
+fs_s5pc100		MACH_FS_S5PC100		FS_S5PC100		2921
+omap3505nova8		MACH_OMAP3505NOVA8	OMAP3505NOVA8		2922
+omap3621_edp1		MACH_OMAP3621_EDP1	OMAP3621_EDP1		2923
+oratisaes		MACH_ORATISAES		ORATISAES		2924
+smdkv310		MACH_SMDKV310		SMDKV310		2925
+siemens_l0		MACH_SIEMENS_L0		SIEMENS_L0		2926
+ventana			MACH_VENTANA		VENTANA			2927
+wm8505_7in_netbook	MACH_WM8505_7IN_NETBOOK	WM8505_7IN_NETBOOK	2928
+ec4350sdb		MACH_EC4350SDB		EC4350SDB		2929
+mimas			MACH_MIMAS		MIMAS			2930
+titan			MACH_TITAN		TITAN			2931
+craneboard		MACH_CRANEBOARD		CRANEBOARD		2932
+es2440			MACH_ES2440		ES2440			2933
+najay_a9263		MACH_NAJAY_A9263	NAJAY_A9263		2934
+htctornado		MACH_HTCTORNADO		HTCTORNADO		2935
+dimm_mx257		MACH_DIMM_MX257		DIMM_MX257		2936
+jigen301		MACH_JIGEN		JIGEN			2937
+smdk6450		MACH_SMDK6450		SMDK6450		2938
+meno_qng		MACH_MENO_QNG		MENO_QNG		2939
+ns2416			MACH_NS2416		NS2416			2940
+rpc353			MACH_RPC353		RPC353			2941
+tq6410			MACH_TQ6410		TQ6410			2942
+sky6410			MACH_SKY6410		SKY6410			2943
+dynasty			MACH_DYNASTY		DYNASTY			2944
+vivo			MACH_VIVO		VIVO			2945
+bury_bl7582		MACH_BURY_BL7582	BURY_BL7582		2946
+bury_bps5270		MACH_BURY_BPS5270	BURY_BPS5270		2947
+basi			MACH_BASI		BASI			2948
+tn200			MACH_TN200		TN200			2949
+c2mmi			MACH_C2MMI		C2MMI			2950
+meson_6236m		MACH_MESON_6236M	MESON_6236M		2951
+meson_8626m		MACH_MESON_8626M	MESON_8626M		2952
+tube			MACH_TUBE		TUBE			2953
+messina			MACH_MESSINA		MESSINA			2954
+mx50_arm2		MACH_MX50_ARM2		MX50_ARM2		2955
-- 
1.5.4.4

