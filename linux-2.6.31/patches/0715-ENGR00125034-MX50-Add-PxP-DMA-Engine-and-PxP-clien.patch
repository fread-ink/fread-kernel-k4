From 305ef9da35e32363a826a8ff7110f73b3aa0e4d0 Mon Sep 17 00:00:00 2001
From: Robby Cai <R63905@freescale.com>
Date: Sat, 10 Jul 2010 06:37:42 +0800
Subject: [PATCH] ENGR00125034 [MX50] Add PxP DMA-Engine and PxP client driver

Use Common DMA-Engine framework to implement ePXP driver
Use a dma client driver to access ePxP staff.

Signed-off-by: Danny Nold <dannynold@freescale.com>
Signed-off-by: Robby Cai <R63905@freescale.com>
---
 drivers/dma/Kconfig          |    9 +
 drivers/dma/Makefile         |    1 +
 drivers/dma/pxp/Makefile     |    2 +
 drivers/dma/pxp/pxp_device.c |  513 ++++++++++++++++
 drivers/dma/pxp/pxp_dma.c    | 1365 ++++++++++++++++++++++++++++++++++++++++++
 drivers/dma/pxp/regs-pxp.h   |  949 +++++++++++++++++++++++++++++
 include/linux/pxp_dma.h      |  221 +++++++
 7 files changed, 3060 insertions(+), 0 deletions(-)

diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 81e1020..27e06eb 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -89,6 +89,15 @@ config MX3_IPU_IRQS
 	  To avoid bloating the irq_desc[] array we allocate a sufficient
 	  number of IRQ slots and map them dynamically to specific sources.
 
+config MXC_PXP
+    bool "MXC PxP support"
+    select DMA_ENGINE
+
+config MXC_PXP_CLIENT_DEVICE
+    bool "MXC PxP Client Device"
+    default y
+    depends on MXC_PXP
+
 config TXX9_DMAC
 	tristate "Toshiba TXx9 SoC DMA support"
 	depends on MACH_TX49XX || MACH_TX39XX
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 40e1e00..72c212a 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -9,4 +9,5 @@ obj-$(CONFIG_MV_XOR) += mv_xor.o
 obj-$(CONFIG_DW_DMAC) += dw_dmac.o
 obj-$(CONFIG_AT_HDMAC) += at_hdmac.o
 obj-$(CONFIG_MX3_IPU) += ipu/
+obj-$(CONFIG_MXC_PXP) += pxp/
 obj-$(CONFIG_TXX9_DMAC) += txx9dmac.o
diff --git a/drivers/dma/pxp/Makefile b/drivers/dma/pxp/Makefile
new file mode 100644
index 0000000..88e51a7
--- /dev/null
+++ b/drivers/dma/pxp/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MXC_PXP) += pxp_dma.o
+obj-$(CONFIG_MXC_PXP_CLIENT_DEVICE) += pxp_device.o
diff --git a/drivers/dma/pxp/pxp_device.c b/drivers/dma/pxp/pxp_device.c
new file mode 100644
index 0000000..afd08ac
--- /dev/null
+++ b/drivers/dma/pxp/pxp_device.c
@@ -0,0 +1,513 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+
+#include <asm/atomic.h>
+
+static atomic_t open_count = ATOMIC_INIT(0);
+
+static DEFINE_SPINLOCK(pxp_mem_lock);
+static DEFINE_SPINLOCK(pxp_chan_lock);
+static LIST_HEAD(head);
+static LIST_HEAD(list);
+static struct pxp_irq_info irq_info[NR_PXP_VIRT_CHANNEL];
+
+struct pxp_chan_handle {
+	int chan_id;
+	int hist_status;
+};
+
+/* To track the allocated memory buffer */
+struct memalloc_record {
+	struct list_head list;
+	struct pxp_mem_desc mem;
+};
+
+struct pxp_chan_info {
+	int chan_id;
+	struct dma_chan *dma_chan;
+	struct list_head list;
+};
+
+static int pxp_alloc_dma_buffer(struct pxp_mem_desc *mem)
+{
+	mem->cpu_addr = (unsigned long)
+	    dma_alloc_coherent(NULL, PAGE_ALIGN(mem->size),
+			       (dma_addr_t *) (&mem->phys_addr),
+			       GFP_DMA | GFP_KERNEL);
+	pr_debug("[ALLOC] mem alloc phys_addr = 0x%x\n", mem->phys_addr);
+	if ((void *)(mem->cpu_addr) == NULL) {
+		printk(KERN_ERR "Physical memory allocation error!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void pxp_free_dma_buffer(struct pxp_mem_desc *mem)
+{
+	if (mem->cpu_addr != 0) {
+		dma_free_coherent(0, PAGE_ALIGN(mem->size),
+				  (void *)mem->cpu_addr, mem->phys_addr);
+	}
+}
+
+static int pxp_free_buffers(void)
+{
+	struct memalloc_record *rec, *n;
+	struct pxp_mem_desc mem;
+
+	list_for_each_entry_safe(rec, n, &head, list) {
+		mem = rec->mem;
+		if (mem.cpu_addr != 0) {
+			pxp_free_dma_buffer(&mem);
+			pr_debug("[FREE] freed paddr=0x%08X\n", mem.phys_addr);
+			/* delete from list */
+			list_del(&rec->list);
+			kfree(rec);
+		}
+	}
+
+	return 0;
+}
+
+/* Callback function triggered after PxP receives an EOF interrupt */
+static void pxp_dma_done(void *arg)
+{
+	struct pxp_tx_desc *tx_desc = to_tx_desc(arg);
+	struct dma_chan *chan = tx_desc->txd.chan;
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	int chan_id = pxp_chan->dma_chan.chan_id;
+
+	pr_debug("DMA Done ISR, chan_id %d\n", chan_id);
+
+	irq_info[chan_id].irq_pending++;
+	irq_info[chan_id].hist_status = tx_desc->hist_status;
+
+	wake_up_interruptible(&(irq_info[chan_id].waitq));
+}
+
+static int pxp_ioc_config_chan(unsigned long arg)
+{
+	struct scatterlist sg[3];
+	struct pxp_tx_desc *desc;
+	struct dma_async_tx_descriptor *txd;
+	struct pxp_chan_info *info;
+	struct pxp_config_data pxp_conf;
+	dma_cookie_t cookie;
+	int chan_id;
+	int i, length, ret;
+
+	ret = copy_from_user(&pxp_conf,
+			     (struct pxp_config_data *)arg,
+			     sizeof(struct pxp_config_data));
+	if (ret)
+		return -EFAULT;
+
+	chan_id = pxp_conf.chan_id;
+	if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+		return -ENODEV;
+
+	init_waitqueue_head(&(irq_info[chan_id].waitq));
+
+	/* Fixme */
+	mdelay(100);
+	/* find the channel */
+	spin_lock(&pxp_chan_lock);
+	list_for_each_entry(info, &list, list) {
+		if (info->dma_chan->chan_id == chan_id)
+			break;
+	}
+	spin_unlock(&pxp_chan_lock);
+
+	sg_init_table(sg, 3);
+
+	txd =
+	    info->dma_chan->device->device_prep_slave_sg(info->dma_chan,
+							 sg, 3,
+							 DMA_TO_DEVICE,
+							 DMA_PREP_INTERRUPT);
+	if (!txd) {
+		pr_err("Error preparing a DMA transaction descriptor.\n");
+		return -EIO;
+	}
+
+	txd->callback_param = txd;
+	txd->callback = pxp_dma_done;
+
+	desc = to_tx_desc(txd);
+
+	length = desc->len;
+	for (i = 0; i < length; i++) {
+		if (i == 0) {	/* S0 */
+			memcpy(&desc->proc_data,
+			       &pxp_conf.proc_data,
+			       sizeof(struct pxp_proc_data));
+			memcpy(&desc->layer_param.s0_param,
+			       &pxp_conf.s0_param,
+			       sizeof(struct pxp_layer_param));
+		} else if (i == 1) {	/* Output */
+			memcpy(&desc->layer_param.out_param,
+			       &pxp_conf.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {
+			/* OverLay */
+			memcpy(&desc->layer_param.ol_param,
+			       &pxp_conf.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		desc = desc->next;
+	}
+
+	cookie = txd->tx_submit(txd);
+	if (cookie < 0) {
+		pr_err("Error tx_submit\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int pxp_device_open(struct inode *inode, struct file *filp)
+{
+	atomic_inc(&open_count);
+
+	return 0;
+}
+
+static int pxp_device_release(struct inode *inode, struct file *filp)
+{
+	if (atomic_dec_and_test(&open_count))
+		pxp_free_buffers();
+
+	return 0;
+}
+
+static int pxp_device_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct memalloc_record *rec, *n;
+	int request_size, found;
+
+	request_size = vma->vm_end - vma->vm_start;
+	found = 0;
+
+	pr_debug("start=0x%x, pgoff=0x%x, size=0x%x\n",
+		 (unsigned int)(vma->vm_start), (unsigned int)(vma->vm_pgoff),
+		 request_size);
+
+	spin_lock(&pxp_mem_lock);
+	list_for_each_entry_safe(rec, n, &head, list) {
+		if (rec->mem.phys_addr == (vma->vm_pgoff << PAGE_SHIFT) &&
+			(rec->mem.size <= request_size)) {
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock(&pxp_mem_lock);
+
+	if (found == 0)
+		return -ENOMEM;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			       request_size, vma->vm_page_prot) ? -EAGAIN : 0;
+}
+
+static int pxp_device_ioctl(struct inode *inode, struct file *filp,
+			    unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case PXP_IOC_GET_CHAN:
+		{
+			struct pxp_chan_info *info;
+			dma_cap_mask_t mask;
+
+			pr_debug("drv: PXP_IOC_GET_CHAN Line %d\n", __LINE__);
+			info = kzalloc(sizeof(*info), GFP_KERNEL);
+			if (!info) {
+				pr_err("%d: alloc err\n", __LINE__);
+				return -ENOMEM;
+			}
+
+			dma_cap_zero(mask);
+			dma_cap_set(DMA_SLAVE, mask);
+			dma_cap_set(DMA_PRIVATE, mask);
+			info->dma_chan = dma_request_channel(mask, NULL, NULL);
+			if (!info->dma_chan) {
+				pr_err("Unsccessfully received channel!\n");
+				kfree(info);
+				return -EBUSY;
+			}
+			pr_debug("Successfully received channel."
+				 "chan_id %d\n", info->dma_chan->chan_id);
+
+			spin_lock(&pxp_chan_lock);
+			list_add_tail(&info->list, &list);
+			spin_unlock(&pxp_chan_lock);
+
+			if (put_user
+			    (info->dma_chan->chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			break;
+		}
+	case PXP_IOC_PUT_CHAN:
+		{
+			int chan_id;
+			struct pxp_chan_info *info;
+
+			if (get_user(chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+				return -ENODEV;
+
+			spin_lock(&pxp_chan_lock);
+			list_for_each_entry(info, &list, list) {
+				if (info->dma_chan->chan_id == chan_id)
+					break;
+			}
+			spin_unlock(&pxp_chan_lock);
+
+			pr_debug("%d release chan_id %d\n", __LINE__,
+				 info->dma_chan->chan_id);
+			/* REVISIT */
+			dma_release_channel(info->dma_chan);
+			spin_lock(&pxp_chan_lock);
+			list_del_init(&info->list);
+			spin_unlock(&pxp_chan_lock);
+			kfree(info);
+
+			break;
+		}
+	case PXP_IOC_CONFIG_CHAN:
+		{
+
+			int ret;
+
+			ret = pxp_ioc_config_chan(arg);
+			if (ret)
+				return ret;
+
+			break;
+		}
+	case PXP_IOC_START_CHAN:
+		{
+			struct pxp_chan_info *info;
+			int chan_id;
+
+			if (get_user(chan_id, (u32 __user *) arg))
+				return -EFAULT;
+
+			/* find the channel */
+			spin_lock(&pxp_chan_lock);
+			list_for_each_entry(info, &list, list) {
+				if (info->dma_chan->chan_id == chan_id)
+					break;
+			}
+			spin_unlock(&pxp_chan_lock);
+
+			dma_async_issue_pending(info->dma_chan);
+
+			break;
+		}
+	case PXP_IOC_GET_PHYMEM:
+		{
+			struct memalloc_record *rec;
+
+			rec = kzalloc(sizeof(*rec), GFP_KERNEL);
+			if (!rec)
+				return -ENOMEM;
+
+			ret = copy_from_user(&(rec->mem),
+					     (struct pxp_mem_desc *)arg,
+					     sizeof(struct pxp_mem_desc));
+			if (ret) {
+				kfree(rec);
+				return -EFAULT;
+			}
+
+			pr_debug("[ALLOC] mem alloc size = 0x%x\n",
+				 rec->mem.size);
+
+			ret = pxp_alloc_dma_buffer(&(rec->mem));
+			if (ret == -1) {
+				kfree(rec);
+				printk(KERN_ERR
+				       "Physical memory allocation error!\n");
+				break;
+			}
+			ret = copy_to_user((void __user *)arg, &(rec->mem),
+					   sizeof(struct pxp_mem_desc));
+			if (ret) {
+				kfree(rec);
+				ret = -EFAULT;
+				break;
+			}
+
+			spin_lock(&pxp_mem_lock);
+			list_add(&rec->list, &head);
+			spin_unlock(&pxp_mem_lock);
+
+			break;
+		}
+	case PXP_IOC_PUT_PHYMEM:
+		{
+			struct memalloc_record *rec, *n;
+			struct pxp_mem_desc pxp_mem;
+
+			ret = copy_from_user(&pxp_mem,
+					     (struct pxp_mem_desc *)arg,
+					     sizeof(struct pxp_mem_desc));
+			if (ret)
+				return -EACCES;
+
+			pr_debug("[FREE] mem freed cpu_addr = 0x%x\n",
+				 pxp_mem.cpu_addr);
+			if ((void *)pxp_mem.cpu_addr != NULL)
+				pxp_free_dma_buffer(&pxp_mem);
+
+			spin_lock(&pxp_mem_lock);
+			list_for_each_entry_safe(rec, n, &head, list) {
+				if (rec->mem.cpu_addr == pxp_mem.cpu_addr) {
+					/* delete from list */
+					list_del(&rec->list);
+					kfree(rec);
+					break;
+				}
+			}
+			spin_unlock(&pxp_mem_lock);
+
+			break;
+		}
+	case PXP_IOC_WAIT4CMPLT:
+		{
+			struct pxp_chan_handle chan_handle;
+			int ret, chan_id;
+
+			ret = copy_from_user(&chan_handle,
+					     (struct pxp_chan_handle *)arg,
+					     sizeof(struct pxp_chan_handle));
+			if (ret)
+				return -EFAULT;
+
+			chan_id = chan_handle.chan_id;
+			if (chan_id < 0 || chan_id >= NR_PXP_VIRT_CHANNEL)
+				return -ENODEV;
+
+			if (!wait_event_interruptible_timeout
+			    (irq_info[chan_id].waitq,
+			     (irq_info[chan_id].irq_pending != 0), 2 * HZ)) {
+				pr_warning("pxp blocking: timeout.\n");
+				return -ETIME;
+			} else if (signal_pending(current)) {
+				printk(KERN_WARNING
+				       "pxp interrupt received.\n");
+				return -ERESTARTSYS;
+			} else
+				irq_info[chan_id].irq_pending--;
+
+			chan_handle.hist_status = irq_info[chan_id].hist_status;
+			ret = copy_to_user((struct pxp_chan_handle *)arg,
+					   &chan_handle,
+					   sizeof(struct pxp_chan_handle));
+			if (ret)
+				return -EFAULT;
+			break;
+		}
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct file_operations pxp_device_fops = {
+	.open = pxp_device_open,
+	.release = pxp_device_release,
+	.ioctl = pxp_device_ioctl,
+	.mmap = pxp_device_mmap,
+};
+
+static struct miscdevice pxp_device_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "pxp_device",
+	.fops = &pxp_device_fops,
+};
+
+static int __devinit pxp_device_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	/* PxP DMA interface */
+	dmaengine_get();
+
+	ret = misc_register(&pxp_device_miscdev);
+	if (ret)
+		return ret;
+
+	pr_debug("PxP_Device Probe Successfully\n");
+	return 0;
+}
+
+static int __devexit pxp_device_remove(struct platform_device *pdev)
+{
+	misc_deregister(&pxp_device_miscdev);
+
+	dmaengine_put();
+
+	return 0;
+}
+
+static struct platform_driver pxp_device = {
+	.probe = pxp_device_probe,
+	.remove = __exit_p(pxp_device_remove),
+	.driver = {
+		   .name = "pxp-device",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init pxp_device_init(void)
+{
+	return platform_driver_register(&pxp_device);
+}
+
+static void __exit pxp_device_exit(void)
+{
+	platform_driver_unregister(&pxp_device);
+}
+
+module_init(pxp_device_init);
+module_exit(pxp_device_exit);
+
+MODULE_DESCRIPTION("i.MX PxP client driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/pxp/pxp_dma.c b/drivers/dma/pxp/pxp_dma.c
new file mode 100644
index 0000000..e418f6c
--- /dev/null
+++ b/drivers/dma/pxp/pxp_dma.c
@@ -0,0 +1,1365 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * Based on STMP378X PxP driver
+ * Copyright 2008-2009 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/dmaengine.h>
+#include <linux/pxp_dma.h>
+#include <linux/clk.h>
+
+#include "regs-pxp.h"
+
+#define	PXP_DOWNSCALE_THRESHOLD		0x4000
+
+static LIST_HEAD(head);
+
+struct pxp_dma {
+	struct dma_device dma;
+};
+
+struct pxps {
+	struct platform_device *pdev;
+	struct clk *clk;
+	void __iomem *base;
+	int irq;		/* PXP IRQ to the CPU */
+
+	spinlock_t lock;
+	struct mutex mutex;
+
+	struct device *dev;
+	struct pxp_dma pxp_dma;
+	struct pxp_channel channel[NR_PXP_VIRT_CHANNEL];
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
+
+	/* describes most recent processing configuration */
+	struct pxp_config_data pxp_conf_state;
+};
+
+#define to_pxp_dma(d) container_of(d, struct pxp_dma, dma)
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+#define to_pxp(id) container_of(id, struct pxps, pxp_dma)
+
+#define PXP_DEF_BUFS	2
+#define PXP_MIN_PIX	8
+
+static uint32_t pxp_s0_formats[] = {
+	PXP_PIX_FMT_RGB24,
+	PXP_PIX_FMT_RGB565,
+	PXP_PIX_FMT_RGB555,
+	PXP_PIX_FMT_YUV420P,
+	PXP_PIX_FMT_YUV422P,
+};
+
+/*
+ * PXP common functions
+ */
+static void dump_pxp_reg(struct pxps *pxp)
+{
+	dev_err(pxp->dev, "PXP_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CTRL));
+	dev_err(pxp->dev, "PXP_STAT 0x%x",
+		__raw_readl(pxp->base + HW_PXP_STAT));
+	dev_err(pxp->dev, "PXP_OUTBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUTBUF));
+	dev_err(pxp->dev, "PXP_OUTBUF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUTBUF2));
+	dev_err(pxp->dev, "PXP_OUTSIZE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OUTSIZE));
+	dev_err(pxp->dev, "PXP_S0BUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0BUF));
+	dev_err(pxp->dev, "PXP_S0UBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0UBUF));
+	dev_err(pxp->dev, "PXP_S0VBUF 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0VBUF));
+	dev_err(pxp->dev, "PXP_S0PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0PARAM));
+	dev_err(pxp->dev, "PXP_S0BACKGROUND 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0BACKGROUND));
+	dev_err(pxp->dev, "PXP_S0CROP 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0CROP));
+	dev_err(pxp->dev, "PXP_S0SCALE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_S0SCALE));
+	dev_err(pxp->dev, "PXP_OLn 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OLn(0)));
+	dev_err(pxp->dev, "PXP_OLnSIZE 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OLnSIZE(0)));
+	dev_err(pxp->dev, "PXP_OLnPARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_OLnPARAM(0)));
+	dev_err(pxp->dev, "PXP_CSCCOEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSCCOEF0));
+	dev_err(pxp->dev, "PXP_CSC2CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2CTRL));
+	dev_err(pxp->dev, "PXP_CSC2COEF0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF0));
+	dev_err(pxp->dev, "PXP_CSC2COEF1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF1));
+	dev_err(pxp->dev, "PXP_CSC2COEF2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF2));
+	dev_err(pxp->dev, "PXP_CSC2COEF3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF3));
+	dev_err(pxp->dev, "PXP_CSC2COEF4 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF4));
+	dev_err(pxp->dev, "PXP_CSC2COEF5 0x%x",
+		__raw_readl(pxp->base + HW_PXP_CSC2COEF5));
+	dev_err(pxp->dev, "PXP_LUT_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_LUT_CTRL));
+	dev_err(pxp->dev, "PXP_LUT 0x%x", __raw_readl(pxp->base + HW_PXP_LUT));
+	dev_err(pxp->dev, "PXP_HIST_CTRL 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST_CTRL));
+	dev_err(pxp->dev, "PXP_HIST2_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST2_PARAM));
+	dev_err(pxp->dev, "PXP_HIST4_PARAM 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST4_PARAM));
+	dev_err(pxp->dev, "PXP_HIST8_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM0));
+	dev_err(pxp->dev, "PXP_HIST8_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST8_PARAM1));
+	dev_err(pxp->dev, "PXP_HIST16_PARAM0 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM0));
+	dev_err(pxp->dev, "PXP_HIST16_PARAM1 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM1));
+	dev_err(pxp->dev, "PXP_HIST16_PARAM2 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM2));
+	dev_err(pxp->dev, "PXP_HIST16_PARAM3 0x%x",
+		__raw_readl(pxp->base + HW_PXP_HIST16_PARAM3));
+}
+
+static bool is_yuv(pix_fmt)
+{
+	if ((pix_fmt == PXP_PIX_FMT_YUYV) |
+	    (pix_fmt == PXP_PIX_FMT_UYVY) |
+	    (pix_fmt == PXP_PIX_FMT_Y41P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV444) |
+	    (pix_fmt == PXP_PIX_FMT_NV12) |
+	    (pix_fmt == PXP_PIX_FMT_GREY) |
+	    (pix_fmt == PXP_PIX_FMT_YVU410P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV410P) |
+	    (pix_fmt == PXP_PIX_FMT_YVU420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV420P2) |
+	    (pix_fmt == PXP_PIX_FMT_YVU422P) |
+	    (pix_fmt == PXP_PIX_FMT_YUV422P)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void pxp_set_ctrl(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 ctrl;
+	u32 fmt_ctrl;
+
+	/* Configure S0 input format */
+	switch (pxp_conf->s0_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__YUV420;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_CTRL_S0_FORMAT__YUV422;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+	ctrl = BF_PXP_CTRL_S0_FORMAT(fmt_ctrl);
+
+	/* Configure output format based on out_channel format */
+	switch (pxp_conf->out_param.pixel_fmt) {
+	case PXP_PIX_FMT_RGB24:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__RGB888;
+		break;
+	case PXP_PIX_FMT_RGB565:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__RGB565;
+		break;
+	case PXP_PIX_FMT_RGB555:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__RGB555;
+		break;
+	case PXP_PIX_FMT_YUV420P:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P420;
+		break;
+	case PXP_PIX_FMT_YUV422P:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P422;
+		break;
+	case PXP_PIX_FMT_GREY:
+		fmt_ctrl = BV_PXP_CTRL_OUTBUF_FORMAT__MONOC8;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+	ctrl |= BF_PXP_CTRL_OUTBUF_FORMAT(fmt_ctrl);
+
+	ctrl |= BM_PXP_CTRL_CROP;
+
+	if (proc_data->scaling)
+		ctrl |= BM_PXP_CTRL_SCALE;
+	if (proc_data->vflip)
+		ctrl |= BM_PXP_CTRL_VFLIP;
+	if (proc_data->hflip)
+		ctrl |= BM_PXP_CTRL_HFLIP;
+	if (proc_data->rotate)
+		ctrl |= BF_PXP_CTRL_ROTATE(proc_data->rotate / 90);
+
+	__raw_writel(ctrl, pxp->base + HW_PXP_CTRL);
+}
+
+static int pxp_start(struct pxps *pxp)
+{
+	__raw_writel(BM_PXP_CTRL_IRQ_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+	__raw_writel(BM_PXP_CTRL_ENABLE, pxp->base + HW_PXP_CTRL_SET);
+
+	return 0;
+}
+
+static void pxp_set_outbuf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	__raw_writel(out_params->paddr, pxp->base + HW_PXP_OUTBUF);
+
+	__raw_writel(BF_PXP_OUTSIZE_WIDTH(out_params->width) |
+		     BF_PXP_OUTSIZE_HEIGHT(out_params->height),
+		     pxp->base + HW_PXP_OUTSIZE);
+}
+
+static void pxp_set_s0colorkey(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (s0_params->color_key == -1) {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_S0COLORKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_S0COLORKEYHIGH);
+	} else {
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_S0COLORKEYLOW);
+		__raw_writel(s0_params->color_key,
+			     pxp->base + HW_PXP_S0COLORKEYHIGH);
+	}
+}
+
+static void pxp_set_olcolorkey(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[layer_no];
+
+	/* Low and high are set equal. V4L does not allow a chromakey range */
+	if (ol_params->color_key_enable != 0 && ol_params->color_key != -1) {
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_OLCOLORKEYLOW);
+		__raw_writel(ol_params->color_key,
+			     pxp->base + HW_PXP_OLCOLORKEYHIGH);
+	} else {
+		/* disable color key */
+		__raw_writel(0xFFFFFF, pxp->base + HW_PXP_OLCOLORKEYLOW);
+		__raw_writel(0, pxp->base + HW_PXP_OLCOLORKEYHIGH);
+	}
+}
+
+static void pxp_set_oln(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	dma_addr_t phys_addr = olparams_data->paddr;
+	__raw_writel(phys_addr, pxp->base + HW_PXP_OLn(layer_no));
+
+	/* Fixme */
+	__raw_writel(BF_PXP_OLnSIZE_WIDTH(olparams_data->width >> 3) |
+		     BF_PXP_OLnSIZE_HEIGHT(olparams_data->height >> 3),
+		     pxp->base + HW_PXP_OLnSIZE(layer_no));
+}
+
+static void pxp_set_olparam(int layer_no, struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *olparams_data = &pxp_conf->ol_param[layer_no];
+	u32 olparam;
+
+	olparam = BF_PXP_OLnPARAM_ALPHA(olparams_data->global_alpha);
+	if (olparams_data->pixel_fmt == PXP_PIX_FMT_RGB24)
+		olparam |=
+		    BF_PXP_OLnPARAM_FORMAT(BV_PXP_OLnPARAM_FORMAT__RGB888);
+	else
+		olparam |=
+		    BF_PXP_OLnPARAM_FORMAT(BV_PXP_OLnPARAM_FORMAT__RGB565);
+	if (olparams_data->global_alpha)
+		olparam |=
+		    BF_PXP_OLnPARAM_ALPHA_CNTL
+		    (BV_PXP_OLnPARAM_ALPHA_CNTL__Override);
+	if (olparams_data->color_key_enable)
+		olparam |= BM_PXP_OLnPARAM_ENABLE_COLORKEY;
+	if (olparams_data->combine_enable)
+		olparam |= BM_PXP_OLnPARAM_ENABLE;
+	__raw_writel(olparam, pxp->base + HW_PXP_OLnPARAM(layer_no));
+}
+
+static void pxp_set_s0param(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0params_data = &pxp_conf->s0_param;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 s0param;
+
+	s0param = BF_PXP_S0PARAM_XBASE(proc_data->drect.left >> 3);
+	s0param |= BF_PXP_S0PARAM_YBASE(proc_data->drect.top >> 3);
+	s0param |= BF_PXP_S0PARAM_WIDTH(s0params_data->width >> 3);
+	s0param |= BF_PXP_S0PARAM_HEIGHT(s0params_data->height >> 3);
+	__raw_writel(s0param, pxp->base + HW_PXP_S0PARAM);
+}
+
+static void pxp_set_s0crop(struct pxps *pxp)
+{
+	u32 s0crop;
+	struct pxp_proc_data *proc_data = &pxp->pxp_conf_state.proc_data;
+
+	s0crop = BF_PXP_S0CROP_XBASE(proc_data->srect.left >> 3);
+	s0crop |= BF_PXP_S0CROP_YBASE(proc_data->srect.top >> 3);
+	s0crop |= BF_PXP_S0CROP_WIDTH(proc_data->drect.width >> 3);
+	s0crop |= BF_PXP_S0CROP_HEIGHT(proc_data->drect.height >> 3);
+	__raw_writel(s0crop, pxp->base + HW_PXP_S0CROP);
+}
+
+static int pxp_set_scaling(struct pxps *pxp)
+{
+	int ret = 0;
+	u32 xscale, yscale, s0scale;
+	struct pxp_proc_data *proc_data = &pxp->pxp_conf_state.proc_data;
+	struct pxp_layer_param *s0params_data = &pxp->pxp_conf_state.s0_param;
+
+	if ((s0params_data->pixel_fmt != PXP_PIX_FMT_YUV420P) &&
+	    (s0params_data->pixel_fmt != PXP_PIX_FMT_YUV422P)) {
+		proc_data->scaling = 0;
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if ((proc_data->srect.width == proc_data->drect.width) &&
+	    (proc_data->srect.height == proc_data->drect.height)) {
+		proc_data->scaling = 0;
+		__raw_writel(0x10001000, pxp->base + HW_PXP_S0SCALE);
+		goto out;
+	}
+
+	proc_data->scaling = 1;
+	xscale = proc_data->srect.width * 0x1000 / proc_data->drect.width;
+	yscale = proc_data->srect.height * 0x1000 / proc_data->drect.height;
+	if (xscale > PXP_DOWNSCALE_THRESHOLD)
+		xscale = PXP_DOWNSCALE_THRESHOLD;
+	if (yscale > PXP_DOWNSCALE_THRESHOLD)
+		yscale = PXP_DOWNSCALE_THRESHOLD;
+	s0scale = BF_PXP_S0SCALE_YSCALE(yscale) | BF_PXP_S0SCALE_XSCALE(xscale);
+	__raw_writel(s0scale, pxp->base + HW_PXP_S0SCALE);
+
+out:
+	pxp_set_ctrl(pxp);
+
+	return ret;
+}
+
+static void pxp_set_bg(struct pxps *pxp)
+{
+	__raw_writel(pxp->pxp_conf_state.proc_data.bgcolor,
+		     pxp->base + HW_PXP_S0BACKGROUND);
+}
+
+static void pxp_set_lut(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	u32 reg_val;
+	int i;
+
+	if (pxp_conf->proc_data.lut_transform == PXP_LUT_NONE) {
+		__raw_writel(BM_PXP_LUT_CTRL_BYPASS,
+			     pxp->base + HW_PXP_LUT_CTRL);
+	} else if (pxp_conf->proc_data.lut_transform == PXP_LUT_INVERT) {
+		/* Fill out LUT table with 8-bit inverted values */
+
+		/* Initialize LUT address to 0 and clear bypass bit */
+		__raw_writel(0, pxp->base + HW_PXP_LUT_CTRL);
+
+		/* LUT address pointer auto-increments after each data write */
+		for (i = 0; i < 256; i++) {
+			reg_val =
+			    __raw_readl(pxp->base +
+					HW_PXP_LUT_CTRL) & BM_PXP_LUT_CTRL_ADDR;
+			reg_val = ~reg_val & BM_PXP_LUT_DATA;
+			__raw_writel(reg_val, pxp->base + HW_PXP_LUT);
+		}
+	}
+}
+
+static void pxp_set_csc(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_layer_param *ol_params = &pxp_conf->ol_param[0];
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+
+	bool input_is_YUV = is_yuv(s0_params->pixel_fmt);
+	bool output_is_YUV = is_yuv(out_params->pixel_fmt);
+
+	if (input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = YUV, Output = YUV
+		 * No CSC unless we need to do combining
+		 */
+		if (ol_params->combine_enable) {
+			/* Must convert to RGB for combining with RGB overlay */
+
+			/* CSC1 - YUV->RGB */
+			__raw_writel(0x04030000, pxp->base + HW_PXP_CSCCOEF0);
+			__raw_writel(0x01230208, pxp->base + HW_PXP_CSCCOEF1);
+			__raw_writel(0x076b079c, pxp->base + HW_PXP_CSCCOEF2);
+
+			/* CSC2 - RGB->YUV */
+			__raw_writel(0x4, pxp->base + HW_PXP_CSC2CTRL);
+			__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2COEF0);
+			__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2COEF1);
+			__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2COEF2);
+			__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2COEF3);
+			__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2COEF4);
+			__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2COEF5);
+		} else {
+			/* Input & Output both YUV, so bypass both CSCs */
+
+			/* CSC1 - Bypass */
+			__raw_writel(0x40000000, pxp->base + HW_PXP_CSCCOEF0);
+
+			/* CSC2 - Bypass */
+			__raw_writel(0x1, pxp->base + HW_PXP_CSC2CTRL);
+		}
+	} else if (input_is_YUV && !output_is_YUV) {
+		/*
+		 * Input = YUV, Output = RGB
+		 * Use CSC1 to convert to RGB
+		 */
+
+		/* CSC1 - YUV->RGB */
+		__raw_writel(0x04030000, pxp->base + HW_PXP_CSCCOEF0);
+		__raw_writel(0x01230208, pxp->base + HW_PXP_CSCCOEF1);
+		__raw_writel(0x076b079c, pxp->base + HW_PXP_CSCCOEF2);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2CTRL);
+	} else if (!input_is_YUV && output_is_YUV) {
+		/*
+		 * Input = RGB, Output = YUV
+		 * Use CSC2 to convert to YUV
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSCCOEF0);
+
+		/* CSC2 - RGB->YUV */
+		__raw_writel(0x4, pxp->base + HW_PXP_CSC2CTRL);
+		__raw_writel(0x0096004D, pxp->base + HW_PXP_CSC2COEF0);
+		__raw_writel(0x05DA001D, pxp->base + HW_PXP_CSC2COEF1);
+		__raw_writel(0x007005B6, pxp->base + HW_PXP_CSC2COEF2);
+		__raw_writel(0x057C009E, pxp->base + HW_PXP_CSC2COEF3);
+		__raw_writel(0x000005E6, pxp->base + HW_PXP_CSC2COEF4);
+		__raw_writel(0x00000000, pxp->base + HW_PXP_CSC2COEF5);
+	} else {
+		/*
+		 * Input = RGB, Output = RGB
+		 * Input & Output both RGB, so bypass both CSCs
+		 */
+
+		/* CSC1 - Bypass */
+		__raw_writel(0x40000000, pxp->base + HW_PXP_CSCCOEF0);
+
+		/* CSC2 - Bypass */
+		__raw_writel(0x1, pxp->base + HW_PXP_CSC2CTRL);
+	}
+
+	/* YCrCb colorspace */
+	/* Not sure when we use this...no YCrCb formats are defined for PxP */
+	/*
+	   __raw_writel(0x84ab01f0, HW_PXP_CSCCOEFF0_ADDR);
+	   __raw_writel(0x01230204, HW_PXP_CSCCOEFF1_ADDR);
+	   __raw_writel(0x0730079c, HW_PXP_CSCCOEFF2_ADDR);
+	 */
+
+}
+
+static void pxp_set_s0buf(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	dma_addr_t Y, U, V;
+
+	Y = s0_params->paddr;
+	__raw_writel(Y, pxp->base + HW_PXP_S0BUF);
+	if ((s0_params->pixel_fmt == PXP_PIX_FMT_YUV420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_YVU420P) ||
+	    (s0_params->pixel_fmt == PXP_PIX_FMT_GREY)) {
+		/* Set to 1 if YUV format is 4:2:2 rather than 4:2:0 */
+		int s = 2;
+		U = Y + (s0_params->width * s0_params->height);
+		V = U + ((s0_params->width * s0_params->height) >> s);
+		__raw_writel(U, pxp->base + HW_PXP_S0UBUF);
+		__raw_writel(V, pxp->base + HW_PXP_S0VBUF);
+	}
+}
+
+/**
+ * pxp_config() - configure PxP for a processing task
+ * @pxps:	PXP context.
+ * @pxp_chan:	PXP channel.
+ * @return:	0 on success or negative error code on failure.
+ */
+static int pxp_config(struct pxps *pxp, struct pxp_channel *pxp_chan)
+{
+	struct pxp_config_data *pxp_conf_data = &pxp->pxp_conf_state;
+	int ol_nr;
+	int i;
+
+	/* Configure PxP regs */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	pxp_set_scaling(pxp);
+	ol_nr = pxp_conf_data->layer_nr - 2;
+	while (ol_nr > 0) {
+		i = pxp_conf_data->layer_nr - 2 - ol_nr;
+		pxp_set_oln(i, pxp);
+		pxp_set_olparam(i, pxp);
+		/* only the color key in higher overlay will take effect. */
+		pxp_set_olcolorkey(i, pxp);
+		ol_nr--;
+	}
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	pxp_set_s0buf(pxp);
+	pxp_set_outbuf(pxp);
+
+	return 0;
+}
+
+static struct pxp_tx_desc *pxpdma_first_active(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->active_list.next, struct pxp_tx_desc, list);
+}
+
+static struct pxp_tx_desc *pxpdma_first_queued(struct pxp_channel *pxp_chan)
+{
+	return list_entry(pxp_chan->queue.next, struct pxp_tx_desc, list);
+}
+
+/* called with pxp_chan->lock held */
+static void __pxpdma_dostart(struct pxp_channel *pxp_chan)
+{
+	struct pxp_dma *pxp_dma = to_pxp_dma(pxp_chan->dma_chan.device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc;
+	struct pxp_tx_desc *child;
+	int i = 0;
+
+	/* so far we presume only one transaction on active_list */
+	/* S0 */
+	desc = pxpdma_first_active(pxp_chan);
+	memcpy(&pxp->pxp_conf_state.s0_param,
+	       &desc->layer_param.s0_param, sizeof(struct pxp_layer_param));
+	memcpy(&pxp->pxp_conf_state.proc_data,
+	       &desc->proc_data, sizeof(struct pxp_proc_data));
+
+	/* Save PxP configuration */
+	list_for_each_entry(child, &desc->txd.tx_list, list) {
+		if (i == 0) {	/* Output */
+			memcpy(&pxp->pxp_conf_state.out_param,
+			       &child->layer_param.out_param,
+			       sizeof(struct pxp_layer_param));
+		} else {	/* Overlay */
+			memcpy(&pxp->pxp_conf_state.ol_param[i - 1],
+			       &child->layer_param.ol_param,
+			       sizeof(struct pxp_layer_param));
+		}
+
+		i++;
+	}
+	pr_debug("%s:%d S0 w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.s0_param.width,
+		 pxp->pxp_conf_state.s0_param.height,
+		 pxp->pxp_conf_state.s0_param.paddr);
+	pr_debug("%s:%d OUT w/h %d/%d paddr %08x\n", __func__, __LINE__,
+		 pxp->pxp_conf_state.out_param.width,
+		 pxp->pxp_conf_state.out_param.height,
+		 pxp->pxp_conf_state.out_param.paddr);
+}
+
+static void pxpdma_dostart_work(struct work_struct *w)
+{
+	struct pxps *pxp = container_of(w, struct pxps, work);
+	struct pxp_channel *pxp_chan = NULL;
+	unsigned long flags, flags1;
+	int val;
+
+	val = __raw_readl(pxp->base + HW_PXP_CTRL);
+	if (val & BM_PXP_CTRL_ENABLE) {
+		pr_warning("pxp is active, quit.\n");
+		return;
+	}
+
+	spin_lock_irqsave(&pxp->lock, flags);
+	if (list_empty(&head)) {
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return;
+	}
+
+	pxp_chan = list_entry(head.next, struct pxp_channel, list);
+
+	spin_lock_irqsave(&pxp_chan->lock, flags1);
+	if (!list_empty(&pxp_chan->active_list)) {
+		struct pxp_tx_desc *desc;
+		/* REVISIT */
+		desc = pxpdma_first_active(pxp_chan);
+		__pxpdma_dostart(pxp_chan);
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags1);
+
+	/* Configure PxP */
+	pxp_config(pxp, pxp_chan);
+
+	pxp_start(pxp);
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+}
+
+static void pxpdma_dequeue(struct pxp_channel *pxp_chan, struct list_head *list)
+{
+	struct pxp_tx_desc *desc = NULL;
+	do {
+		desc = pxpdma_first_queued(pxp_chan);
+		list_move_tail(&desc->list, list);
+	} while (!list_empty(&pxp_chan->queue));
+}
+
+static dma_cookie_t pxp_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct pxp_tx_desc *desc = to_tx_desc(tx);
+	struct pxp_channel *pxp_chan = to_pxp_channel(tx->chan);
+	dma_cookie_t cookie;
+	unsigned long flags;
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "received TX\n");
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	cookie = pxp_chan->dma_chan.cookie;
+
+	if (++cookie < 0)
+		cookie = 1;
+
+	/* from dmaengine.h: "last cookie value returned to client" */
+	pxp_chan->dma_chan.cookie = cookie;
+	tx->cookie = cookie;
+
+	/* pxp_chan->lock can be taken under ichan->lock, but not v.v. */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+
+	/* Here we add the tx descriptor to our PxP task queue. */
+	list_add_tail(&desc->list, &pxp_chan->queue);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	dev_dbg(&pxp_chan->dma_chan.dev->device, "done TX\n");
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+	return cookie;
+}
+
+/* Called with pxp_chan->chan_mutex held */
+static int pxp_desc_alloc(struct pxp_channel *pxp_chan, int n)
+{
+	struct pxp_tx_desc *desc = vmalloc(n * sizeof(struct pxp_tx_desc));
+
+	if (!desc)
+		return -ENOMEM;
+
+	pxp_chan->n_tx_desc = n;
+	pxp_chan->desc = desc;
+	INIT_LIST_HEAD(&pxp_chan->active_list);
+	INIT_LIST_HEAD(&pxp_chan->queue);
+	INIT_LIST_HEAD(&pxp_chan->free_list);
+
+	while (n--) {
+		struct dma_async_tx_descriptor *txd = &desc->txd;
+
+		memset(txd, 0, sizeof(*txd));
+		dma_async_tx_descriptor_init(txd, &pxp_chan->dma_chan);
+		txd->tx_submit = pxp_tx_submit;
+
+		list_add(&desc->list, &pxp_chan->free_list);
+
+		desc++;
+	}
+
+	return 0;
+}
+
+/**
+ * pxp_init_channel() - initialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_init_channel(struct pxp_dma *pxp_dma,
+			    struct pxp_channel *pxp_chan)
+{
+	unsigned long flags;
+	struct pxps *pxp = to_pxp(pxp_dma);
+	int ret = 0, n_desc = 0;
+
+	/*
+	 * We are using _virtual_ channel here.
+	 * Each channel contains all parameters of corresponding layers
+	 * for one transaction; each layer is represented as one descriptor
+	 * (i.e., pxp_tx_desc) here.
+	 */
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	/* max desc nr: S0+OL+OUT = 1+8+1 */
+	n_desc = 10;
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	if (n_desc && !pxp_chan->desc)
+		ret = pxp_desc_alloc(pxp_chan, n_desc);
+
+	return ret;
+}
+
+/**
+ * pxp_uninit_channel() - uninitialize a PXP channel.
+ * @pxp_dma:   PXP DMA context.
+ * @pchan:  pointer to the channel object.
+ * @return      0 on success or negative error code on failure.
+ */
+static int pxp_uninit_channel(struct pxp_dma *pxp_dma,
+			      struct pxp_channel *pxp_chan)
+{
+	int ret = 0;
+
+	if (pxp_chan->desc)
+		vfree(pxp_chan->desc);
+
+	pxp_chan->desc = NULL;
+
+	return ret;
+}
+
+static irqreturn_t pxp_irq(int irq, void *dev_id)
+{
+	struct pxp_channel *pxp_chan = dev_id;
+	struct pxp_dma *pxp_dma = to_pxp_dma(pxp_chan->dma_chan.device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc;
+	dma_async_tx_callback callback;
+	void *callback_param;
+	unsigned long flags;
+	u32 hist_status;
+
+	hist_status =
+	    __raw_readl(pxp->base + HW_PXP_HIST_CTRL) & BM_PXP_HIST_CTRL_STATUS;
+
+	__raw_writel(BM_PXP_STAT_IRQ, pxp->base + HW_PXP_STAT_CLR);
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	if (list_empty(&pxp_chan->active_list)) {
+		pr_debug("PXP_IRQ pxp_chan->active_list empty. chan_id %d\n",
+			 pxp_chan->dma_chan.chan_id);
+		spin_unlock_irqrestore(&pxp->lock, flags);
+		return IRQ_NONE;
+	}
+
+	/* Get descriptor and call callback */
+	desc = pxpdma_first_active(pxp_chan);
+
+	pxp_chan->completed = desc->txd.cookie;
+
+	callback = desc->txd.callback;
+	callback_param = desc->txd.callback_param;
+
+	/* Send histogram status back to caller */
+	desc->hist_status = hist_status;
+
+	if ((desc->txd.flags & DMA_PREP_INTERRUPT) && callback)
+		callback(callback_param);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	list_splice_init(&desc->txd.tx_list, &pxp_chan->free_list);
+	list_move(&desc->list, &pxp_chan->free_list);
+
+	list_del(&pxp_chan->list);
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
+
+	queue_work(pxp->workqueue, &pxp->work);
+
+	return IRQ_HANDLED;
+}
+
+static struct pxp_tx_desc *pxp_desc_get(struct pxp_channel *pxp_chan)
+{
+	struct pxp_tx_desc *desc, *_desc;
+	struct pxp_tx_desc *ret = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	list_for_each_entry_safe(desc, _desc, &pxp_chan->free_list, list) {
+		list_del_init(&desc->list);
+		ret = desc;
+		break;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	return ret;
+}
+
+static void pxpdma_desc_put(struct pxp_channel *pxp_chan,
+			    struct pxp_tx_desc *desc)
+{
+	if (desc) {
+		struct device *dev = &pxp_chan->dma_chan.dev->device;
+		struct pxp_tx_desc *child;
+		unsigned long flags;
+
+		spin_lock_irqsave(&pxp_chan->lock, flags);
+		list_for_each_entry(child, &desc->txd.tx_list, list)
+		    dev_info(dev, "moving child desc %p to freelist\n", child);
+		list_splice_init(&desc->txd.tx_list, &pxp_chan->free_list);
+		dev_info(dev, "moving desc %p to freelist\n", desc);
+		list_add(&desc->list, &pxp_chan->free_list);
+		spin_unlock_irqrestore(&pxp_chan->lock, flags);
+	}
+}
+
+/* Allocate and initialise a transfer descriptor. */
+static struct dma_async_tx_descriptor *pxp_prep_slave_sg(struct dma_chan *chan,
+							 struct scatterlist
+							 *sgl,
+							 unsigned int sg_len,
+							 enum dma_data_direction
+							 direction,
+							 unsigned long tx_flags)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	struct pxp_tx_desc *desc = NULL;
+	struct pxp_tx_desc *first = NULL, *prev = NULL;
+	struct scatterlist *sg;
+	unsigned long flags;
+	dma_addr_t phys_addr;
+	int i;
+
+	if (direction != DMA_FROM_DEVICE && direction != DMA_TO_DEVICE) {
+		dev_err(chan->device->dev, "Invalid DMA direction %d!\n",
+			direction);
+		return NULL;
+	}
+
+	if (unlikely(sg_len < 2))
+		return NULL;
+
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	for_each_sg(sgl, sg, sg_len, i) {
+		desc = pxp_desc_get(pxp_chan);
+		if (!desc) {
+			pxpdma_desc_put(pxp_chan, first);
+			dev_err(chan->device->dev, "Can't get DMA desc.\n");
+			spin_unlock_irqrestore(&pxp_chan->lock, flags);
+			return NULL;
+		}
+
+		phys_addr = sg_dma_address(sg);
+
+		if (!first) {
+			first = desc;
+
+			desc->layer_param.s0_param.paddr = phys_addr;
+		} else {
+			list_add_tail(&desc->list, &first->txd.tx_list);
+			prev->next = desc;
+			desc->next = NULL;
+
+			if (i == 1)
+				desc->layer_param.out_param.paddr = phys_addr;
+			else
+				desc->layer_param.ol_param.paddr = phys_addr;
+		}
+
+		prev = desc;
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp->pxp_conf_state.layer_nr = sg_len;
+	first->txd.flags = tx_flags;
+	first->len = sg_len;
+	pr_debug("%s:%d first %p, first->len %d, flags %08x\n",
+		 __func__, __LINE__, first, first->len, first->txd.flags);
+
+	return &first->txd;
+}
+
+static void pxp_issue_pending(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	struct pxps *pxp = to_pxp(pxp_dma);
+	unsigned long flags0, flags;
+
+	spin_lock_irqsave(&pxp->lock, flags0);
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	if (!list_empty(&pxp_chan->active_list))
+		queue_work(pxp->workqueue, &pxp->work);
+
+	if (!list_empty(&pxp_chan->queue)) {
+		pxpdma_dequeue(pxp_chan, &pxp_chan->active_list);
+		pxp_chan->status = PXP_CHANNEL_READY;
+		list_add_tail(&pxp_chan->list, &head);
+		queue_work(pxp->workqueue, &pxp->work);
+	}
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+	spin_unlock_irqrestore(&pxp->lock, flags0);
+}
+
+static void __pxp_terminate_all(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	unsigned long flags;
+
+	cancel_work_sync(&to_pxp(pxp_dma)->work);
+
+	/* pchan->queue is modified in ISR, have to spinlock */
+	spin_lock_irqsave(&pxp_chan->lock, flags);
+	list_splice_init(&pxp_chan->queue, &pxp_chan->free_list);
+	list_splice_init(&pxp_chan->active_list, &pxp_chan->free_list);
+
+	spin_unlock_irqrestore(&pxp_chan->lock, flags);
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+}
+
+static void pxp_terminate_all(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	mutex_lock(&pxp_chan->chan_mutex);
+	__pxp_terminate_all(chan);
+	mutex_unlock(&pxp_chan->chan_mutex);
+}
+
+static int pxp_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+	int ret;
+
+	/* dmaengine.c now guarantees to only offer free channels */
+	BUG_ON(chan->client_count > 1);
+	WARN_ON(pxp_chan->status != PXP_CHANNEL_FREE);
+
+	chan->cookie = 1;
+	pxp_chan->completed = -ENXIO;
+
+	pr_debug("%s dma_chan.chan_id %d\n", __func__, chan->chan_id);
+	ret = pxp_init_channel(pxp_dma, pxp_chan);
+	if (ret < 0)
+		goto err_chan;
+
+	ret = request_irq(pxp_chan->eof_irq, pxp_irq, IRQF_SHARED,
+			  "pxp-irq", pxp_chan);
+	if (ret < 0)
+		goto err_irq;
+
+	pxp_chan->status = PXP_CHANNEL_INITIALIZED;
+
+	dev_dbg(&chan->dev->device, "Found channel 0x%x, irq %d\n",
+		chan->chan_id, pxp_chan->eof_irq);
+
+	return ret;
+
+err_irq:
+	pxp_uninit_channel(pxp_dma, pxp_chan);
+err_chan:
+	return ret;
+}
+
+static void pxp_free_chan_resources(struct dma_chan *chan)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+	struct pxp_dma *pxp_dma = to_pxp_dma(chan->device);
+
+	mutex_lock(&pxp_chan->chan_mutex);
+
+	__pxp_terminate_all(chan);
+
+	pxp_chan->status = PXP_CHANNEL_FREE;
+
+	pxp_uninit_channel(pxp_dma, pxp_chan);
+
+	free_irq(pxp_chan->eof_irq, pxp_chan);
+
+	mutex_unlock(&pxp_chan->chan_mutex);
+}
+
+static enum dma_status pxp_is_tx_complete(struct dma_chan *chan,
+					  dma_cookie_t cookie,
+					  dma_cookie_t *done,
+					  dma_cookie_t *used)
+{
+	struct pxp_channel *pxp_chan = to_pxp_channel(chan);
+
+	if (done)
+		*done = pxp_chan->completed;
+	if (used)
+		*used = chan->cookie;
+	if (cookie != chan->cookie)
+		return DMA_ERROR;
+	return DMA_SUCCESS;
+}
+
+static int pxp_hw_init(struct pxps *pxp)
+{
+	struct pxp_config_data *pxp_conf = &pxp->pxp_conf_state;
+	struct pxp_proc_data *proc_data = &pxp_conf->proc_data;
+	u32 reg_val;
+	int i;
+
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+
+	/* Config defaults */
+
+	/* Initialize non-channel-specific PxP parameters */
+	proc_data->drect.left = proc_data->srect.left = 0;
+	proc_data->drect.top = proc_data->srect.top = 0;
+	proc_data->drect.width = proc_data->srect.width = 0;
+	proc_data->drect.height = proc_data->srect.height = 0;
+	proc_data->scaling = 0;
+	proc_data->hflip = 0;
+	proc_data->vflip = 0;
+	proc_data->rotate = 0;
+	proc_data->bgcolor = 0;
+
+	/* Initialize S0 channel parameters */
+	pxp_conf->s0_param.pixel_fmt = pxp_s0_formats[0];
+	pxp_conf->s0_param.width = 0;
+	pxp_conf->s0_param.height = 0;
+	pxp_conf->s0_param.color_key = -1;
+	pxp_conf->s0_param.color_key_enable = false;
+
+	/* Initialize OL channel parameters */
+	for (i = 0; i < 8; i++) {
+		pxp_conf->ol_param[i].combine_enable = false;
+		pxp_conf->ol_param[i].width = 0;
+		pxp_conf->ol_param[i].height = 0;
+		pxp_conf->ol_param[i].pixel_fmt = PXP_PIX_FMT_RGB565;
+		pxp_conf->ol_param[i].color_key_enable = false;
+		pxp_conf->ol_param[i].color_key = -1;
+		pxp_conf->ol_param[i].global_alpha_enable = false;
+		pxp_conf->ol_param[i].global_alpha = 0;
+		pxp_conf->ol_param[i].local_alpha_enable = false;
+	}
+
+	/* Initialize Output channel parameters */
+	pxp_conf->out_param.width = 0;
+	pxp_conf->out_param.height = 0;
+	pxp_conf->out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
+
+	proc_data->overlay_state = 0;
+
+	/* Write default h/w config */
+	pxp_set_ctrl(pxp);
+	pxp_set_s0param(pxp);
+	pxp_set_s0crop(pxp);
+	for (i = 0; i < 8; i++) {
+		pxp_set_oln(i, pxp);
+		pxp_set_olparam(i, pxp);
+		pxp_set_olcolorkey(i, pxp);
+	}
+	pxp_set_s0colorkey(pxp);
+	pxp_set_csc(pxp);
+	pxp_set_bg(pxp);
+	pxp_set_lut(pxp);
+
+	/* One-time histogram configuration */
+	reg_val =
+	    BF_PXP_HIST_CTRL_PANEL_MODE(BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST_CTRL);
+
+	reg_val = BF_PXP_HIST2_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST2_PARAM_VALUE1(0x00F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST2_PARAM);
+
+	reg_val = BF_PXP_HIST4_PARAM_VALUE0(0x00) |
+	    BF_PXP_HIST4_PARAM_VALUE1(0x05) |
+	    BF_PXP_HIST4_PARAM_VALUE2(0x0A) | BF_PXP_HIST4_PARAM_VALUE3(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST4_PARAM);
+
+	reg_val = BF_PXP_HIST8_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST8_PARAM0_VALUE1(0x02) |
+	    BF_PXP_HIST8_PARAM0_VALUE2(0x04) | BF_PXP_HIST8_PARAM0_VALUE3(0x06);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM0);
+	reg_val = BF_PXP_HIST8_PARAM1_VALUE4(0x09) |
+	    BF_PXP_HIST8_PARAM1_VALUE5(0x0B) |
+	    BF_PXP_HIST8_PARAM1_VALUE6(0x0D) | BF_PXP_HIST8_PARAM1_VALUE7(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST8_PARAM1);
+
+	reg_val = BF_PXP_HIST16_PARAM0_VALUE0(0x00) |
+	    BF_PXP_HIST16_PARAM0_VALUE1(0x01) |
+	    BF_PXP_HIST16_PARAM0_VALUE2(0x02) |
+	    BF_PXP_HIST16_PARAM0_VALUE3(0x03);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM0);
+	reg_val = BF_PXP_HIST16_PARAM1_VALUE4(0x04) |
+	    BF_PXP_HIST16_PARAM1_VALUE5(0x05) |
+	    BF_PXP_HIST16_PARAM1_VALUE6(0x06) |
+	    BF_PXP_HIST16_PARAM1_VALUE7(0x07);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM1);
+	reg_val = BF_PXP_HIST16_PARAM2_VALUE8(0x08) |
+	    BF_PXP_HIST16_PARAM2_VALUE9(0x09) |
+	    BF_PXP_HIST16_PARAM2_VALUE10(0x0A) |
+	    BF_PXP_HIST16_PARAM2_VALUE11(0x0B);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM2);
+	reg_val = BF_PXP_HIST16_PARAM3_VALUE12(0x0C) |
+	    BF_PXP_HIST16_PARAM3_VALUE13(0x0D) |
+	    BF_PXP_HIST16_PARAM3_VALUE14(0x0E) |
+	    BF_PXP_HIST16_PARAM3_VALUE15(0x0F);
+	__raw_writel(reg_val, pxp->base + HW_PXP_HIST16_PARAM3);
+
+	return 0;
+}
+
+static int pxp_dma_init(struct pxps *pxp)
+{
+	struct pxp_dma *pxp_dma = &pxp->pxp_dma;
+	struct dma_device *dma = &pxp_dma->dma;
+	int i;
+
+	dma_cap_set(DMA_SLAVE, dma->cap_mask);
+	dma_cap_set(DMA_PRIVATE, dma->cap_mask);
+
+	/* Compulsory common fields */
+	dma->dev = pxp->dev;
+	dma->device_alloc_chan_resources = pxp_alloc_chan_resources;
+	dma->device_free_chan_resources = pxp_free_chan_resources;
+	dma->device_is_tx_complete = pxp_is_tx_complete;
+	dma->device_issue_pending = pxp_issue_pending;
+
+	/* Compulsory for DMA_SLAVE fields */
+	dma->device_prep_slave_sg = pxp_prep_slave_sg;
+	dma->device_terminate_all = pxp_terminate_all;
+
+	/* Initialize PxP Channels */
+	INIT_LIST_HEAD(&dma->channels);
+	for (i = 0; i < NR_PXP_VIRT_CHANNEL; i++) {
+		struct pxp_channel *pxp_chan = pxp->channel + i;
+		struct dma_chan *dma_chan = &pxp_chan->dma_chan;
+
+		spin_lock_init(&pxp_chan->lock);
+		mutex_init(&pxp_chan->chan_mutex);
+
+		/* Only one EOF IRQ for PxP, shared by all channels */
+		pxp_chan->eof_irq = pxp->irq;
+		pxp_chan->status = PXP_CHANNEL_FREE;
+		pxp_chan->completed = -ENXIO;
+		snprintf(pxp_chan->eof_name, sizeof(pxp_chan->eof_name),
+			 "PXP EOF %d", i);
+
+		dma_chan->device = &pxp_dma->dma;
+		dma_chan->cookie = 1;
+		dma_chan->chan_id = i;
+		list_add_tail(&dma_chan->device_node, &dma->channels);
+	}
+
+	return dma_async_device_register(&pxp_dma->dma);
+}
+
+static int pxp_probe(struct platform_device *pdev)
+{
+	struct pxps *pxp;
+	struct resource *res;
+	int irq;
+	int err = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || irq < 0) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	pxp = kzalloc(sizeof(*pxp), GFP_KERNEL);
+	if (!pxp) {
+		dev_err(&pdev->dev, "failed to allocate control object\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	pxp->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, pxp);
+	pxp->irq = irq;
+
+	spin_lock_init(&pxp->lock);
+	mutex_init(&pxp->mutex);
+
+	if (!request_mem_region(res->start, resource_size(res), "pxp-mem")) {
+		err = -EBUSY;
+		goto freepxp;
+	}
+
+	pxp->base = ioremap(res->start, SZ_4K);
+	pxp->pdev = pdev;
+
+	pxp->clk = clk_get(NULL, "pxp_axi");
+	clk_enable(pxp->clk);
+
+	err = pxp_hw_init(pxp);
+	if (err) {
+		dev_err(&pdev->dev, "failed to initialize hardware\n");
+		goto release;
+	}
+
+	/* Initialize DMA engine */
+	err = pxp_dma_init(pxp);
+	if (err < 0)
+		goto err_dma_init;
+
+	INIT_WORK(&pxp->work, pxpdma_dostart_work);
+	pxp->workqueue = create_singlethread_workqueue("pxp_dma");
+exit:
+	return err;
+err_dma_init:
+	free_irq(pxp->irq, pxp);
+	clk_disable(pxp->clk);
+release:
+	release_mem_region(res->start, resource_size(res));
+freepxp:
+	kfree(pxp);
+	dev_err(&pdev->dev, "Exiting (unsuccessfully) pxp_probe function\n");
+	return err;
+}
+
+static int __devexit pxp_remove(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	cancel_work_sync(&pxp->work);
+	kfree(pxp);
+
+	free_irq(pxp->irq, pxp);
+	clk_disable(pxp->clk);
+	clk_put(pxp->clk);
+	iounmap(pxp->base);
+
+	kfree(pxp);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pxp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	while (__raw_readl(pxp->base + HW_PXP_CTRL) & BM_PXP_CTRL_ENABLE)
+		;
+
+	__raw_writel(BM_PXP_CTRL_SFTRST, pxp->base + HW_PXP_CTRL);
+	clk_disable(pxp->clk);
+
+	return 0;
+}
+
+static int pxp_resume(struct platform_device *pdev)
+{
+	struct pxps *pxp = platform_get_drvdata(pdev);
+
+	clk_enable(pxp->clk);
+	/* Pull PxP out of reset */
+	__raw_writel(0, pxp->base + HW_PXP_CTRL);
+
+	return 0;
+}
+#else
+#define	pxp_suspend	NULL
+#define	pxp_resume	NULL
+#endif
+
+static struct platform_driver pxp_driver = {
+	.driver = {
+		   .name = "mxc-pxp",
+		   },
+	.probe = pxp_probe,
+	.remove = __exit_p(pxp_remove),
+	.suspend = pxp_suspend,
+	.resume = pxp_resume,
+};
+
+static int __init pxp_init(void)
+{
+	return platform_driver_register(&pxp_driver);
+}
+
+subsys_initcall(pxp_init);
+
+static void __exit pxp_exit(void)
+{
+	platform_driver_unregister(&pxp_driver);
+}
+
+module_exit(pxp_exit);
+
+MODULE_DESCRIPTION("i.MX PxP driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/pxp/regs-pxp.h b/drivers/dma/pxp/regs-pxp.h
new file mode 100644
index 0000000..b0c1b00
--- /dev/null
+++ b/drivers/dma/pxp/regs-pxp.h
@@ -0,0 +1,949 @@
+/*
+ * Freescale PXP Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.6
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___PXP_H
+#define __ARCH_ARM___PXP_H
+
+
+#define HW_PXP_CTRL	(0x00000000)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define HW_PXP_CTRL_CLR	(0x00000008)
+#define HW_PXP_CTRL_TOG	(0x0000000c)
+
+#define BM_PXP_CTRL_SFTRST 0x80000000
+#define BM_PXP_CTRL_CLKGATE 0x40000000
+#define BM_PXP_CTRL_RSVD 0x20000000
+#define BM_PXP_CTRL_EN_REPEAT 0x10000000
+#define BP_PXP_CTRL_INTERLACED_OUTPUT      26
+#define BM_PXP_CTRL_INTERLACED_OUTPUT 0x0C000000
+#define BF_PXP_CTRL_INTERLACED_OUTPUT(v)  \
+	(((v) << 26) & BM_PXP_CTRL_INTERLACED_OUTPUT)
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD0      0x1
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD1      0x2
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__INTERLACED  0x3
+#define BP_PXP_CTRL_INTERLACED_INPUT      24
+#define BM_PXP_CTRL_INTERLACED_INPUT 0x03000000
+#define BF_PXP_CTRL_INTERLACED_INPUT(v)  \
+	(((v) << 24) & BM_PXP_CTRL_INTERLACED_INPUT)
+#define BV_PXP_CTRL_INTERLACED_INPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD0      0x2
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD1      0x3
+#define BM_PXP_CTRL_BLOCK_SIZE 0x00800000
+#define BV_PXP_CTRL_BLOCK_SIZE__8X8   0x0
+#define BV_PXP_CTRL_BLOCK_SIZE__16X16 0x1
+#define BM_PXP_CTRL_ALPHA_OUTPUT 0x00400000
+#define BM_PXP_CTRL_IN_PLACE 0x00200000
+#define BM_PXP_CTRL_DELTA 0x00100000
+#define BM_PXP_CTRL_CROP 0x00080000
+#define BM_PXP_CTRL_SCALE 0x00040000
+#define BM_PXP_CTRL_UPSAMPLE 0x00020000
+#define BM_PXP_CTRL_SUBSAMPLE 0x00010000
+#define BP_PXP_CTRL_S0_FORMAT      12
+#define BM_PXP_CTRL_S0_FORMAT 0x0000F000
+#define BF_PXP_CTRL_S0_FORMAT(v)  \
+	(((v) << 12) & BM_PXP_CTRL_S0_FORMAT)
+#define BV_PXP_CTRL_S0_FORMAT__RGB888    0x1
+#define BV_PXP_CTRL_S0_FORMAT__RGB565    0x4
+#define BV_PXP_CTRL_S0_FORMAT__RGB555    0x5
+#define BV_PXP_CTRL_S0_FORMAT__YUV422    0x8
+#define BV_PXP_CTRL_S0_FORMAT__YUV420    0x9
+#define BV_PXP_CTRL_S0_FORMAT__UYVY1P422 0xA
+#define BV_PXP_CTRL_S0_FORMAT__VYUY1P422 0xB
+#define BV_PXP_CTRL_S0_FORMAT__YUV2P422  0xC
+#define BV_PXP_CTRL_S0_FORMAT__YUV2P420  0xD
+#define BV_PXP_CTRL_S0_FORMAT__YVU2P422  0xE
+#define BV_PXP_CTRL_S0_FORMAT__YVU2P420  0xF
+#define BM_PXP_CTRL_VFLIP 0x00000800
+#define BM_PXP_CTRL_HFLIP 0x00000400
+#define BP_PXP_CTRL_ROTATE      8
+#define BM_PXP_CTRL_ROTATE 0x00000300
+#define BF_PXP_CTRL_ROTATE(v)  \
+	(((v) << 8) & BM_PXP_CTRL_ROTATE)
+#define BV_PXP_CTRL_ROTATE__ROT_0   0x0
+#define BV_PXP_CTRL_ROTATE__ROT_90  0x1
+#define BV_PXP_CTRL_ROTATE__ROT_180 0x2
+#define BV_PXP_CTRL_ROTATE__ROT_270 0x3
+#define BP_PXP_CTRL_OUTBUF_FORMAT      4
+#define BM_PXP_CTRL_OUTBUF_FORMAT 0x000000F0
+#define BF_PXP_CTRL_OUTBUF_FORMAT(v)  \
+	(((v) << 4) & BM_PXP_CTRL_OUTBUF_FORMAT)
+#define BV_PXP_CTRL_OUTBUF_FORMAT__ARGB8888  0x0
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB888    0x1
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB888P   0x2
+#define BV_PXP_CTRL_OUTBUF_FORMAT__ARGB1555  0x3
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB565    0x4
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB555    0x5
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV444    0x7
+#define BV_PXP_CTRL_OUTBUF_FORMAT__MONOC8    0x8
+#define BV_PXP_CTRL_OUTBUF_FORMAT__MONOC4    0x9
+#define BV_PXP_CTRL_OUTBUF_FORMAT__UYVY1P422 0xA
+#define BV_PXP_CTRL_OUTBUF_FORMAT__VYUY1P422 0xB
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P422  0xC
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P420  0xD
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YVU2P422  0xE
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YVU2P420  0xF
+#define BM_PXP_CTRL_ENABLE_LCD_HANDSHAKE 0x00000008
+#define BM_PXP_CTRL_NEXT_IRQ_ENABLE 0x00000004
+#define BM_PXP_CTRL_IRQ_ENABLE 0x00000002
+#define BM_PXP_CTRL_ENABLE 0x00000001
+
+#define HW_PXP_STAT	(0x00000010)
+#define HW_PXP_STAT_SET	(0x00000014)
+#define HW_PXP_STAT_CLR	(0x00000018)
+#define HW_PXP_STAT_TOG	(0x0000001c)
+
+#define BP_PXP_STAT_BLOCKX      24
+#define BM_PXP_STAT_BLOCKX 0xFF000000
+#define BF_PXP_STAT_BLOCKX(v) \
+	(((v) << 24) & BM_PXP_STAT_BLOCKX)
+#define BP_PXP_STAT_BLOCKY      16
+#define BM_PXP_STAT_BLOCKY 0x00FF0000
+#define BF_PXP_STAT_BLOCKY(v)  \
+	(((v) << 16) & BM_PXP_STAT_BLOCKY)
+#define BP_PXP_STAT_RSVD2      8
+#define BM_PXP_STAT_RSVD2 0x0000FF00
+#define BF_PXP_STAT_RSVD2(v)  \
+	(((v) << 8) & BM_PXP_STAT_RSVD2)
+#define BP_PXP_STAT_AXI_ERROR_ID      4
+#define BM_PXP_STAT_AXI_ERROR_ID 0x000000F0
+#define BF_PXP_STAT_AXI_ERROR_ID(v)  \
+	(((v) << 4) & BM_PXP_STAT_AXI_ERROR_ID)
+#define BM_PXP_STAT_NEXT_IRQ 0x00000008
+#define BM_PXP_STAT_AXI_READ_ERROR 0x00000004
+#define BM_PXP_STAT_AXI_WRITE_ERROR 0x00000002
+#define BM_PXP_STAT_IRQ 0x00000001
+
+#define HW_PXP_OUTBUF	(0x00000020)
+
+#define BP_PXP_OUTBUF_ADDR      0
+#define BM_PXP_OUTBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_OUTBUF_ADDR(v)   (v)
+
+#define HW_PXP_OUTBUF2	(0x00000030)
+
+#define BP_PXP_OUTBUF2_ADDR      0
+#define BM_PXP_OUTBUF2_ADDR 0xFFFFFFFF
+#define BF_PXP_OUTBUF2_ADDR(v)   (v)
+
+#define HW_PXP_OUTSIZE	(0x00000040)
+
+#define BP_PXP_OUTSIZE_ALPHA      24
+#define BM_PXP_OUTSIZE_ALPHA 0xFF000000
+#define BF_PXP_OUTSIZE_ALPHA(v) \
+	(((v) << 24) & BM_PXP_OUTSIZE_ALPHA)
+#define BP_PXP_OUTSIZE_WIDTH      12
+#define BM_PXP_OUTSIZE_WIDTH 0x00FFF000
+#define BF_PXP_OUTSIZE_WIDTH(v)  \
+	(((v) << 12) & BM_PXP_OUTSIZE_WIDTH)
+#define BP_PXP_OUTSIZE_HEIGHT      0
+#define BM_PXP_OUTSIZE_HEIGHT 0x00000FFF
+#define BF_PXP_OUTSIZE_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_OUTSIZE_HEIGHT)
+
+#define HW_PXP_S0BUF	(0x00000050)
+
+#define BP_PXP_S0BUF_ADDR      0
+#define BM_PXP_S0BUF_ADDR 0xFFFFFFFF
+#define BF_PXP_S0BUF_ADDR(v)   (v)
+
+#define HW_PXP_S0UBUF	(0x00000060)
+
+#define BP_PXP_S0UBUF_ADDR      0
+#define BM_PXP_S0UBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_S0UBUF_ADDR(v)   (v)
+
+#define HW_PXP_S0VBUF	(0x00000070)
+
+#define BP_PXP_S0VBUF_ADDR      0
+#define BM_PXP_S0VBUF_ADDR 0xFFFFFFFF
+#define BF_PXP_S0VBUF_ADDR(v)   (v)
+
+#define HW_PXP_S0PARAM	(0x00000080)
+
+#define BP_PXP_S0PARAM_XBASE      24
+#define BM_PXP_S0PARAM_XBASE 0xFF000000
+#define BF_PXP_S0PARAM_XBASE(v) \
+	(((v) << 24) & BM_PXP_S0PARAM_XBASE)
+#define BP_PXP_S0PARAM_YBASE      16
+#define BM_PXP_S0PARAM_YBASE 0x00FF0000
+#define BF_PXP_S0PARAM_YBASE(v)  \
+	(((v) << 16) & BM_PXP_S0PARAM_YBASE)
+#define BP_PXP_S0PARAM_WIDTH      8
+#define BM_PXP_S0PARAM_WIDTH 0x0000FF00
+#define BF_PXP_S0PARAM_WIDTH(v)  \
+	(((v) << 8) & BM_PXP_S0PARAM_WIDTH)
+#define BP_PXP_S0PARAM_HEIGHT      0
+#define BM_PXP_S0PARAM_HEIGHT 0x000000FF
+#define BF_PXP_S0PARAM_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_S0PARAM_HEIGHT)
+
+#define HW_PXP_S0BACKGROUND	(0x00000090)
+
+#define BP_PXP_S0BACKGROUND_COLOR      0
+#define BM_PXP_S0BACKGROUND_COLOR 0xFFFFFFFF
+#define BF_PXP_S0BACKGROUND_COLOR(v)   (v)
+
+#define HW_PXP_S0CROP	(0x000000a0)
+
+#define BP_PXP_S0CROP_XBASE      24
+#define BM_PXP_S0CROP_XBASE 0xFF000000
+#define BF_PXP_S0CROP_XBASE(v) \
+	(((v) << 24) & BM_PXP_S0CROP_XBASE)
+#define BP_PXP_S0CROP_YBASE      16
+#define BM_PXP_S0CROP_YBASE 0x00FF0000
+#define BF_PXP_S0CROP_YBASE(v)  \
+	(((v) << 16) & BM_PXP_S0CROP_YBASE)
+#define BP_PXP_S0CROP_WIDTH      8
+#define BM_PXP_S0CROP_WIDTH 0x0000FF00
+#define BF_PXP_S0CROP_WIDTH(v)  \
+	(((v) << 8) & BM_PXP_S0CROP_WIDTH)
+#define BP_PXP_S0CROP_HEIGHT      0
+#define BM_PXP_S0CROP_HEIGHT 0x000000FF
+#define BF_PXP_S0CROP_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_S0CROP_HEIGHT)
+
+#define HW_PXP_S0SCALE	(0x000000b0)
+
+#define BM_PXP_S0SCALE_RSVD2 0x80000000
+#define BP_PXP_S0SCALE_YSCALE      16
+#define BM_PXP_S0SCALE_YSCALE 0x7FFF0000
+#define BF_PXP_S0SCALE_YSCALE(v)  \
+	(((v) << 16) & BM_PXP_S0SCALE_YSCALE)
+#define BM_PXP_S0SCALE_RSVD1 0x00008000
+#define BP_PXP_S0SCALE_XSCALE      0
+#define BM_PXP_S0SCALE_XSCALE 0x00007FFF
+#define BF_PXP_S0SCALE_XSCALE(v)  \
+	(((v) << 0) & BM_PXP_S0SCALE_XSCALE)
+
+#define HW_PXP_S0OFFSET	(0x000000c0)
+
+#define BP_PXP_S0OFFSET_RSVD2      28
+#define BM_PXP_S0OFFSET_RSVD2 0xF0000000
+#define BF_PXP_S0OFFSET_RSVD2(v) \
+	(((v) << 28) & BM_PXP_S0OFFSET_RSVD2)
+#define BP_PXP_S0OFFSET_YOFFSET      16
+#define BM_PXP_S0OFFSET_YOFFSET 0x0FFF0000
+#define BF_PXP_S0OFFSET_YOFFSET(v)  \
+	(((v) << 16) & BM_PXP_S0OFFSET_YOFFSET)
+#define BP_PXP_S0OFFSET_RSVD1      12
+#define BM_PXP_S0OFFSET_RSVD1 0x0000F000
+#define BF_PXP_S0OFFSET_RSVD1(v)  \
+	(((v) << 12) & BM_PXP_S0OFFSET_RSVD1)
+#define BP_PXP_S0OFFSET_XOFFSET      0
+#define BM_PXP_S0OFFSET_XOFFSET 0x00000FFF
+#define BF_PXP_S0OFFSET_XOFFSET(v)  \
+	(((v) << 0) & BM_PXP_S0OFFSET_XOFFSET)
+
+#define HW_PXP_CSCCOEF0	(0x000000d0)
+
+#define BM_PXP_CSCCOEF0_YCBCR_MODE 0x80000000
+#define BM_PXP_CSCCOEF0_BYPASS 0x40000000
+#define BM_PXP_CSCCOEF0_RSVD1 0x20000000
+#define BP_PXP_CSCCOEF0_C0      18
+#define BM_PXP_CSCCOEF0_C0 0x1FFC0000
+#define BF_PXP_CSCCOEF0_C0(v)  \
+	(((v) << 18) & BM_PXP_CSCCOEF0_C0)
+#define BP_PXP_CSCCOEF0_UV_OFFSET      9
+#define BM_PXP_CSCCOEF0_UV_OFFSET 0x0003FE00
+#define BF_PXP_CSCCOEF0_UV_OFFSET(v)  \
+	(((v) << 9) & BM_PXP_CSCCOEF0_UV_OFFSET)
+#define BP_PXP_CSCCOEF0_Y_OFFSET      0
+#define BM_PXP_CSCCOEF0_Y_OFFSET 0x000001FF
+#define BF_PXP_CSCCOEF0_Y_OFFSET(v)  \
+	(((v) << 0) & BM_PXP_CSCCOEF0_Y_OFFSET)
+
+#define HW_PXP_CSCCOEF1	(0x000000e0)
+
+#define BP_PXP_CSCCOEF1_RSVD1      27
+#define BM_PXP_CSCCOEF1_RSVD1 0xF8000000
+#define BF_PXP_CSCCOEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSCCOEF1_RSVD1)
+#define BP_PXP_CSCCOEF1_C1      16
+#define BM_PXP_CSCCOEF1_C1 0x07FF0000
+#define BF_PXP_CSCCOEF1_C1(v)  \
+	(((v) << 16) & BM_PXP_CSCCOEF1_C1)
+#define BP_PXP_CSCCOEF1_RSVD0      11
+#define BM_PXP_CSCCOEF1_RSVD0 0x0000F800
+#define BF_PXP_CSCCOEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSCCOEF1_RSVD0)
+#define BP_PXP_CSCCOEF1_C4      0
+#define BM_PXP_CSCCOEF1_C4 0x000007FF
+#define BF_PXP_CSCCOEF1_C4(v)  \
+	(((v) << 0) & BM_PXP_CSCCOEF1_C4)
+
+#define HW_PXP_CSCCOEF2	(0x000000f0)
+
+#define BP_PXP_CSCCOEF2_RSVD1      27
+#define BM_PXP_CSCCOEF2_RSVD1 0xF8000000
+#define BF_PXP_CSCCOEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSCCOEF2_RSVD1)
+#define BP_PXP_CSCCOEF2_C2      16
+#define BM_PXP_CSCCOEF2_C2 0x07FF0000
+#define BF_PXP_CSCCOEF2_C2(v)  \
+	(((v) << 16) & BM_PXP_CSCCOEF2_C2)
+#define BP_PXP_CSCCOEF2_RSVD0      11
+#define BM_PXP_CSCCOEF2_RSVD0 0x0000F800
+#define BF_PXP_CSCCOEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSCCOEF2_RSVD0)
+#define BP_PXP_CSCCOEF2_C3      0
+#define BM_PXP_CSCCOEF2_C3 0x000007FF
+#define BF_PXP_CSCCOEF2_C3(v)  \
+	(((v) << 0) & BM_PXP_CSCCOEF2_C3)
+
+#define HW_PXP_NEXT	(0x00000100)
+#define HW_PXP_NEXT_SET	(0x00000104)
+#define HW_PXP_NEXT_CLR	(0x00000108)
+#define HW_PXP_NEXT_TOG	(0x0000010c)
+
+#define BP_PXP_NEXT_POINTER      2
+#define BM_PXP_NEXT_POINTER 0xFFFFFFFC
+#define BF_PXP_NEXT_POINTER(v) \
+	(((v) << 2) & BM_PXP_NEXT_POINTER)
+#define BM_PXP_NEXT_RSVD 0x00000002
+#define BM_PXP_NEXT_ENABLED 0x00000001
+
+#define HW_PXP_S0COLORKEYLOW	(0x00000180)
+
+#define BP_PXP_S0COLORKEYLOW_RSVD1      24
+#define BM_PXP_S0COLORKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_S0COLORKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_S0COLORKEYLOW_RSVD1)
+#define BP_PXP_S0COLORKEYLOW_PIXEL      0
+#define BM_PXP_S0COLORKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_S0COLORKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_S0COLORKEYLOW_PIXEL)
+
+#define HW_PXP_S0COLORKEYHIGH	(0x00000190)
+
+#define BP_PXP_S0COLORKEYHIGH_RSVD1      24
+#define BM_PXP_S0COLORKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_S0COLORKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_S0COLORKEYHIGH_RSVD1)
+#define BP_PXP_S0COLORKEYHIGH_PIXEL      0
+#define BM_PXP_S0COLORKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_S0COLORKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_S0COLORKEYHIGH_PIXEL)
+
+#define HW_PXP_OLCOLORKEYLOW	(0x000001a0)
+
+#define BP_PXP_OLCOLORKEYLOW_RSVD1      24
+#define BM_PXP_OLCOLORKEYLOW_RSVD1 0xFF000000
+#define BF_PXP_OLCOLORKEYLOW_RSVD1(v) \
+	(((v) << 24) & BM_PXP_OLCOLORKEYLOW_RSVD1)
+#define BP_PXP_OLCOLORKEYLOW_PIXEL      0
+#define BM_PXP_OLCOLORKEYLOW_PIXEL 0x00FFFFFF
+#define BF_PXP_OLCOLORKEYLOW_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_OLCOLORKEYLOW_PIXEL)
+
+#define HW_PXP_OLCOLORKEYHIGH	(0x000001b0)
+
+#define BP_PXP_OLCOLORKEYHIGH_RSVD1      24
+#define BM_PXP_OLCOLORKEYHIGH_RSVD1 0xFF000000
+#define BF_PXP_OLCOLORKEYHIGH_RSVD1(v) \
+	(((v) << 24) & BM_PXP_OLCOLORKEYHIGH_RSVD1)
+#define BP_PXP_OLCOLORKEYHIGH_PIXEL      0
+#define BM_PXP_OLCOLORKEYHIGH_PIXEL 0x00FFFFFF
+#define BF_PXP_OLCOLORKEYHIGH_PIXEL(v)  \
+	(((v) << 0) & BM_PXP_OLCOLORKEYHIGH_PIXEL)
+
+#define HW_PXP_DEBUGCTRL	(0x000001d0)
+
+#define BP_PXP_DEBUGCTRL_RSVD      8
+#define BM_PXP_DEBUGCTRL_RSVD 0xFFFFFF00
+#define BF_PXP_DEBUGCTRL_RSVD(v) \
+	(((v) << 8) & BM_PXP_DEBUGCTRL_RSVD)
+#define BP_PXP_DEBUGCTRL_SELECT      0
+#define BM_PXP_DEBUGCTRL_SELECT 0x000000FF
+#define BF_PXP_DEBUGCTRL_SELECT(v)  \
+	(((v) << 0) & BM_PXP_DEBUGCTRL_SELECT)
+#define BV_PXP_DEBUGCTRL_SELECT__NONE     0x0
+#define BV_PXP_DEBUGCTRL_SELECT__CTRL     0x1
+#define BV_PXP_DEBUGCTRL_SELECT__S0REGS   0x2
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAX    0x3
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAY    0x4
+#define BV_PXP_DEBUGCTRL_SELECT__PXBUF    0x5
+#define BV_PXP_DEBUGCTRL_SELECT__ROTATION 0x6
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF0  0x7
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF1  0x8
+
+#define HW_PXP_DEBUG	(0x000001e0)
+
+#define BP_PXP_DEBUG_DATA      0
+#define BM_PXP_DEBUG_DATA 0xFFFFFFFF
+#define BF_PXP_DEBUG_DATA(v)   (v)
+
+#define HW_PXP_VERSION	(0x000001f0)
+
+#define BP_PXP_VERSION_MAJOR      24
+#define BM_PXP_VERSION_MAJOR 0xFF000000
+#define BF_PXP_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_PXP_VERSION_MAJOR)
+#define BP_PXP_VERSION_MINOR      16
+#define BM_PXP_VERSION_MINOR 0x00FF0000
+#define BF_PXP_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_PXP_VERSION_MINOR)
+#define BP_PXP_VERSION_STEP      0
+#define BM_PXP_VERSION_STEP 0x0000FFFF
+#define BF_PXP_VERSION_STEP(v)  \
+	(((v) << 0) & BM_PXP_VERSION_STEP)
+
+/*
+ *  multi-register-define name HW_PXP_OLn
+ *              base 0x00000200
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLn(n)	(0x00000200 + (n) * 0x40)
+#define BP_PXP_OLn_ADDR      0
+#define BM_PXP_OLn_ADDR 0xFFFFFFFF
+#define BF_PXP_OLn_ADDR(v)   (v)
+
+/*
+ *  multi-register-define name HW_PXP_OLnSIZE
+ *              base 0x00000210
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnSIZE(n)	(0x00000210 + (n) * 0x40)
+#define BP_PXP_OLnSIZE_XBASE      24
+#define BM_PXP_OLnSIZE_XBASE 0xFF000000
+#define BF_PXP_OLnSIZE_XBASE(v) \
+	(((v) << 24) & BM_PXP_OLnSIZE_XBASE)
+#define BP_PXP_OLnSIZE_YBASE      16
+#define BM_PXP_OLnSIZE_YBASE 0x00FF0000
+#define BF_PXP_OLnSIZE_YBASE(v)  \
+	(((v) << 16) & BM_PXP_OLnSIZE_YBASE)
+#define BP_PXP_OLnSIZE_WIDTH      8
+#define BM_PXP_OLnSIZE_WIDTH 0x0000FF00
+#define BF_PXP_OLnSIZE_WIDTH(v)  \
+	(((v) << 8) & BM_PXP_OLnSIZE_WIDTH)
+#define BP_PXP_OLnSIZE_HEIGHT      0
+#define BM_PXP_OLnSIZE_HEIGHT 0x000000FF
+#define BF_PXP_OLnSIZE_HEIGHT(v)  \
+	(((v) << 0) & BM_PXP_OLnSIZE_HEIGHT)
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM
+ *              base 0x00000220
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM(n)	(0x00000220 + (n) * 0x40)
+#define BP_PXP_OLnPARAM_RSVD1      20
+#define BM_PXP_OLnPARAM_RSVD1 0xFFF00000
+#define BF_PXP_OLnPARAM_RSVD1(v) \
+	(((v) << 20) & BM_PXP_OLnPARAM_RSVD1)
+#define BP_PXP_OLnPARAM_ROP      16
+#define BM_PXP_OLnPARAM_ROP 0x000F0000
+#define BF_PXP_OLnPARAM_ROP(v)  \
+	(((v) << 16) & BM_PXP_OLnPARAM_ROP)
+#define BV_PXP_OLnPARAM_ROP__MASKOL     0x0
+#define BV_PXP_OLnPARAM_ROP__MASKNOTOL  0x1
+#define BV_PXP_OLnPARAM_ROP__MASKOLNOT  0x2
+#define BV_PXP_OLnPARAM_ROP__MERGEOL    0x3
+#define BV_PXP_OLnPARAM_ROP__MERGENOTOL 0x4
+#define BV_PXP_OLnPARAM_ROP__MERGEOLNOT 0x5
+#define BV_PXP_OLnPARAM_ROP__NOTCOPYOL  0x6
+#define BV_PXP_OLnPARAM_ROP__NOT        0x7
+#define BV_PXP_OLnPARAM_ROP__NOTMASKOL  0x8
+#define BV_PXP_OLnPARAM_ROP__NOTMERGEOL 0x9
+#define BV_PXP_OLnPARAM_ROP__XOROL      0xA
+#define BV_PXP_OLnPARAM_ROP__NOTXOROL   0xB
+#define BP_PXP_OLnPARAM_ALPHA      8
+#define BM_PXP_OLnPARAM_ALPHA 0x0000FF00
+#define BF_PXP_OLnPARAM_ALPHA(v)  \
+	(((v) << 8) & BM_PXP_OLnPARAM_ALPHA)
+#define BP_PXP_OLnPARAM_FORMAT      4
+#define BM_PXP_OLnPARAM_FORMAT 0x000000F0
+#define BF_PXP_OLnPARAM_FORMAT(v)  \
+	(((v) << 4) & BM_PXP_OLnPARAM_FORMAT)
+#define BV_PXP_OLnPARAM_FORMAT__ARGB8888 0x0
+#define BV_PXP_OLnPARAM_FORMAT__RGB888   0x1
+#define BV_PXP_OLnPARAM_FORMAT__ARGB1555 0x3
+#define BV_PXP_OLnPARAM_FORMAT__RGB565   0x4
+#define BV_PXP_OLnPARAM_FORMAT__RGB555   0x5
+#define BM_PXP_OLnPARAM_ENABLE_COLORKEY 0x00000008
+#define BP_PXP_OLnPARAM_ALPHA_CNTL      1
+#define BM_PXP_OLnPARAM_ALPHA_CNTL 0x00000006
+#define BF_PXP_OLnPARAM_ALPHA_CNTL(v)  \
+	(((v) << 1) & BM_PXP_OLnPARAM_ALPHA_CNTL)
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Embedded 0x0
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Override 0x1
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Multiply 0x2
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__ROPs     0x3
+#define BM_PXP_OLnPARAM_ENABLE 0x00000001
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM2
+ *              base 0x00000230
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM2(n)	(0x00000230 + (n) * 0x40)
+#define BP_PXP_OLnPARAM2_RSVD      0
+#define BM_PXP_OLnPARAM2_RSVD 0xFFFFFFFF
+#define BF_PXP_OLnPARAM2_RSVD(v)   (v)
+
+#define HW_PXP_CSC2CTRL	(0x00000400)
+
+#define BP_PXP_CSC2CTRL_RSVD      3
+#define BM_PXP_CSC2CTRL_RSVD 0xFFFFFFF8
+#define BF_PXP_CSC2CTRL_RSVD(v) \
+	(((v) << 3) & BM_PXP_CSC2CTRL_RSVD)
+#define BP_PXP_CSC2CTRL_CSC_MODE      1
+#define BM_PXP_CSC2CTRL_CSC_MODE 0x00000006
+#define BF_PXP_CSC2CTRL_CSC_MODE(v)  \
+	(((v) << 1) & BM_PXP_CSC2CTRL_CSC_MODE)
+#define BV_PXP_CSC2CTRL_CSC_MODE__YUV2RGB   0x0
+#define BV_PXP_CSC2CTRL_CSC_MODE__YCbCr2RGB 0x1
+#define BV_PXP_CSC2CTRL_CSC_MODE__RGB2YUV   0x2
+#define BV_PXP_CSC2CTRL_CSC_MODE__RGB2YCbCr 0x3
+#define BM_PXP_CSC2CTRL_BYPASS 0x00000001
+
+#define HW_PXP_CSC2COEF0	(0x00000410)
+
+#define BP_PXP_CSC2COEF0_RSVD1      27
+#define BM_PXP_CSC2COEF0_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF0_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF0_RSVD1)
+#define BP_PXP_CSC2COEF0_A2      16
+#define BM_PXP_CSC2COEF0_A2 0x07FF0000
+#define BF_PXP_CSC2COEF0_A2(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF0_A2)
+#define BP_PXP_CSC2COEF0_RSVD0      11
+#define BM_PXP_CSC2COEF0_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF0_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF0_RSVD0)
+#define BP_PXP_CSC2COEF0_A1      0
+#define BM_PXP_CSC2COEF0_A1 0x000007FF
+#define BF_PXP_CSC2COEF0_A1(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF0_A1)
+
+#define HW_PXP_CSC2COEF1	(0x00000420)
+
+#define BP_PXP_CSC2COEF1_RSVD1      27
+#define BM_PXP_CSC2COEF1_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF1_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF1_RSVD1)
+#define BP_PXP_CSC2COEF1_B1      16
+#define BM_PXP_CSC2COEF1_B1 0x07FF0000
+#define BF_PXP_CSC2COEF1_B1(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF1_B1)
+#define BP_PXP_CSC2COEF1_RSVD0      11
+#define BM_PXP_CSC2COEF1_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF1_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF1_RSVD0)
+#define BP_PXP_CSC2COEF1_A3      0
+#define BM_PXP_CSC2COEF1_A3 0x000007FF
+#define BF_PXP_CSC2COEF1_A3(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF1_A3)
+
+#define HW_PXP_CSC2COEF2	(0x00000430)
+
+#define BP_PXP_CSC2COEF2_RSVD1      27
+#define BM_PXP_CSC2COEF2_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF2_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF2_RSVD1)
+#define BP_PXP_CSC2COEF2_B3      16
+#define BM_PXP_CSC2COEF2_B3 0x07FF0000
+#define BF_PXP_CSC2COEF2_B3(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF2_B3)
+#define BP_PXP_CSC2COEF2_RSVD0      11
+#define BM_PXP_CSC2COEF2_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF2_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF2_RSVD0)
+#define BP_PXP_CSC2COEF2_B2      0
+#define BM_PXP_CSC2COEF2_B2 0x000007FF
+#define BF_PXP_CSC2COEF2_B2(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF2_B2)
+
+#define HW_PXP_CSC2COEF3	(0x00000440)
+
+#define BP_PXP_CSC2COEF3_RSVD1      27
+#define BM_PXP_CSC2COEF3_RSVD1 0xF8000000
+#define BF_PXP_CSC2COEF3_RSVD1(v) \
+	(((v) << 27) & BM_PXP_CSC2COEF3_RSVD1)
+#define BP_PXP_CSC2COEF3_C2      16
+#define BM_PXP_CSC2COEF3_C2 0x07FF0000
+#define BF_PXP_CSC2COEF3_C2(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF3_C2)
+#define BP_PXP_CSC2COEF3_RSVD0      11
+#define BM_PXP_CSC2COEF3_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF3_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF3_RSVD0)
+#define BP_PXP_CSC2COEF3_C1      0
+#define BM_PXP_CSC2COEF3_C1 0x000007FF
+#define BF_PXP_CSC2COEF3_C1(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF3_C1)
+
+#define HW_PXP_CSC2COEF4	(0x00000450)
+
+#define BP_PXP_CSC2COEF4_RSVD1      25
+#define BM_PXP_CSC2COEF4_RSVD1 0xFE000000
+#define BF_PXP_CSC2COEF4_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2COEF4_RSVD1)
+#define BP_PXP_CSC2COEF4_D1      16
+#define BM_PXP_CSC2COEF4_D1 0x01FF0000
+#define BF_PXP_CSC2COEF4_D1(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF4_D1)
+#define BP_PXP_CSC2COEF4_RSVD0      11
+#define BM_PXP_CSC2COEF4_RSVD0 0x0000F800
+#define BF_PXP_CSC2COEF4_RSVD0(v)  \
+	(((v) << 11) & BM_PXP_CSC2COEF4_RSVD0)
+#define BP_PXP_CSC2COEF4_C3      0
+#define BM_PXP_CSC2COEF4_C3 0x000007FF
+#define BF_PXP_CSC2COEF4_C3(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF4_C3)
+
+#define HW_PXP_CSC2COEF5	(0x00000460)
+
+#define BP_PXP_CSC2COEF5_RSVD1      25
+#define BM_PXP_CSC2COEF5_RSVD1 0xFE000000
+#define BF_PXP_CSC2COEF5_RSVD1(v) \
+	(((v) << 25) & BM_PXP_CSC2COEF5_RSVD1)
+#define BP_PXP_CSC2COEF5_D3      16
+#define BM_PXP_CSC2COEF5_D3 0x01FF0000
+#define BF_PXP_CSC2COEF5_D3(v)  \
+	(((v) << 16) & BM_PXP_CSC2COEF5_D3)
+#define BP_PXP_CSC2COEF5_RSVD0      9
+#define BM_PXP_CSC2COEF5_RSVD0 0x0000FE00
+#define BF_PXP_CSC2COEF5_RSVD0(v)  \
+	(((v) << 9) & BM_PXP_CSC2COEF5_RSVD0)
+#define BP_PXP_CSC2COEF5_D2      0
+#define BM_PXP_CSC2COEF5_D2 0x000001FF
+#define BF_PXP_CSC2COEF5_D2(v)  \
+	(((v) << 0) & BM_PXP_CSC2COEF5_D2)
+
+#define HW_PXP_LUT_CTRL	(0x00000470)
+
+#define BM_PXP_LUT_CTRL_BYPASS 0x80000000
+#define BP_PXP_LUT_CTRL_RSVD      8
+#define BM_PXP_LUT_CTRL_RSVD 0x7FFFFF00
+#define BF_PXP_LUT_CTRL_RSVD(v)  \
+	(((v) << 8) & BM_PXP_LUT_CTRL_RSVD)
+#define BP_PXP_LUT_CTRL_ADDR      0
+#define BM_PXP_LUT_CTRL_ADDR 0x000000FF
+#define BF_PXP_LUT_CTRL_ADDR(v)  \
+	(((v) << 0) & BM_PXP_LUT_CTRL_ADDR)
+
+#define HW_PXP_LUT	(0x00000480)
+
+#define BP_PXP_LUT_RSVD      8
+#define BM_PXP_LUT_RSVD 0xFFFFFF00
+#define BF_PXP_LUT_RSVD(v) \
+	(((v) << 8) & BM_PXP_LUT_RSVD)
+#define BP_PXP_LUT_DATA      0
+#define BM_PXP_LUT_DATA 0x000000FF
+#define BF_PXP_LUT_DATA(v)  \
+	(((v) << 0) & BM_PXP_LUT_DATA)
+
+#define HW_PXP_HIST_CTRL	(0x00000490)
+
+#define BP_PXP_HIST_CTRL_RSVD      6
+#define BM_PXP_HIST_CTRL_RSVD 0xFFFFFFC0
+#define BF_PXP_HIST_CTRL_RSVD(v) \
+	(((v) << 6) & BM_PXP_HIST_CTRL_RSVD)
+#define BP_PXP_HIST_CTRL_PANEL_MODE      4
+#define BM_PXP_HIST_CTRL_PANEL_MODE 0x00000030
+#define BF_PXP_HIST_CTRL_PANEL_MODE(v)  \
+	(((v) << 4) & BM_PXP_HIST_CTRL_PANEL_MODE)
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY4  0x0
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY8  0x1
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY16 0x2
+#define BV_PXP_HIST_CTRL_PANEL_MODE__GRAY32 0x3
+#define BP_PXP_HIST_CTRL_STATUS      0
+#define BM_PXP_HIST_CTRL_STATUS 0x0000000F
+#define BF_PXP_HIST_CTRL_STATUS(v)  \
+	(((v) << 0) & BM_PXP_HIST_CTRL_STATUS)
+
+#define HW_PXP_HIST2_PARAM	(0x000004a0)
+
+#define BP_PXP_HIST2_PARAM_RSVD      16
+#define BM_PXP_HIST2_PARAM_RSVD 0xFFFF0000
+#define BF_PXP_HIST2_PARAM_RSVD(v) \
+	(((v) << 16) & BM_PXP_HIST2_PARAM_RSVD)
+#define BP_PXP_HIST2_PARAM_RSVD1      13
+#define BM_PXP_HIST2_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST2_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST2_PARAM_RSVD1)
+#define BP_PXP_HIST2_PARAM_VALUE1      8
+#define BM_PXP_HIST2_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST2_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST2_PARAM_VALUE1)
+#define BP_PXP_HIST2_PARAM_RSVD0      5
+#define BM_PXP_HIST2_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST2_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST2_PARAM_RSVD0)
+#define BP_PXP_HIST2_PARAM_VALUE0      0
+#define BM_PXP_HIST2_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST2_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST2_PARAM_VALUE0)
+
+#define HW_PXP_HIST4_PARAM	(0x000004b0)
+
+#define BP_PXP_HIST4_PARAM_RSVD3      29
+#define BM_PXP_HIST4_PARAM_RSVD3 0xE0000000
+#define BF_PXP_HIST4_PARAM_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST4_PARAM_RSVD3)
+#define BP_PXP_HIST4_PARAM_VALUE3      24
+#define BM_PXP_HIST4_PARAM_VALUE3 0x1F000000
+#define BF_PXP_HIST4_PARAM_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST4_PARAM_VALUE3)
+#define BP_PXP_HIST4_PARAM_RSVD2      21
+#define BM_PXP_HIST4_PARAM_RSVD2 0x00E00000
+#define BF_PXP_HIST4_PARAM_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST4_PARAM_RSVD2)
+#define BP_PXP_HIST4_PARAM_VALUE2      16
+#define BM_PXP_HIST4_PARAM_VALUE2 0x001F0000
+#define BF_PXP_HIST4_PARAM_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST4_PARAM_VALUE2)
+#define BP_PXP_HIST4_PARAM_RSVD1      13
+#define BM_PXP_HIST4_PARAM_RSVD1 0x0000E000
+#define BF_PXP_HIST4_PARAM_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST4_PARAM_RSVD1)
+#define BP_PXP_HIST4_PARAM_VALUE1      8
+#define BM_PXP_HIST4_PARAM_VALUE1 0x00001F00
+#define BF_PXP_HIST4_PARAM_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST4_PARAM_VALUE1)
+#define BP_PXP_HIST4_PARAM_RSVD0      5
+#define BM_PXP_HIST4_PARAM_RSVD0 0x000000E0
+#define BF_PXP_HIST4_PARAM_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST4_PARAM_RSVD0)
+#define BP_PXP_HIST4_PARAM_VALUE0      0
+#define BM_PXP_HIST4_PARAM_VALUE0 0x0000001F
+#define BF_PXP_HIST4_PARAM_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST4_PARAM_VALUE0)
+
+#define HW_PXP_HIST8_PARAM0	(0x000004c0)
+
+#define BP_PXP_HIST8_PARAM0_RSVD3      29
+#define BM_PXP_HIST8_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST8_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM0_RSVD3)
+#define BP_PXP_HIST8_PARAM0_VALUE3      24
+#define BM_PXP_HIST8_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST8_PARAM0_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM0_VALUE3)
+#define BP_PXP_HIST8_PARAM0_RSVD2      21
+#define BM_PXP_HIST8_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST8_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM0_RSVD2)
+#define BP_PXP_HIST8_PARAM0_VALUE2      16
+#define BM_PXP_HIST8_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST8_PARAM0_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM0_VALUE2)
+#define BP_PXP_HIST8_PARAM0_RSVD1      13
+#define BM_PXP_HIST8_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST8_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM0_RSVD1)
+#define BP_PXP_HIST8_PARAM0_VALUE1      8
+#define BM_PXP_HIST8_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST8_PARAM0_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM0_VALUE1)
+#define BP_PXP_HIST8_PARAM0_RSVD0      5
+#define BM_PXP_HIST8_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST8_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM0_RSVD0)
+#define BP_PXP_HIST8_PARAM0_VALUE0      0
+#define BM_PXP_HIST8_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST8_PARAM0_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM0_VALUE0)
+
+#define HW_PXP_HIST8_PARAM1	(0x000004d0)
+
+#define BP_PXP_HIST8_PARAM1_RSVD7      29
+#define BM_PXP_HIST8_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST8_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST8_PARAM1_RSVD7)
+#define BP_PXP_HIST8_PARAM1_VALUE7      24
+#define BM_PXP_HIST8_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST8_PARAM1_VALUE7(v)  \
+	(((v) << 24) & BM_PXP_HIST8_PARAM1_VALUE7)
+#define BP_PXP_HIST8_PARAM1_RSVD6      21
+#define BM_PXP_HIST8_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST8_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST8_PARAM1_RSVD6)
+#define BP_PXP_HIST8_PARAM1_VALUE6      16
+#define BM_PXP_HIST8_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST8_PARAM1_VALUE6(v)  \
+	(((v) << 16) & BM_PXP_HIST8_PARAM1_VALUE6)
+#define BP_PXP_HIST8_PARAM1_RSVD5      13
+#define BM_PXP_HIST8_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST8_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST8_PARAM1_RSVD5)
+#define BP_PXP_HIST8_PARAM1_VALUE5      8
+#define BM_PXP_HIST8_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST8_PARAM1_VALUE5(v)  \
+	(((v) << 8) & BM_PXP_HIST8_PARAM1_VALUE5)
+#define BP_PXP_HIST8_PARAM1_RSVD4      5
+#define BM_PXP_HIST8_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST8_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST8_PARAM1_RSVD4)
+#define BP_PXP_HIST8_PARAM1_VALUE4      0
+#define BM_PXP_HIST8_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST8_PARAM1_VALUE4(v)  \
+	(((v) << 0) & BM_PXP_HIST8_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM0	(0x000004e0)
+
+#define BP_PXP_HIST16_PARAM0_RSVD3      29
+#define BM_PXP_HIST16_PARAM0_RSVD3 0xE0000000
+#define BF_PXP_HIST16_PARAM0_RSVD3(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM0_RSVD3)
+#define BP_PXP_HIST16_PARAM0_VALUE3      24
+#define BM_PXP_HIST16_PARAM0_VALUE3 0x1F000000
+#define BF_PXP_HIST16_PARAM0_VALUE3(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM0_VALUE3)
+#define BP_PXP_HIST16_PARAM0_RSVD2      21
+#define BM_PXP_HIST16_PARAM0_RSVD2 0x00E00000
+#define BF_PXP_HIST16_PARAM0_RSVD2(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM0_RSVD2)
+#define BP_PXP_HIST16_PARAM0_VALUE2      16
+#define BM_PXP_HIST16_PARAM0_VALUE2 0x001F0000
+#define BF_PXP_HIST16_PARAM0_VALUE2(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM0_VALUE2)
+#define BP_PXP_HIST16_PARAM0_RSVD1      13
+#define BM_PXP_HIST16_PARAM0_RSVD1 0x0000E000
+#define BF_PXP_HIST16_PARAM0_RSVD1(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM0_RSVD1)
+#define BP_PXP_HIST16_PARAM0_VALUE1      8
+#define BM_PXP_HIST16_PARAM0_VALUE1 0x00001F00
+#define BF_PXP_HIST16_PARAM0_VALUE1(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM0_VALUE1)
+#define BP_PXP_HIST16_PARAM0_RSVD0      5
+#define BM_PXP_HIST16_PARAM0_RSVD0 0x000000E0
+#define BF_PXP_HIST16_PARAM0_RSVD0(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM0_RSVD0)
+#define BP_PXP_HIST16_PARAM0_VALUE0      0
+#define BM_PXP_HIST16_PARAM0_VALUE0 0x0000001F
+#define BF_PXP_HIST16_PARAM0_VALUE0(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM0_VALUE0)
+
+#define HW_PXP_HIST16_PARAM1	(0x000004f0)
+
+#define BP_PXP_HIST16_PARAM1_RSVD7      29
+#define BM_PXP_HIST16_PARAM1_RSVD7 0xE0000000
+#define BF_PXP_HIST16_PARAM1_RSVD7(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM1_RSVD7)
+#define BP_PXP_HIST16_PARAM1_VALUE7      24
+#define BM_PXP_HIST16_PARAM1_VALUE7 0x1F000000
+#define BF_PXP_HIST16_PARAM1_VALUE7(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM1_VALUE7)
+#define BP_PXP_HIST16_PARAM1_RSVD6      21
+#define BM_PXP_HIST16_PARAM1_RSVD6 0x00E00000
+#define BF_PXP_HIST16_PARAM1_RSVD6(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM1_RSVD6)
+#define BP_PXP_HIST16_PARAM1_VALUE6      16
+#define BM_PXP_HIST16_PARAM1_VALUE6 0x001F0000
+#define BF_PXP_HIST16_PARAM1_VALUE6(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM1_VALUE6)
+#define BP_PXP_HIST16_PARAM1_RSVD5      13
+#define BM_PXP_HIST16_PARAM1_RSVD5 0x0000E000
+#define BF_PXP_HIST16_PARAM1_RSVD5(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM1_RSVD5)
+#define BP_PXP_HIST16_PARAM1_VALUE5      8
+#define BM_PXP_HIST16_PARAM1_VALUE5 0x00001F00
+#define BF_PXP_HIST16_PARAM1_VALUE5(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM1_VALUE5)
+#define BP_PXP_HIST16_PARAM1_RSVD4      5
+#define BM_PXP_HIST16_PARAM1_RSVD4 0x000000E0
+#define BF_PXP_HIST16_PARAM1_RSVD4(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM1_RSVD4)
+#define BP_PXP_HIST16_PARAM1_VALUE4      0
+#define BM_PXP_HIST16_PARAM1_VALUE4 0x0000001F
+#define BF_PXP_HIST16_PARAM1_VALUE4(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM1_VALUE4)
+
+#define HW_PXP_HIST16_PARAM2	(0x00000500)
+
+#define BP_PXP_HIST16_PARAM2_RSVD11      29
+#define BM_PXP_HIST16_PARAM2_RSVD11 0xE0000000
+#define BF_PXP_HIST16_PARAM2_RSVD11(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM2_RSVD11)
+#define BP_PXP_HIST16_PARAM2_VALUE11      24
+#define BM_PXP_HIST16_PARAM2_VALUE11 0x1F000000
+#define BF_PXP_HIST16_PARAM2_VALUE11(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM2_VALUE11)
+#define BP_PXP_HIST16_PARAM2_RSVD10      21
+#define BM_PXP_HIST16_PARAM2_RSVD10 0x00E00000
+#define BF_PXP_HIST16_PARAM2_RSVD10(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM2_RSVD10)
+#define BP_PXP_HIST16_PARAM2_VALUE10      16
+#define BM_PXP_HIST16_PARAM2_VALUE10 0x001F0000
+#define BF_PXP_HIST16_PARAM2_VALUE10(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM2_VALUE10)
+#define BP_PXP_HIST16_PARAM2_RSVD9      13
+#define BM_PXP_HIST16_PARAM2_RSVD9 0x0000E000
+#define BF_PXP_HIST16_PARAM2_RSVD9(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM2_RSVD9)
+#define BP_PXP_HIST16_PARAM2_VALUE9      8
+#define BM_PXP_HIST16_PARAM2_VALUE9 0x00001F00
+#define BF_PXP_HIST16_PARAM2_VALUE9(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM2_VALUE9)
+#define BP_PXP_HIST16_PARAM2_RSVD8      5
+#define BM_PXP_HIST16_PARAM2_RSVD8 0x000000E0
+#define BF_PXP_HIST16_PARAM2_RSVD8(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM2_RSVD8)
+#define BP_PXP_HIST16_PARAM2_VALUE8      0
+#define BM_PXP_HIST16_PARAM2_VALUE8 0x0000001F
+#define BF_PXP_HIST16_PARAM2_VALUE8(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM2_VALUE8)
+
+#define HW_PXP_HIST16_PARAM3	(0x00000510)
+
+#define BP_PXP_HIST16_PARAM3_RSVD15      29
+#define BM_PXP_HIST16_PARAM3_RSVD15 0xE0000000
+#define BF_PXP_HIST16_PARAM3_RSVD15(v) \
+	(((v) << 29) & BM_PXP_HIST16_PARAM3_RSVD15)
+#define BP_PXP_HIST16_PARAM3_VALUE15      24
+#define BM_PXP_HIST16_PARAM3_VALUE15 0x1F000000
+#define BF_PXP_HIST16_PARAM3_VALUE15(v)  \
+	(((v) << 24) & BM_PXP_HIST16_PARAM3_VALUE15)
+#define BP_PXP_HIST16_PARAM3_RSVD14      21
+#define BM_PXP_HIST16_PARAM3_RSVD14 0x00E00000
+#define BF_PXP_HIST16_PARAM3_RSVD14(v)  \
+	(((v) << 21) & BM_PXP_HIST16_PARAM3_RSVD14)
+#define BP_PXP_HIST16_PARAM3_VALUE14      16
+#define BM_PXP_HIST16_PARAM3_VALUE14 0x001F0000
+#define BF_PXP_HIST16_PARAM3_VALUE14(v)  \
+	(((v) << 16) & BM_PXP_HIST16_PARAM3_VALUE14)
+#define BP_PXP_HIST16_PARAM3_RSVD13      13
+#define BM_PXP_HIST16_PARAM3_RSVD13 0x0000E000
+#define BF_PXP_HIST16_PARAM3_RSVD13(v)  \
+	(((v) << 13) & BM_PXP_HIST16_PARAM3_RSVD13)
+#define BP_PXP_HIST16_PARAM3_VALUE13      8
+#define BM_PXP_HIST16_PARAM3_VALUE13 0x00001F00
+#define BF_PXP_HIST16_PARAM3_VALUE13(v)  \
+	(((v) << 8) & BM_PXP_HIST16_PARAM3_VALUE13)
+#define BP_PXP_HIST16_PARAM3_RSVD12      5
+#define BM_PXP_HIST16_PARAM3_RSVD12 0x000000E0
+#define BF_PXP_HIST16_PARAM3_RSVD12(v)  \
+	(((v) << 5) & BM_PXP_HIST16_PARAM3_RSVD12)
+#define BP_PXP_HIST16_PARAM3_VALUE12      0
+#define BM_PXP_HIST16_PARAM3_VALUE12 0x0000001F
+#define BF_PXP_HIST16_PARAM3_VALUE12(v)  \
+	(((v) << 0) & BM_PXP_HIST16_PARAM3_VALUE12)
+#endif /* __ARCH_ARM___PXP_H */
diff --git a/include/linux/pxp_dma.h b/include/linux/pxp_dma.h
new file mode 100644
index 0000000..13e524d
--- /dev/null
+++ b/include/linux/pxp_dma.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _PXP_DMA
+#define _PXP_DMA
+
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long dma_addr_t;
+typedef unsigned char bool;
+#endif
+
+/*  PXP Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name PXP Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define PXP_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define PXP_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define PXP_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define PXP_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define PXP_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define PXP_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define PXP_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define PXP_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define PXP_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define PXP_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define PXP_PIX_FMT_NV12    fourcc('N', 'V', '1', '2')	/* 12  Y/CbCr 4:2:0  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define PXP_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define PXP_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define PXP_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define PXP_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define PXP_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+#define PXP_LUT_NONE		0x0
+#define PXP_LUT_INVERT		0x1
+
+#define NR_PXP_VIRT_CHANNEL	16
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+
+/* Order significant! */
+enum pxp_channel_status {
+	PXP_CHANNEL_FREE,
+	PXP_CHANNEL_INITIALIZED,
+	PXP_CHANNEL_READY,
+};
+
+struct rect {
+	int top;		/* Upper left coordinate of rectangle */
+	int left;
+	int width;
+	int height;
+};
+
+struct pxp_layer_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned int pixel_fmt;
+
+	/* layers combining parameters
+	 * (these are ignored for S0 and output
+	 * layers, and only apply for OL layer)
+	 */
+	bool combine_enable;
+	__u32 color_key_enable;
+	__u32 color_key;
+	bool global_alpha_enable;
+	__u8 global_alpha;
+	bool local_alpha_enable;
+
+	dma_addr_t paddr;
+};
+
+struct pxp_proc_data {
+	/* S0 Transformation Info */
+	int scaling;
+	int hflip;
+	int vflip;
+	int rotate;
+	int yuv;
+
+	/* Source rectangle (srect) defines the sub-rectangle
+	 * within S0 to undergo processing.
+	 */
+	struct rect srect;
+	/* Dest rect (drect) defines how to position the processed
+	 * source rectangle (after resizing) within the output frame,
+	 * whose dimensions are defined in pxp->pxp_conf_state.out_param
+	 */
+	struct rect drect;
+
+	/* Current S0 configuration */
+	__u32 bgcolor;
+
+	/* Output overlay support */
+	int overlay_state;
+
+	/* LUT transformation on Y data */
+	int lut_transform;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param ol_param[8];
+	struct pxp_layer_param out_param;
+	struct pxp_proc_data proc_data;
+	int layer_nr;
+
+	/* Users don't touch */
+	int chan_id;
+};
+
+struct pxp_mem_desc {
+	__u32 size;
+	dma_addr_t phys_addr;
+	__u32 cpu_addr;		/* cpu address to free the dma mem */
+	__u32 virt_uaddr;		/* virtual user space address */
+};
+
+#ifdef __KERNEL__
+
+struct pxp_tx_desc {
+	struct dma_async_tx_descriptor txd;
+	struct list_head list;
+	int len;
+	union {
+		struct pxp_layer_param s0_param;
+		struct pxp_layer_param out_param;
+		struct pxp_layer_param ol_param;
+	} layer_param;
+	struct pxp_proc_data proc_data;
+
+	u32 hist_status;	/* Histogram output status */
+
+	struct pxp_tx_desc *next;
+};
+
+struct pxp_channel {
+	struct dma_chan dma_chan;
+	dma_cookie_t completed;	/* last completed cookie */
+	enum pxp_channel_status status;
+	void *client;		/* Only one client per channel */
+	unsigned int n_tx_desc;
+	struct pxp_tx_desc *desc;	/* allocated tx-descriptors */
+	struct list_head active_list;	/* active tx-descriptors */
+	struct list_head free_list;	/* free tx-descriptors */
+	struct list_head queue;	/* queued tx-descriptors */
+	struct list_head list;	/* track queued channel number */
+	spinlock_t lock;	/* protects sg[0,1], queue */
+	struct mutex chan_mutex;	/* protects status, cookie, free_list */
+	int active_buffer;
+	unsigned int eof_irq;
+	char eof_name[16];	/* EOF IRQ name for request_irq()  */
+};
+
+struct pxp_irq_info {
+	wait_queue_head_t waitq;
+	int irq_pending;
+	int hist_status;
+};
+
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+
+void pxp_txd_ack(struct dma_async_tx_descriptor *txd,
+		 struct pxp_channel *pxp_chan);
+#endif
+
+#endif
-- 
1.5.4.4

