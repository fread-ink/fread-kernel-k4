From ae06586a50296b86254d34fc1ec4e50d3f5f3320 Mon Sep 17 00:00:00 2001
From: Albert Chen <R65187@freescale.com>
Date: Thu, 28 Jan 2010 09:57:57 +0800
Subject: [PATCH] ENGR00117742-1  add usb support for mx28

	add usb support for mx28
	include usb host and usb device

Signed-off-by: Albert Chen <r65187@freescale.com>
---
 arch/arm/configs/imx28evk_defconfig             |  231 +++++-
 arch/arm/mach-mx28/Kconfig                      |    1 +
 arch/arm/mach-mx28/Makefile                     |    6 +
 arch/arm/mach-mx28/clock.c                      |   28 +
 arch/arm/mach-mx28/mx28evk_pins.c               |   13 +
 arch/arm/mach-mx28/regs-digctl.h                | 1022 +++++++++++++++++++++++
 arch/arm/mach-mx28/usb.h                        |  109 +++
 arch/arm/mach-mx28/usb_dr.c                     |  127 +++
 arch/arm/mach-mx28/usb_h1.c                     |   81 ++
 arch/arm/plat-mxs/Makefile                      |    1 +
 arch/arm/plat-mxs/include/mach/arc_otg.h        |  166 ++++
 arch/arm/plat-mxs/include/mach/fsl_usb.h        |   66 ++
 arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h |   46 +
 arch/arm/plat-mxs/regs-usbphy.h                 |  380 +++++++++
 arch/arm/plat-mxs/usb_common.c                  |  383 +++++++++
 arch/arm/plat-mxs/utmixc.c                      |   84 ++
 drivers/usb/gadget/Kconfig                      |    5 +-
 drivers/usb/gadget/arcotg_udc.h                 |   26 +-
 drivers/usb/host/Kconfig                        |   52 ++-
 include/linux/fsl_devices.h                     |   23 +-
 20 files changed, 2823 insertions(+), 27 deletions(-)

diff --git a/arch/arm/configs/imx28evk_defconfig b/arch/arm/configs/imx28evk_defconfig
index 529d539..0c066e3 100644
--- a/arch/arm/configs/imx28evk_defconfig
+++ b/arch/arm/configs/imx28evk_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.31
-# Wed Jan 27 18:03:15 2010
+# Wed Jan 27 16:30:16 2010
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -71,6 +71,10 @@ CONFIG_INITRAMFS_SOURCE=""
 CONFIG_RD_GZIP=y
 CONFIG_RD_BZIP2=y
 CONFIG_RD_LZMA=y
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
@@ -417,6 +421,7 @@ CONFIG_BLK_DEV=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=4
 CONFIG_BLK_DEV_RAM_SIZE=8192
@@ -589,6 +594,8 @@ CONFIG_MOUSE_PS2_TRACKPOINT=y
 # CONFIG_MOUSE_PS2_ELANTECH is not set
 # CONFIG_MOUSE_PS2_TOUCHKIT is not set
 CONFIG_MOUSE_SERIAL=m
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
 CONFIG_MOUSE_VSXXXAA=m
 # CONFIG_MOUSE_GPIO is not set
 # CONFIG_MOUSE_SYNAPTICS_I2C is not set
@@ -613,6 +620,7 @@ CONFIG_INPUT_JOYSTICK=y
 # CONFIG_JOYSTICK_TWIDJOY is not set
 # CONFIG_JOYSTICK_ZHENHUA is not set
 # CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
 # CONFIG_INPUT_TABLET is not set
 CONFIG_INPUT_TOUCHSCREEN=y
 # CONFIG_TOUCHSCREEN_AD7879_I2C is not set
@@ -628,10 +636,17 @@ CONFIG_TOUCHSCREEN_GUNZE=m
 # CONFIG_TOUCHSCREEN_PENMOUNT is not set
 # CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
 # CONFIG_TOUCHSCREEN_W90X900 is not set
 CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
 CONFIG_INPUT_UINPUT=m
 # CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
 
@@ -714,6 +729,7 @@ CONFIG_I2C_MXS_SELECT0=y
 #
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
 
 #
 # Other I2C/SMBus bus drivers
@@ -770,6 +786,11 @@ CONFIG_WATCHDOG=y
 #
 # CONFIG_SOFT_WATCHDOG is not set
 CONFIG_MXS_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
 CONFIG_SSB_POSSIBLE=y
 
 #
@@ -818,8 +839,211 @@ CONFIG_SSB=m
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 # CONFIG_SOUND is not set
-# CONFIG_HID_SUPPORT is not set
-# CONFIG_USB_SUPPORT is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_H1=y
+CONFIG_USB_EHCI_ARC_OTG=y
+# CONFIG_USB_STATIC_IRAM is not set
+# CONFIG_USB_EHCI_FSL_MC13783 is not set
+# CONFIG_USB_EHCI_FSL_1301 is not set
+# CONFIG_USB_EHCI_FSL_1504 is not set
+CONFIG_USB_EHCI_FSL_UTMI=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=m
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_ARC_OTG=y
+# CONFIG_USB_GADGET_FSL_MC13783 is not set
+# CONFIG_USB_GADGET_FSL_1301 is not set
+# CONFIG_USB_GADGET_FSL_1504 is not set
+CONFIG_USB_GADGET_FSL_UTMI=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
 CONFIG_MMC_UNSAFE_RESUME=y
@@ -1130,6 +1354,7 @@ CONFIG_SECURITY_NETWORK=y
 # CONFIG_SECURITY_NETWORK_XFRM is not set
 # CONFIG_SECURITY_PATH is not set
 # CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
 CONFIG_LSM_MMAP_MIN_ADDR=65536
 CONFIG_SECURITY_SELINUX=y
 CONFIG_SECURITY_SELINUX_BOOTPARAM=y
diff --git a/arch/arm/mach-mx28/Kconfig b/arch/arm/mach-mx28/Kconfig
index a46d7f0..c78d48d 100644
--- a/arch/arm/mach-mx28/Kconfig
+++ b/arch/arm/mach-mx28/Kconfig
@@ -4,5 +4,6 @@ choice
 config MACH_MX28EVK
 	bool "Freescale MX28 EVK board"
 	depends on ARCH_MX28
+	select USB_ARCH_HAS_EHCI
 
 endchoice
diff --git a/arch/arm/mach-mx28/Makefile b/arch/arm/mach-mx28/Makefile
index 530dd11..b323224 100644
--- a/arch/arm/mach-mx28/Makefile
+++ b/arch/arm/mach-mx28/Makefile
@@ -6,3 +6,9 @@ obj-y += pinctrl.o clock.o device.o
 # Board select
 obj-$(CONFIG_MACH_MX28EVK) += mx28evk.o mx28evk_pins.o
 obj-$(CONFIG_GENERIC_GPIO) += gpio.o
+
+# USB support
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y   += usb_dr.o
+endif
+obj-$(CONFIG_USB_EHCI_ARC_H1)   += usb_h1.o
diff --git a/arch/arm/mach-mx28/clock.c b/arch/arm/mach-mx28/clock.c
index 0a2f271..0bf8a0f 100644
--- a/arch/arm/mach-mx28/clock.c
+++ b/arch/arm/mach-mx28/clock.c
@@ -27,8 +27,10 @@
 #include <mach/clock.h>
 
 #include "regs-clkctrl.h"
+#include "regs-digctl.h"
 
 #define CLKCTRL_BASE_ADDR IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define DIGCTRL_BASE_ADDR IO_ADDRESS(DIGCTL_PHYS_ADDR)
 
 /* external clock input */
 static struct clk xtal_clk[];
@@ -751,6 +753,24 @@ static struct clk pcmspdif_clk = {
 	.enable_bits = BM_CLKCTRL_SPDIF_CLKGATE,
 };
 
+/* usb_clk for usb0 */
+static struct clk usb_clk0 = {
+	.parent = &pll_clk[0],
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL,
+	.enable_bits = BM_DIGCTL_CTRL_USB0_CLKGATE,
+};
+
+/* usb_clk for usb1 */
+static struct clk usb_clk1 = {
+	.parent = &pll_clk[1],
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL,
+	.enable_bits = BM_DIGCTL_CTRL_USB1_CLKGATE,
+};
+
 static struct clk enet_out_clk = {
 	.parent = &pll_clk[2],
 	.enable = mx28_raw_enable,
@@ -909,6 +929,14 @@ static struct clk_lookup onchip_clocks[] = {
 	 .clk = &flexcan_clk[1],
 	 },
 	{
+	.con_id = "usb_clk0",
+	.clk = &usb_clk0,
+	},
+	{
+	.con_id = "usb_clk1",
+	.clk = &usb_clk1,
+	},
+	{
 	.con_id = "fec_clk",
 	.clk = &enet_out_clk,
 	},
diff --git a/arch/arm/mach-mx28/mx28evk_pins.c b/arch/arm/mach-mx28/mx28evk_pins.c
index e90f844..094ad32 100644
--- a/arch/arm/mach-mx28/mx28evk_pins.c
+++ b/arch/arm/mach-mx28/mx28evk_pins.c
@@ -37,6 +37,19 @@ static struct pin_desc mx28evk_fixed_pins[] = {
 	 .id = PINID_PWM1,
 	 .fun = PIN_FUN3,
 	 },
+	{
+	 .name = "usb0",
+	 .id = PINID_AUART2_TX,
+	 .fun = PIN_GPIO,
+	 .data = 1,
+	 },
+	 {
+	 .name  = "usb1",
+	 .id    = PINID_AUART2_RX,
+	 .fun   = PIN_GPIO,
+	 .data  = 1,
+	 },
+
 #if defined(CONFIG_I2C_MXS) || \
 	defined(CONFIG_I2C_MXS_MODULE)
 	{
diff --git a/arch/arm/mach-mx28/regs-digctl.h b/arch/arm/mach-mx28/regs-digctl.h
new file mode 100644
index 0000000..6ebda07
--- /dev/null
+++ b/arch/arm/mach-mx28/regs-digctl.h
@@ -0,0 +1,1022 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ARCH_ARM___DIGCTL_H
+#define __ARCH_ARM___DIGCTL_H
+
+
+#define HW_DIGCTL_CTRL	(0x00000000)
+#define HW_DIGCTL_CTRL_SET	(0x00000004)
+#define HW_DIGCTL_CTRL_CLR	(0x00000008)
+#define HW_DIGCTL_CTRL_TOG	(0x0000000c)
+
+#define BM_DIGCTL_CTRL_RSVD3	0x80000000
+#define BM_DIGCTL_CTRL_XTAL24M_GATE	0x40000000
+#define BP_DIGCTL_CTRL_RSVD2	25
+#define BM_DIGCTL_CTRL_RSVD2	0x3E000000
+#define BF_DIGCTL_CTRL_RSVD2(v)  \
+		(((v) << 25) & BM_DIGCTL_CTRL_RSVD2)
+#define BM_DIGCTL_CTRL_USB1_OVERCURRENT_ENABLE	0x01000000
+#define BM_DIGCTL_CTRL_USB0_OVERCURRENT_ENABLE	0x00800000
+#define BM_DIGCTL_CTRL_USB1_OVERCURRENT_POL	0x00400000
+#define BM_DIGCTL_CTRL_USB0_OVERCURRENT_POL	0x00200000
+#define BM_DIGCTL_CTRL_USB1_TESTMODE	0x00100000
+#define BM_DIGCTL_CTRL_USB0_TESTMODE	0x00080000
+#define BM_DIGCTL_CTRL_ANALOG_TESTMODE	0x00040000
+#define BM_DIGCTL_CTRL_DIGITAL_TESTMODE	0x00020000
+#define BM_DIGCTL_CTRL_USB1_CLKGATE	0x00010000
+#define BV_DIGCTL_CTRL_USB1_CLKGATE__RUN     0x0
+#define BV_DIGCTL_CTRL_USB1_CLKGATE__NO_CLKS 0x1
+#define BM_DIGCTL_CTRL_SAIF_LOOPBACK	0x00008000
+#define BV_DIGCTL_CTRL_SAIF_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_SAIF_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_DUART_LOOPBACK	0x00004000
+#define BV_DIGCTL_CTRL_DUART_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_DUART_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_AUART01_LOOPBACK	0x00002000
+#define BV_DIGCTL_CTRL_AUART01_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_AUART01_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_RSVD1	0x00001000
+#define BP_DIGCTL_CTRL_SAIF_CLKMUX_SEL	10
+#define BM_DIGCTL_CTRL_SAIF_CLKMUX_SEL	0x00000C00
+#define BF_DIGCTL_CTRL_SAIF_CLKMUX_SEL(v)  \
+		(((v) << 10) & BM_DIGCTL_CTRL_SAIF_CLKMUX_SEL)
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__DIRECT         0x0
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__CROSSINPUT     0x1
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__CLKSRCSAIF0PIN 0x2
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__CLKSRCSAIF1PIN 0x3
+#define BP_DIGCTL_CTRL_RSVD0	4
+#define BM_DIGCTL_CTRL_RSVD0	0x000003F0
+#define BF_DIGCTL_CTRL_RSVD0(v)  \
+		(((v) << 4) & BM_DIGCTL_CTRL_RSVD0)
+#define BM_DIGCTL_CTRL_DEBUG_DISABLE	0x00000008
+#define BM_DIGCTL_CTRL_USB0_CLKGATE	0x00000004
+#define BV_DIGCTL_CTRL_USB0_CLKGATE__RUN     0x0
+#define BV_DIGCTL_CTRL_USB0_CLKGATE__NO_CLKS 0x1
+#define BM_DIGCTL_CTRL_JTAG_SHIELD	0x00000002
+#define BV_DIGCTL_CTRL_JTAG_SHIELD__NORMAL     0x0
+#define BV_DIGCTL_CTRL_JTAG_SHIELD__SHIELDS_UP 0x1
+#define BM_DIGCTL_CTRL_LATCH_ENTROPY	0x00000001
+
+#define HW_DIGCTL_STATUS	(0x00000010)
+#define HW_DIGCTL_STATUS_SET	(0x00000014)
+#define HW_DIGCTL_STATUS_CLR	(0x00000018)
+#define HW_DIGCTL_STATUS_TOG	(0x0000001c)
+
+#define BM_DIGCTL_STATUS_USB0_HS_PRESENT	0x80000000
+#define BM_DIGCTL_STATUS_USB0_OTG_PRESENT	0x40000000
+#define BM_DIGCTL_STATUS_USB0_HOST_PRESENT	0x20000000
+#define BM_DIGCTL_STATUS_USB0_DEVICE_PRESENT	0x10000000
+#define BM_DIGCTL_STATUS_USB1_HS_PRESENT	0x08000000
+#define BM_DIGCTL_STATUS_USB1_OTG_PRESENT	0x04000000
+#define BM_DIGCTL_STATUS_USB1_HOST_PRESENT	0x02000000
+#define BM_DIGCTL_STATUS_USB1_DEVICE_PRESENT	0x01000000
+#define BP_DIGCTL_STATUS_RSVD0	5
+#define BM_DIGCTL_STATUS_RSVD0	0x00FFFFE0
+#define BF_DIGCTL_STATUS_RSVD0(v)  \
+		(((v) << 5) & BM_DIGCTL_STATUS_RSVD0)
+#define BM_DIGCTL_STATUS_JTAG_IN_USE	0x00000010
+#define BP_DIGCTL_STATUS_PACKAGE_TYPE	1
+#define BM_DIGCTL_STATUS_PACKAGE_TYPE	0x0000000E
+#define BF_DIGCTL_STATUS_PACKAGE_TYPE(v)  \
+		(((v) << 1) & BM_DIGCTL_STATUS_PACKAGE_TYPE)
+#define BM_DIGCTL_STATUS_WRITTEN	0x00000001
+
+#define HW_DIGCTL_HCLKCOUNT	(0x00000020)
+#define HW_DIGCTL_HCLKCOUNT_SET	(0x00000024)
+#define HW_DIGCTL_HCLKCOUNT_CLR	(0x00000028)
+#define HW_DIGCTL_HCLKCOUNT_TOG	(0x0000002c)
+
+#define BP_DIGCTL_HCLKCOUNT_COUNT	0
+#define BM_DIGCTL_HCLKCOUNT_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_HCLKCOUNT_COUNT(v)	(v)
+
+#define HW_DIGCTL_RAMCTRL	(0x00000030)
+#define HW_DIGCTL_RAMCTRL_SET	(0x00000034)
+#define HW_DIGCTL_RAMCTRL_CLR	(0x00000038)
+#define HW_DIGCTL_RAMCTRL_TOG	(0x0000003c)
+
+#define BP_DIGCTL_RAMCTRL_RSVD1	15
+#define BM_DIGCTL_RAMCTRL_RSVD1	0xFFFF8000
+#define BF_DIGCTL_RAMCTRL_RSVD1(v) \
+		(((v) << 15) & BM_DIGCTL_RAMCTRL_RSVD1)
+#define BM_DIGCTL_RAMCTRL_TBYPASS	0x00004000
+#define BM_DIGCTL_RAMCTRL_DEBUG_ENABLE	0x00002000
+#define BP_DIGCTL_RAMCTRL_DEBUG_CODE	8
+#define BM_DIGCTL_RAMCTRL_DEBUG_CODE	0x00001F00
+#define BF_DIGCTL_RAMCTRL_DEBUG_CODE(v)  \
+		(((v) << 8) & BM_DIGCTL_RAMCTRL_DEBUG_CODE)
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__NORMAL 0x0
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY1 0x4
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY2 0x5
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY3 0x6
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY4 0x7
+#define BP_DIGCTL_RAMCTRL_RSVD0	0
+#define BM_DIGCTL_RAMCTRL_RSVD0	0x000000FF
+#define BF_DIGCTL_RAMCTRL_RSVD0(v)  \
+		(((v) << 0) & BM_DIGCTL_RAMCTRL_RSVD0)
+
+#define HW_DIGCTL_EMI_STATUS	(0x00000040)
+#define HW_DIGCTL_EMI_STATUS_SET	(0x00000044)
+#define HW_DIGCTL_EMI_STATUS_CLR	(0x00000048)
+#define HW_DIGCTL_EMI_STATUS_TOG	(0x0000004c)
+
+#define BP_DIGCTL_EMI_STATUS_RSVD0	5
+#define BM_DIGCTL_EMI_STATUS_RSVD0	0xFFFFFFE0
+#define BF_DIGCTL_EMI_STATUS_RSVD0(v) \
+		(((v) << 5) & BM_DIGCTL_EMI_STATUS_RSVD0)
+#define BP_DIGCTL_EMI_STATUS_POWER_MODE	0
+#define BM_DIGCTL_EMI_STATUS_POWER_MODE	0x0000001F
+#define BF_DIGCTL_EMI_STATUS_POWER_MODE(v)  \
+		(((v) << 0) & BM_DIGCTL_EMI_STATUS_POWER_MODE)
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM5    0x1
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM4    0x2
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM3    0x4
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM2    0x8
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM1    0x10
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__NORMAL 0x0
+
+#define HW_DIGCTL_READ_MARGIN	(0x00000050)
+#define HW_DIGCTL_READ_MARGIN_SET	(0x00000054)
+#define HW_DIGCTL_READ_MARGIN_CLR	(0x00000058)
+#define HW_DIGCTL_READ_MARGIN_TOG	(0x0000005c)
+
+#define BP_DIGCTL_READ_MARGIN_RSVD0	4
+#define BM_DIGCTL_READ_MARGIN_RSVD0	0xFFFFFFF0
+#define BF_DIGCTL_READ_MARGIN_RSVD0(v) \
+		(((v) << 4) & BM_DIGCTL_READ_MARGIN_RSVD0)
+#define BP_DIGCTL_READ_MARGIN_ROM	0
+#define BM_DIGCTL_READ_MARGIN_ROM	0x0000000F
+#define BF_DIGCTL_READ_MARGIN_ROM(v)  \
+		(((v) << 0) & BM_DIGCTL_READ_MARGIN_ROM)
+
+#define HW_DIGCTL_WRITEONCE	(0x00000060)
+
+#define BP_DIGCTL_WRITEONCE_BITS	0
+#define BM_DIGCTL_WRITEONCE_BITS	0xFFFFFFFF
+#define BF_DIGCTL_WRITEONCE_BITS(v)	(v)
+
+#define HW_DIGCTL_BIST_CTL	(0x00000070)
+#define HW_DIGCTL_BIST_CTL_SET	(0x00000074)
+#define HW_DIGCTL_BIST_CTL_CLR	(0x00000078)
+#define HW_DIGCTL_BIST_CTL_TOG	(0x0000007c)
+
+#define BM_DIGCTL_BIST_CTL_BIST_TESTMODE	0x80000000
+#define BM_DIGCTL_BIST_CTL_BIST_RESETN	0x40000000
+#define BM_DIGCTL_BIST_CTL_BIST_DEBUGZ	0x20000000
+#define BM_DIGCTL_BIST_CTL_BIST_CHECKB	0x10000000
+#define BM_DIGCTL_BIST_CTL_BIST_RESUME	0x08000000
+#define BP_DIGCTL_BIST_CTL_RSVD0	15
+#define BM_DIGCTL_BIST_CTL_RSVD0	0x07FF8000
+#define BF_DIGCTL_BIST_CTL_RSVD0(v)  \
+		(((v) << 15) & BM_DIGCTL_BIST_CTL_RSVD0)
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_RETENTION	0x00004000
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_PASS	0x00002000
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_FAIL	0x00001000
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_DONE	0x00000800
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_START	0x00000400
+#define BM_DIGCTL_BIST_CTL_PXP_BIST_START	0x00000200
+#define BM_DIGCTL_BIST_CTL_LCDIF_BIST_START	0x00000100
+#define BM_DIGCTL_BIST_CTL_DCP_BIST_START	0x00000080
+#define BM_DIGCTL_BIST_CTL_ENET_BIST_START	0x00000040
+#define BM_DIGCTL_BIST_CTL_USB1_BIST_START	0x00000020
+#define BM_DIGCTL_BIST_CTL_USB0_BIST_START	0x00000010
+#define BM_DIGCTL_BIST_CTL_DMA1_BIST_START	0x00000008
+#define BM_DIGCTL_BIST_CTL_DMA0_BIST_START	0x00000004
+#define BM_DIGCTL_BIST_CTL_CACHE_BIST_START	0x00000002
+#define BM_DIGCTL_BIST_CTL_CAN_BIST_START	0x00000001
+
+#define HW_DIGCTL_BIST_STATUS	(0x00000080)
+#define HW_DIGCTL_BIST_STATUS_SET	(0x00000084)
+#define HW_DIGCTL_BIST_STATUS_CLR	(0x00000088)
+#define HW_DIGCTL_BIST_STATUS_TOG	(0x0000008c)
+
+#define BP_DIGCTL_BIST_STATUS_RSVD0	30
+#define BM_DIGCTL_BIST_STATUS_RSVD0	0xC0000000
+#define BF_DIGCTL_BIST_STATUS_RSVD0(v) \
+		(((v) << 30) & BM_DIGCTL_BIST_STATUS_RSVD0)
+#define BM_DIGCTL_BIST_STATUS_PXP_BIST_RETENTION	0x20000000
+#define BM_DIGCTL_BIST_STATUS_LCDIF_BIST_RETENTION	0x10000000
+#define BM_DIGCTL_BIST_STATUS_DCP_BIST_RETENTION	0x08000000
+#define BM_DIGCTL_BIST_STATUS_ENET_BIST_RETENTION	0x04000000
+#define BM_DIGCTL_BIST_STATUS_USB1_BIST_RETENTION	0x02000000
+#define BM_DIGCTL_BIST_STATUS_USB0_BIST_RETENTION	0x01000000
+#define BM_DIGCTL_BIST_STATUS_DMA1_BIST_RETENTION	0x00800000
+#define BM_DIGCTL_BIST_STATUS_DMA0_BIST_RETENTION	0x00400000
+#define BM_DIGCTL_BIST_STATUS_CACHE_BIST_RETENTION	0x00200000
+#define BM_DIGCTL_BIST_STATUS_CAN_BIST_RETENTION	0x00100000
+#define BM_DIGCTL_BIST_STATUS_PXP_BIST_FAIL	0x00080000
+#define BM_DIGCTL_BIST_STATUS_LCDIF_BIST_FAIL	0x00040000
+#define BM_DIGCTL_BIST_STATUS_DCP_BIST_FAIL	0x00020000
+#define BM_DIGCTL_BIST_STATUS_ENET_BIST_FAIL	0x00010000
+#define BM_DIGCTL_BIST_STATUS_USB1_BIST_FAIL	0x00008000
+#define BM_DIGCTL_BIST_STATUS_USB0_BIST_FAIL	0x00004000
+#define BM_DIGCTL_BIST_STATUS_DMA1_BIST_FAIL	0x00002000
+#define BM_DIGCTL_BIST_STATUS_DMA0_BIST_FAIL	0x00001000
+#define BM_DIGCTL_BIST_STATUS_CACHE_BIST_FAIL	0x00000800
+#define BM_DIGCTL_BIST_STATUS_CAN_BIST_FAIL	0x00000400
+#define BM_DIGCTL_BIST_STATUS_PXP_BIST_DONE	0x00000200
+#define BM_DIGCTL_BIST_STATUS_LCDIF_BIST_DONE	0x00000100
+#define BM_DIGCTL_BIST_STATUS_DCP_BIST_DONE	0x00000080
+#define BM_DIGCTL_BIST_STATUS_ENET_BIST_DONE	0x00000040
+#define BM_DIGCTL_BIST_STATUS_USB1_BIST_DONE	0x00000020
+#define BM_DIGCTL_BIST_STATUS_USB0_BIST_DONE	0x00000010
+#define BM_DIGCTL_BIST_STATUS_DMA1_BIST_DONE	0x00000008
+#define BM_DIGCTL_BIST_STATUS_DMA0_BIST_DONE	0x00000004
+#define BM_DIGCTL_BIST_STATUS_CACHE_BIST_DONE	0x00000002
+#define BM_DIGCTL_BIST_STATUS_CAN_BIST_DONE	0x00000001
+
+#define HW_DIGCTL_ENTROPY	(0x00000090)
+
+#define BP_DIGCTL_ENTROPY_VALUE	0
+#define BM_DIGCTL_ENTROPY_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_ENTROPY_VALUE(v)	(v)
+
+#define HW_DIGCTL_ENTROPY_LATCHED	(0x000000a0)
+
+#define BP_DIGCTL_ENTROPY_LATCHED_VALUE	0
+#define BM_DIGCTL_ENTROPY_LATCHED_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_ENTROPY_LATCHED_VALUE(v)	(v)
+
+#define HW_DIGCTL_MICROSECONDS	(0x000000c0)
+#define HW_DIGCTL_MICROSECONDS_SET	(0x000000c4)
+#define HW_DIGCTL_MICROSECONDS_CLR	(0x000000c8)
+#define HW_DIGCTL_MICROSECONDS_TOG	(0x000000cc)
+
+#define BP_DIGCTL_MICROSECONDS_VALUE	0
+#define BM_DIGCTL_MICROSECONDS_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_MICROSECONDS_VALUE(v)	(v)
+
+#define HW_DIGCTL_DBGRD	(0x000000d0)
+
+#define BP_DIGCTL_DBGRD_COMPLEMENT	0
+#define BM_DIGCTL_DBGRD_COMPLEMENT	0xFFFFFFFF
+#define BF_DIGCTL_DBGRD_COMPLEMENT(v)	(v)
+
+#define HW_DIGCTL_DBG	(0x000000e0)
+
+#define BP_DIGCTL_DBG_VALUE	0
+#define BM_DIGCTL_DBG_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_DBG_VALUE(v)	(v)
+
+#define HW_DIGCTL_USB_LOOPBACK	(0x00000100)
+#define HW_DIGCTL_USB_LOOPBACK_SET	(0x00000104)
+#define HW_DIGCTL_USB_LOOPBACK_CLR	(0x00000108)
+#define HW_DIGCTL_USB_LOOPBACK_TOG	(0x0000010c)
+
+#define BP_DIGCTL_USB_LOOPBACK_RSVD0	18
+#define BM_DIGCTL_USB_LOOPBACK_RSVD0	0xFFFC0000
+#define BF_DIGCTL_USB_LOOPBACK_RSVD0(v) \
+		(((v) << 18) & BM_DIGCTL_USB_LOOPBACK_RSVD0)
+#define BM_DIGCTL_USB_LOOPBACK_USB1_TST_START	0x00020000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_LS	0x00010000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_HS	0x00008000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_EN	0x00004000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_HIZ	0x00002000
+#define BM_DIGCTL_USB_LOOPBACK_UTMI1_DIG_TST1	0x00001000
+#define BM_DIGCTL_USB_LOOPBACK_UTMI1_DIG_TST0	0x00000800
+#define BM_DIGCTL_USB_LOOPBACK_USB0_TST_START	0x00000400
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_LS	0x00000200
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_HS	0x00000100
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_EN	0x00000080
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_HIZ	0x00000040
+#define BM_DIGCTL_USB_LOOPBACK_UTMI0_DIG_TST1	0x00000020
+#define BM_DIGCTL_USB_LOOPBACK_UTMI0_DIG_TST0	0x00000010
+#define BM_DIGCTL_USB_LOOPBACK_UTMO1_DIG_TST1	0x00000008
+#define BM_DIGCTL_USB_LOOPBACK_UTMO1_DIG_TST0	0x00000004
+#define BM_DIGCTL_USB_LOOPBACK_UTMO0_DIG_TST1	0x00000002
+#define BM_DIGCTL_USB_LOOPBACK_UTMO0_DIG_TST0	0x00000001
+
+#define HW_DIGCTL_OCRAM_STATUS0	(0x00000110)
+#define HW_DIGCTL_OCRAM_STATUS0_SET	(0x00000114)
+#define HW_DIGCTL_OCRAM_STATUS0_CLR	(0x00000118)
+#define HW_DIGCTL_OCRAM_STATUS0_TOG	(0x0000011c)
+
+#define BP_DIGCTL_OCRAM_STATUS0_FAILDATA00	0
+#define BM_DIGCTL_OCRAM_STATUS0_FAILDATA00	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS0_FAILDATA00(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS1	(0x00000120)
+#define HW_DIGCTL_OCRAM_STATUS1_SET	(0x00000124)
+#define HW_DIGCTL_OCRAM_STATUS1_CLR	(0x00000128)
+#define HW_DIGCTL_OCRAM_STATUS1_TOG	(0x0000012c)
+
+#define BP_DIGCTL_OCRAM_STATUS1_FAILDATA01	0
+#define BM_DIGCTL_OCRAM_STATUS1_FAILDATA01	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS1_FAILDATA01(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS2	(0x00000130)
+#define HW_DIGCTL_OCRAM_STATUS2_SET	(0x00000134)
+#define HW_DIGCTL_OCRAM_STATUS2_CLR	(0x00000138)
+#define HW_DIGCTL_OCRAM_STATUS2_TOG	(0x0000013c)
+
+#define BP_DIGCTL_OCRAM_STATUS2_FAILDATA10	0
+#define BM_DIGCTL_OCRAM_STATUS2_FAILDATA10	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS2_FAILDATA10(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS3	(0x00000140)
+#define HW_DIGCTL_OCRAM_STATUS3_SET	(0x00000144)
+#define HW_DIGCTL_OCRAM_STATUS3_CLR	(0x00000148)
+#define HW_DIGCTL_OCRAM_STATUS3_TOG	(0x0000014c)
+
+#define BP_DIGCTL_OCRAM_STATUS3_FAILDATA11	0
+#define BM_DIGCTL_OCRAM_STATUS3_FAILDATA11	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS3_FAILDATA11(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS4	(0x00000150)
+#define HW_DIGCTL_OCRAM_STATUS4_SET	(0x00000154)
+#define HW_DIGCTL_OCRAM_STATUS4_CLR	(0x00000158)
+#define HW_DIGCTL_OCRAM_STATUS4_TOG	(0x0000015c)
+
+#define BP_DIGCTL_OCRAM_STATUS4_FAILDATA20	0
+#define BM_DIGCTL_OCRAM_STATUS4_FAILDATA20	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS4_FAILDATA20(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS5	(0x00000160)
+#define HW_DIGCTL_OCRAM_STATUS5_SET	(0x00000164)
+#define HW_DIGCTL_OCRAM_STATUS5_CLR	(0x00000168)
+#define HW_DIGCTL_OCRAM_STATUS5_TOG	(0x0000016c)
+
+#define BP_DIGCTL_OCRAM_STATUS5_FAILDATA21	0
+#define BM_DIGCTL_OCRAM_STATUS5_FAILDATA21	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS5_FAILDATA21(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS6	(0x00000170)
+#define HW_DIGCTL_OCRAM_STATUS6_SET	(0x00000174)
+#define HW_DIGCTL_OCRAM_STATUS6_CLR	(0x00000178)
+#define HW_DIGCTL_OCRAM_STATUS6_TOG	(0x0000017c)
+
+#define BP_DIGCTL_OCRAM_STATUS6_FAILDATA30	0
+#define BM_DIGCTL_OCRAM_STATUS6_FAILDATA30	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS6_FAILDATA30(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS7	(0x00000180)
+#define HW_DIGCTL_OCRAM_STATUS7_SET	(0x00000184)
+#define HW_DIGCTL_OCRAM_STATUS7_CLR	(0x00000188)
+#define HW_DIGCTL_OCRAM_STATUS7_TOG	(0x0000018c)
+
+#define BP_DIGCTL_OCRAM_STATUS7_FAILDATA31	0
+#define BM_DIGCTL_OCRAM_STATUS7_FAILDATA31	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS7_FAILDATA31(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS8	(0x00000190)
+#define HW_DIGCTL_OCRAM_STATUS8_SET	(0x00000194)
+#define HW_DIGCTL_OCRAM_STATUS8_CLR	(0x00000198)
+#define HW_DIGCTL_OCRAM_STATUS8_TOG	(0x0000019c)
+
+#define BP_DIGCTL_OCRAM_STATUS8_FAILADDR01	16
+#define BM_DIGCTL_OCRAM_STATUS8_FAILADDR01	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS8_FAILADDR01(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS8_FAILADDR01)
+#define BP_DIGCTL_OCRAM_STATUS8_FAILADDR00	0
+#define BM_DIGCTL_OCRAM_STATUS8_FAILADDR00	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS8_FAILADDR00(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS8_FAILADDR00)
+
+#define HW_DIGCTL_OCRAM_STATUS9	(0x000001a0)
+#define HW_DIGCTL_OCRAM_STATUS9_SET	(0x000001a4)
+#define HW_DIGCTL_OCRAM_STATUS9_CLR	(0x000001a8)
+#define HW_DIGCTL_OCRAM_STATUS9_TOG	(0x000001ac)
+
+#define BP_DIGCTL_OCRAM_STATUS9_FAILADDR11	16
+#define BM_DIGCTL_OCRAM_STATUS9_FAILADDR11	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS9_FAILADDR11(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS9_FAILADDR11)
+#define BP_DIGCTL_OCRAM_STATUS9_FAILADDR10	0
+#define BM_DIGCTL_OCRAM_STATUS9_FAILADDR10	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS9_FAILADDR10(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS9_FAILADDR10)
+
+#define HW_DIGCTL_OCRAM_STATUS10	(0x000001b0)
+#define HW_DIGCTL_OCRAM_STATUS10_SET	(0x000001b4)
+#define HW_DIGCTL_OCRAM_STATUS10_CLR	(0x000001b8)
+#define HW_DIGCTL_OCRAM_STATUS10_TOG	(0x000001bc)
+
+#define BP_DIGCTL_OCRAM_STATUS10_FAILADDR21	16
+#define BM_DIGCTL_OCRAM_STATUS10_FAILADDR21	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS10_FAILADDR21(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS10_FAILADDR21)
+#define BP_DIGCTL_OCRAM_STATUS10_FAILADDR20	0
+#define BM_DIGCTL_OCRAM_STATUS10_FAILADDR20	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS10_FAILADDR20(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS10_FAILADDR20)
+
+#define HW_DIGCTL_OCRAM_STATUS11	(0x000001c0)
+#define HW_DIGCTL_OCRAM_STATUS11_SET	(0x000001c4)
+#define HW_DIGCTL_OCRAM_STATUS11_CLR	(0x000001c8)
+#define HW_DIGCTL_OCRAM_STATUS11_TOG	(0x000001cc)
+
+#define BP_DIGCTL_OCRAM_STATUS11_FAILADDR31	16
+#define BM_DIGCTL_OCRAM_STATUS11_FAILADDR31	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS11_FAILADDR31(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS11_FAILADDR31)
+#define BP_DIGCTL_OCRAM_STATUS11_FAILADDR30	0
+#define BM_DIGCTL_OCRAM_STATUS11_FAILADDR30	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS11_FAILADDR30(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS11_FAILADDR30)
+
+#define HW_DIGCTL_OCRAM_STATUS12	(0x000001d0)
+#define HW_DIGCTL_OCRAM_STATUS12_SET	(0x000001d4)
+#define HW_DIGCTL_OCRAM_STATUS12_CLR	(0x000001d8)
+#define HW_DIGCTL_OCRAM_STATUS12_TOG	(0x000001dc)
+
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD3	0x80000000
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE11	24
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE11	0x7F000000
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE11(v)  \
+		(((v) << 24) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE11)
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD2	0x00800000
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE10	16
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE10	0x007F0000
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE10(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE10)
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD1	0x00008000
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE01	8
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE01	0x00007F00
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE01(v)  \
+		(((v) << 8) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE01)
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD0	0x00000080
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE00	0
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE00	0x0000007F
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE00(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE00)
+
+#define HW_DIGCTL_OCRAM_STATUS13	(0x000001e0)
+#define HW_DIGCTL_OCRAM_STATUS13_SET	(0x000001e4)
+#define HW_DIGCTL_OCRAM_STATUS13_CLR	(0x000001e8)
+#define HW_DIGCTL_OCRAM_STATUS13_TOG	(0x000001ec)
+
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD3	0x80000000
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE31	24
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE31	0x7F000000
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE31(v)  \
+		(((v) << 24) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE31)
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD2	0x00800000
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE30	16
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE30	0x007F0000
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE30(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE30)
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD1	0x00008000
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE21	8
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE21	0x00007F00
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE21(v)  \
+		(((v) << 8) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE21)
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD0	0x00000080
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE20	0
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE20	0x0000007F
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE20(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE20)
+
+#define HW_DIGCTL_SCRATCH0	(0x00000280)
+
+#define BP_DIGCTL_SCRATCH0_PTR	0
+#define BM_DIGCTL_SCRATCH0_PTR	0xFFFFFFFF
+#define BF_DIGCTL_SCRATCH0_PTR(v)	(v)
+
+#define HW_DIGCTL_SCRATCH1	(0x00000290)
+
+#define BP_DIGCTL_SCRATCH1_PTR	0
+#define BM_DIGCTL_SCRATCH1_PTR	0xFFFFFFFF
+#define BF_DIGCTL_SCRATCH1_PTR(v)	(v)
+
+#define HW_DIGCTL_ARMCACHE	(0x000002a0)
+
+#define BP_DIGCTL_ARMCACHE_RSVD4	18
+#define BM_DIGCTL_ARMCACHE_RSVD4	0xFFFC0000
+#define BF_DIGCTL_ARMCACHE_RSVD4(v) \
+		(((v) << 18) & BM_DIGCTL_ARMCACHE_RSVD4)
+#define BP_DIGCTL_ARMCACHE_VALID_SS	16
+#define BM_DIGCTL_ARMCACHE_VALID_SS	0x00030000
+#define BF_DIGCTL_ARMCACHE_VALID_SS(v)  \
+		(((v) << 16) & BM_DIGCTL_ARMCACHE_VALID_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD3	14
+#define BM_DIGCTL_ARMCACHE_RSVD3	0x0000C000
+#define BF_DIGCTL_ARMCACHE_RSVD3(v)  \
+		(((v) << 14) & BM_DIGCTL_ARMCACHE_RSVD3)
+#define BP_DIGCTL_ARMCACHE_DRTY_SS	12
+#define BM_DIGCTL_ARMCACHE_DRTY_SS	0x00003000
+#define BF_DIGCTL_ARMCACHE_DRTY_SS(v)  \
+		(((v) << 12) & BM_DIGCTL_ARMCACHE_DRTY_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD2	10
+#define BM_DIGCTL_ARMCACHE_RSVD2	0x00000C00
+#define BF_DIGCTL_ARMCACHE_RSVD2(v)  \
+		(((v) << 10) & BM_DIGCTL_ARMCACHE_RSVD2)
+#define BP_DIGCTL_ARMCACHE_CACHE_SS	8
+#define BM_DIGCTL_ARMCACHE_CACHE_SS	0x00000300
+#define BF_DIGCTL_ARMCACHE_CACHE_SS(v)  \
+		(((v) << 8) & BM_DIGCTL_ARMCACHE_CACHE_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD1	6
+#define BM_DIGCTL_ARMCACHE_RSVD1	0x000000C0
+#define BF_DIGCTL_ARMCACHE_RSVD1(v)  \
+		(((v) << 6) & BM_DIGCTL_ARMCACHE_RSVD1)
+#define BP_DIGCTL_ARMCACHE_DTAG_SS	4
+#define BM_DIGCTL_ARMCACHE_DTAG_SS	0x00000030
+#define BF_DIGCTL_ARMCACHE_DTAG_SS(v)  \
+		(((v) << 4) & BM_DIGCTL_ARMCACHE_DTAG_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD0	2
+#define BM_DIGCTL_ARMCACHE_RSVD0	0x0000000C
+#define BF_DIGCTL_ARMCACHE_RSVD0(v)  \
+		(((v) << 2) & BM_DIGCTL_ARMCACHE_RSVD0)
+#define BP_DIGCTL_ARMCACHE_ITAG_SS	0
+#define BM_DIGCTL_ARMCACHE_ITAG_SS	0x00000003
+#define BF_DIGCTL_ARMCACHE_ITAG_SS(v)  \
+		(((v) << 0) & BM_DIGCTL_ARMCACHE_ITAG_SS)
+
+#define HW_DIGCTL_DEBUG_TRAP	(0x000002b0)
+#define HW_DIGCTL_DEBUG_TRAP_SET	(0x000002b4)
+#define HW_DIGCTL_DEBUG_TRAP_CLR	(0x000002b8)
+#define HW_DIGCTL_DEBUG_TRAP_TOG	(0x000002bc)
+
+#define BP_DIGCTL_DEBUG_TRAP_RSVD2	12
+#define BM_DIGCTL_DEBUG_TRAP_RSVD2	0xFFFFF000
+#define BF_DIGCTL_DEBUG_TRAP_RSVD2(v) \
+		(((v) << 12) & BM_DIGCTL_DEBUG_TRAP_RSVD2)
+#define BP_DIGCTL_DEBUG_TRAP_RSVD1	10
+#define BM_DIGCTL_DEBUG_TRAP_RSVD1	0x00000C00
+#define BF_DIGCTL_DEBUG_TRAP_RSVD1(v)  \
+		(((v) << 10) & BM_DIGCTL_DEBUG_TRAP_RSVD1)
+#define BP_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID	8
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID	0x00000300
+#define BF_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID(v)  \
+		(((v) << 8) & BM_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID)
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__PXP   0x0
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__LCDIF 0x1
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__BCH   0x2
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__DCP   0x3
+#define BM_DIGCTL_DEBUG_TRAP_RSVD0	0x00000080
+#define BP_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID	4
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID	0x00000070
+#define BF_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID(v)  \
+		(((v) << 4) & BM_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID)
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__APBH_BRIDE_DMA 0x0
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__APBX_BRIDE_DMA 0x1
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__USB0           0x2
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__USB1           0x3
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__ENET_M0        0x4
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__ENET_M1        0x5
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L3_IRQ	0x00000008
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L0_IRQ	0x00000004
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_IN_RANGE	0x00000002
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_ENABLE	0x00000001
+
+#define HW_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW	(0x000002c0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH	(0x000002d0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW	(0x000002e0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH	(0x000002f0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH_ADDR(v)	(v)
+
+#define HW_DIGCTL_FSL	(0x00000300)
+
+#define BP_DIGCTL_FSL_COPYRIGHT	0
+#define BM_DIGCTL_FSL_COPYRIGHT	0xFFFFFFFF
+#define BF_DIGCTL_FSL_COPYRIGHT(v)	(v)
+
+#define HW_DIGCTL_CHIPID	(0x00000310)
+
+#define BP_DIGCTL_CHIPID_PRODUCT_CODE	16
+#define BM_DIGCTL_CHIPID_PRODUCT_CODE	0xFFFF0000
+#define BF_DIGCTL_CHIPID_PRODUCT_CODE(v) \
+		(((v) << 16) & BM_DIGCTL_CHIPID_PRODUCT_CODE)
+#define BP_DIGCTL_CHIPID_RSVD0	8
+#define BM_DIGCTL_CHIPID_RSVD0	0x0000FF00
+#define BF_DIGCTL_CHIPID_RSVD0(v)  \
+		(((v) << 8) & BM_DIGCTL_CHIPID_RSVD0)
+#define BP_DIGCTL_CHIPID_REVISION	0
+#define BM_DIGCTL_CHIPID_REVISION	0x000000FF
+#define BF_DIGCTL_CHIPID_REVISION(v)  \
+		(((v) << 0) & BM_DIGCTL_CHIPID_REVISION)
+
+#define HW_DIGCTL_AHB_STATS_SELECT	(0x00000330)
+
+#define BP_DIGCTL_AHB_STATS_SELECT_RSVD0	24
+#define BM_DIGCTL_AHB_STATS_SELECT_RSVD0	0xFF000000
+#define BF_DIGCTL_AHB_STATS_SELECT_RSVD0(v) \
+		(((v) << 24) & BM_DIGCTL_AHB_STATS_SELECT_RSVD0)
+#define BP_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT	16
+#define BM_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT	0x00FF0000
+#define BF_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT(v)  \
+		(((v) << 16) & BM_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__APBHDMA 0x1
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__APBXDMA 0x2
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__USB0    0x4
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__USB1    0x8
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__UDMA0   0x10
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__UDMA1   0x20
+#define BP_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT	8
+#define BM_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT	0x0000FF00
+#define BF_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT(v)  \
+		(((v) << 8) & BM_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT__ARMD 0x1
+#define BP_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT	0
+#define BM_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT	0x000000FF
+#define BF_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT(v)  \
+		(((v) << 0) & BM_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT__ARMI 0x1
+
+#define HW_DIGCTL_L1_AHB_ACTIVE_CYCLES	(0x00000370)
+
+#define BP_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_DATA_STALLED	(0x00000380)
+
+#define BP_DIGCTL_L1_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L1_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_DATA_CYCLES	(0x00000390)
+
+#define BP_DIGCTL_L1_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L1_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_ACTIVE_CYCLES	(0x000003a0)
+
+#define BP_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_DATA_STALLED	(0x000003b0)
+
+#define BP_DIGCTL_L2_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L2_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_DATA_CYCLES	(0x000003c0)
+
+#define BP_DIGCTL_L2_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L2_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_ACTIVE_CYCLES	(0x000003d0)
+
+#define BP_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_DATA_STALLED	(0x000003e0)
+
+#define BP_DIGCTL_L3_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L3_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_DATA_CYCLES	(0x000003f0)
+
+#define BP_DIGCTL_L3_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L3_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_MPTE0_LOC	(0x00000500)
+
+#define BM_DIGCTL_MPTE0_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE0_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE0_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE0_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE0_LOC_RSVD1)
+#define BP_DIGCTL_MPTE0_LOC_SPAN	24
+#define BM_DIGCTL_MPTE0_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE0_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE0_LOC_SPAN)
+#define BP_DIGCTL_MPTE0_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE0_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE0_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE0_LOC_RSVD0)
+#define BP_DIGCTL_MPTE0_LOC_LOC	0
+#define BM_DIGCTL_MPTE0_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE0_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE0_LOC_LOC)
+
+#define HW_DIGCTL_MPTE1_LOC	(0x00000510)
+
+#define BM_DIGCTL_MPTE1_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE1_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE1_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE1_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE1_LOC_RSVD1)
+#define BP_DIGCTL_MPTE1_LOC_SPAN	24
+#define BM_DIGCTL_MPTE1_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE1_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE1_LOC_SPAN)
+#define BP_DIGCTL_MPTE1_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE1_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE1_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE1_LOC_RSVD0)
+#define BP_DIGCTL_MPTE1_LOC_LOC	0
+#define BM_DIGCTL_MPTE1_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE1_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE1_LOC_LOC)
+
+#define HW_DIGCTL_MPTE2_LOC	(0x00000520)
+
+#define BM_DIGCTL_MPTE2_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE2_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE2_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE2_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE2_LOC_RSVD1)
+#define BP_DIGCTL_MPTE2_LOC_SPAN	24
+#define BM_DIGCTL_MPTE2_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE2_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE2_LOC_SPAN)
+#define BP_DIGCTL_MPTE2_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE2_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE2_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE2_LOC_RSVD0)
+#define BP_DIGCTL_MPTE2_LOC_LOC	0
+#define BM_DIGCTL_MPTE2_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE2_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE2_LOC_LOC)
+
+#define HW_DIGCTL_MPTE3_LOC	(0x00000530)
+
+#define BM_DIGCTL_MPTE3_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE3_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE3_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE3_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE3_LOC_RSVD1)
+#define BP_DIGCTL_MPTE3_LOC_SPAN	24
+#define BM_DIGCTL_MPTE3_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE3_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE3_LOC_SPAN)
+#define BP_DIGCTL_MPTE3_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE3_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE3_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE3_LOC_RSVD0)
+#define BP_DIGCTL_MPTE3_LOC_LOC	0
+#define BM_DIGCTL_MPTE3_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE3_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE3_LOC_LOC)
+
+#define HW_DIGCTL_MPTE4_LOC	(0x00000540)
+
+#define BM_DIGCTL_MPTE4_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE4_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE4_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE4_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE4_LOC_RSVD1)
+#define BP_DIGCTL_MPTE4_LOC_SPAN	24
+#define BM_DIGCTL_MPTE4_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE4_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE4_LOC_SPAN)
+#define BP_DIGCTL_MPTE4_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE4_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE4_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE4_LOC_RSVD0)
+#define BP_DIGCTL_MPTE4_LOC_LOC	0
+#define BM_DIGCTL_MPTE4_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE4_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE4_LOC_LOC)
+
+#define HW_DIGCTL_MPTE5_LOC	(0x00000550)
+
+#define BM_DIGCTL_MPTE5_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE5_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE5_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE5_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE5_LOC_RSVD1)
+#define BP_DIGCTL_MPTE5_LOC_SPAN	24
+#define BM_DIGCTL_MPTE5_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE5_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE5_LOC_SPAN)
+#define BP_DIGCTL_MPTE5_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE5_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE5_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE5_LOC_RSVD0)
+#define BP_DIGCTL_MPTE5_LOC_LOC	0
+#define BM_DIGCTL_MPTE5_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE5_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE5_LOC_LOC)
+
+#define HW_DIGCTL_MPTE6_LOC	(0x00000560)
+
+#define BM_DIGCTL_MPTE6_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE6_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE6_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE6_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE6_LOC_RSVD1)
+#define BP_DIGCTL_MPTE6_LOC_SPAN	24
+#define BM_DIGCTL_MPTE6_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE6_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE6_LOC_SPAN)
+#define BP_DIGCTL_MPTE6_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE6_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE6_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE6_LOC_RSVD0)
+#define BP_DIGCTL_MPTE6_LOC_LOC	0
+#define BM_DIGCTL_MPTE6_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE6_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE6_LOC_LOC)
+
+#define HW_DIGCTL_MPTE7_LOC	(0x00000570)
+
+#define BM_DIGCTL_MPTE7_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE7_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE7_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE7_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE7_LOC_RSVD1)
+#define BP_DIGCTL_MPTE7_LOC_SPAN	24
+#define BM_DIGCTL_MPTE7_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE7_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE7_LOC_SPAN)
+#define BP_DIGCTL_MPTE7_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE7_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE7_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE7_LOC_RSVD0)
+#define BP_DIGCTL_MPTE7_LOC_LOC	0
+#define BM_DIGCTL_MPTE7_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE7_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE7_LOC_LOC)
+
+#define HW_DIGCTL_MPTE8_LOC	(0x00000580)
+
+#define BM_DIGCTL_MPTE8_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE8_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE8_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE8_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE8_LOC_RSVD1)
+#define BP_DIGCTL_MPTE8_LOC_SPAN	24
+#define BM_DIGCTL_MPTE8_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE8_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE8_LOC_SPAN)
+#define BP_DIGCTL_MPTE8_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE8_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE8_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE8_LOC_RSVD0)
+#define BP_DIGCTL_MPTE8_LOC_LOC	0
+#define BM_DIGCTL_MPTE8_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE8_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE8_LOC_LOC)
+
+#define HW_DIGCTL_MPTE9_LOC	(0x00000590)
+
+#define BM_DIGCTL_MPTE9_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE9_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE9_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE9_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE9_LOC_RSVD1)
+#define BP_DIGCTL_MPTE9_LOC_SPAN	24
+#define BM_DIGCTL_MPTE9_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE9_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE9_LOC_SPAN)
+#define BP_DIGCTL_MPTE9_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE9_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE9_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE9_LOC_RSVD0)
+#define BP_DIGCTL_MPTE9_LOC_LOC	0
+#define BM_DIGCTL_MPTE9_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE9_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE9_LOC_LOC)
+
+#define HW_DIGCTL_MPTE10_LOC	(0x000005a0)
+
+#define BM_DIGCTL_MPTE10_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE10_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE10_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE10_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE10_LOC_RSVD1)
+#define BP_DIGCTL_MPTE10_LOC_SPAN	24
+#define BM_DIGCTL_MPTE10_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE10_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE10_LOC_SPAN)
+#define BP_DIGCTL_MPTE10_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE10_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE10_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE10_LOC_RSVD0)
+#define BP_DIGCTL_MPTE10_LOC_LOC	0
+#define BM_DIGCTL_MPTE10_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE10_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE10_LOC_LOC)
+
+#define HW_DIGCTL_MPTE11_LOC	(0x000005b0)
+
+#define BM_DIGCTL_MPTE11_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE11_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE11_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE11_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE11_LOC_RSVD1)
+#define BP_DIGCTL_MPTE11_LOC_SPAN	24
+#define BM_DIGCTL_MPTE11_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE11_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE11_LOC_SPAN)
+#define BP_DIGCTL_MPTE11_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE11_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE11_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE11_LOC_RSVD0)
+#define BP_DIGCTL_MPTE11_LOC_LOC	0
+#define BM_DIGCTL_MPTE11_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE11_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE11_LOC_LOC)
+
+#define HW_DIGCTL_MPTE12_LOC	(0x000005c0)
+
+#define BM_DIGCTL_MPTE12_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE12_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE12_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE12_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE12_LOC_RSVD1)
+#define BP_DIGCTL_MPTE12_LOC_SPAN	24
+#define BM_DIGCTL_MPTE12_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE12_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE12_LOC_SPAN)
+#define BP_DIGCTL_MPTE12_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE12_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE12_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE12_LOC_RSVD0)
+#define BP_DIGCTL_MPTE12_LOC_LOC	0
+#define BM_DIGCTL_MPTE12_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE12_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE12_LOC_LOC)
+
+#define HW_DIGCTL_MPTE13_LOC	(0x000005d0)
+
+#define BM_DIGCTL_MPTE13_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE13_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE13_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE13_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE13_LOC_RSVD1)
+#define BP_DIGCTL_MPTE13_LOC_SPAN	24
+#define BM_DIGCTL_MPTE13_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE13_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE13_LOC_SPAN)
+#define BP_DIGCTL_MPTE13_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE13_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE13_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE13_LOC_RSVD0)
+#define BP_DIGCTL_MPTE13_LOC_LOC	0
+#define BM_DIGCTL_MPTE13_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE13_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE13_LOC_LOC)
+
+#define HW_DIGCTL_MPTE14_LOC	(0x000005e0)
+
+#define BM_DIGCTL_MPTE14_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE14_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE14_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE14_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE14_LOC_RSVD1)
+#define BP_DIGCTL_MPTE14_LOC_SPAN	24
+#define BM_DIGCTL_MPTE14_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE14_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE14_LOC_SPAN)
+#define BP_DIGCTL_MPTE14_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE14_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE14_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE14_LOC_RSVD0)
+#define BP_DIGCTL_MPTE14_LOC_LOC	0
+#define BM_DIGCTL_MPTE14_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE14_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE14_LOC_LOC)
+
+#define HW_DIGCTL_MPTE15_LOC	(0x000005f0)
+
+#define BM_DIGCTL_MPTE15_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE15_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE15_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE15_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE15_LOC_RSVD1)
+#define BP_DIGCTL_MPTE15_LOC_SPAN	24
+#define BM_DIGCTL_MPTE15_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE15_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE15_LOC_SPAN)
+#define BP_DIGCTL_MPTE15_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE15_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE15_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE15_LOC_RSVD0)
+#define BP_DIGCTL_MPTE15_LOC_LOC	0
+#define BM_DIGCTL_MPTE15_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE15_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE15_LOC_LOC)
+#endif /* __ARCH_ARM___DIGCTL_H */
diff --git a/arch/arm/mach-mx28/usb.h b/arch/arm/mach-mx28/usb.h
new file mode 100644
index 0000000..689603d
--- /dev/null
+++ b/arch/arm/mach-mx28/usb.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+extern void fsl_platform_set_usb_phy_dis(struct fsl_usb2_platform_data *pdata,
+					 bool enable);
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx28/usb_dr.c b/arch/arm/mach-mx28/usb_dr.c
new file mode 100644
index 0000000..69cb854
--- /dev/null
+++ b/arch/arm/mach-mx28/usb_dr.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/irqs.h>
+#include "usb.h"
+
+static void usb_host_phy_resume(struct fsl_usb2_platform_data *plat)
+{
+	fsl_platform_set_usb_phy_dis(plat, 0);
+}
+
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_clk0");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	return usbotg_init(pdev);
+}
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init_ext,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,	/* 500 mA max power */
+	.platform_resume = usb_host_phy_resume,
+	.transceiver       = "utmi",
+	.phy_regs          = USBPHY0_PHYS_ADDR,
+};
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start	= (u32)USBCTRL0_PHYS_ADDR,
+		.end	= (u32)(USBCTRL0_PHYS_ADDR + 0x1ff),
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start	= IRQ_USB0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * 	dev.platform_data field plugged at run time
+ */
+static struct platform_device dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{}
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev  = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	PDATA->change_ahb_burst = 1;
+	PDATA->ahb_burst_mode = 0;
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx28/usb_h1.c b/arch/arm/mach-mx28/usb_h1.c
new file mode 100644
index 0000000..4ee6378
--- /dev/null
+++ b/arch/arm/mach-mx28/usb_h1.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/irqs.h>
+#include "usb.h"
+
+static void usb_host_phy_resume(struct fsl_usb2_platform_data *plat)
+{
+	fsl_platform_set_usb_phy_dis(plat, 0);
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_clk1");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	return fsl_usb_host_init(pdev);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name = "Host 1",
+	.platform_init = fsl_usb_host_init_ext,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget = 500,	/* 500 mA max power */
+	.platform_resume = usb_host_phy_resume,
+	.transceiver = "utmi",
+	.phy_regs = USBPHY1_PHYS_ADDR,
+};
+
+static struct resource usbh1_resources[] = {
+	[0] = {
+	       .start = (u32) (USBCTRL1_PHYS_ADDR),
+	       .end = (u32) (USBCTRL1_PHYS_ADDR + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int __init usbh1_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	host_pdev_register(usbh1_resources,
+			ARRAY_SIZE(usbh1_resources), &usbh1_config);
+
+	return 0;
+}
+
+module_init(usbh1_init);
diff --git a/arch/arm/plat-mxs/Makefile b/arch/arm/plat-mxs/Makefile
index 7999f0e..fb8c27b 100644
--- a/arch/arm/plat-mxs/Makefile
+++ b/arch/arm/plat-mxs/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_GENERIC_GPIO) += gpio.o
 obj-$(CONFIG_MXS_ICOLL) += icoll.o
 
 obj-$(CONFIG_MXS_DMA_ENGINE) += dmaengine.o dma-apbh.o dma-apbx.o
+obj-$(CONFIG_ARCH_MX28) += usb_common.o utmixc.o
 
 obj-$(CONFIG_MXS_LRADC) += lradc.o
 # Power Management
diff --git a/arch/arm/plat-mxs/include/mach/arc_otg.h b/arch/arm/plat-mxs/include/mach/arc_otg.h
new file mode 100644
index 0000000..d8f83d5
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/arc_otg.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+#define OTG_BASE_ADDR		USBCTRL0_PHYS_ADDR
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+/*
+ * OTG registers
+ */
+#define UOG_ID			(0x00)	/* Host ID */
+#define UOG_HWGENERAL		(0x04)	/* Host General */
+#define UOG_HWHOST		(0x08)	/* Host h/w params */
+#define UOG_HWTXBUF		(0x10)	/* TX buffer h/w params */
+#define UOG_HWRXBUF		(0x14)	/* RX buffer h/w params */
+#define UOG_CAPLENGTH		(0x100)	/* Capability register length */
+#define UOG_HCIVERSION		(0x102)	/* Host Interface version */
+#define UOG_HCSPARAMS		(0x104)	/* Host control structural params */
+#define UOG_HCCPARAMS		(0x108)	/* control capability params */
+#define UOG_DCIVERSION		(0x120)	/* device interface version */
+/* start EHCI registers: */
+#define UOG_USBCMD		(0x140)	/* USB command register */
+#define UOG_USBSTS		(0x144)	/* USB status register */
+#define UOG_USBINTR		(0x148)	/* interrupt enable register */
+#define UOG_FRINDEX		(0x14c)	/* USB frame index */
+/*      segment         (0x150)	   addr bits 63:32 if needed */
+#define UOG_PERIODICLISTBASE	(0x154)	/* host crtlr frame list base addr */
+#define UOG_DEVICEADDR		(0x154)	/* device crtlr device address */
+#define UOG_ASYNCLISTADDR	(0x158)	/* host ctrlr next async addr */
+#define UOG_EPLISTADDR		(0x158)	/* device ctrlr endpoint list addr */
+#define UOG_BURSTSIZE		(0x160)	/* host ctrlr embedded TT
+					   async buf status */
+#define UOG_TXFILLTUNING	(0x164)	/* TX FIFO fill tuning */
+#define UOG_ULPIVIEW		(0x170)	/* ULPI viewport */
+#define UOG_CFGFLAG		(0x180)	/* configflag (supports HS) */
+#define UOG_PORTSC1		(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UOG_OTGSC		(0x1a4)	/* OTG status and control */
+#define UOG_USBMODE		(0x1a8)	/* USB device mode */
+#define UOG_ENDPTSETUPSTAT	(0x1ac)	/* endpoint setup status */
+#define UOG_ENDPTPRIME		(0x1b0)	/* endpoint initialization */
+#define UOG_ENDPTFLUSH		(0x1b4)	/* endpoint de-initialize */
+#define UOG_ENDPTSTAT		(0x1b8)	/* endpoint status */
+#define UOG_ENDPTCOMPLETE	(0x1bc)	/* endpoint complete */
+#define UOG_EPCTRL0		(0x1c0)	/* endpoint control0 */
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30) /* parallel xcvr mask */
+#define PORTSC_PTS_UTMI			(0 << 30) /* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30) /* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30) /* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30) /* serial */
+#define PORTSC_STS			(1 << 29) /* serial xcvr select */
+#define PORTSC_PTW                      (1 << 28) /* UTMI width */
+#define PORTSC_PHCD                     (1 << 23) /* Low Power Suspend */
+#define PORTSC_PORT_POWER		(1 << 12) /* port power */
+#define PORTSC_LS_MASK			(3 << 10) /* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10) /* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10) /* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10) /* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8) /* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7) /* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6) /* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5) /* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4) /* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3) /* port change */
+#define PORTSC_PORT_ENABLE		(1 <<  2) /* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1) /* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0) /* current connect status */
+
+#define PORTSC_W1C_BITS	\
+	(PORTSC_CONNECT_STATUS_CHANGE |	\
+	PORTSC_PORT_EN_DIS_CHANGE	|	\
+	PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 << 0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 << 1)
+/* controls DM pulldown */
+#define  OTGSC_CTRL_OTG_TERM		(1 << 3)
+#define  OTGSC_CTRL_DATA_PULSING	(1 << 4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 << 5)
+/* current status: (R/O) */
+/* 0=A-device  1=B-device */
+#define  OTGSC_STS_USB_ID		(1 << 8)
+#define  OTGSC_STS_A_VBUS_VALID		(1 << 9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1	/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	(~(0xff << 16))	/* Interrupt Threshold */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+				/* 1=high: Operate as B-device */
+				/* 0=low : Operate as A-device */
+
+#define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
+
+extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/fsl_usb.h b/arch/arm/plat-mxs/include/mach/fsl_usb.h
new file mode 100644
index 0000000..50a9920
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/fsl_usb.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_MEMORY)
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+
+static inline void fsl_platform_usb_setup(struct ehci_hcd *ehci)
+{
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = ehci_to_hcd(ehci)->self.controller->platform_data;
+	fsl_setup_phy(ehci, pdata->phy_mode, 0);
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + UOG_USBMODE);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + UOG_USBMODE);
+}
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+}
+
+/* Set USB AHB burst length for host */
+static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
+{
+}
diff --git a/arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h b/arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h
new file mode 100644
index 0000000..767b344
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(1);
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(0);
+}
diff --git a/arch/arm/plat-mxs/regs-usbphy.h b/arch/arm/plat-mxs/regs-usbphy.h
new file mode 100644
index 0000000..5ab0152
--- /dev/null
+++ b/arch/arm/plat-mxs/regs-usbphy.h
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ARCH_ARM___USBPHY_H
+#define __ARCH_ARM___USBPHY_H  1
+
+#define REGS_USBPHY_BASE (MX28_SOC_IO_VIRT_BASE + 0x7c000)
+#define REGS_USBPHY_PHYS (0x8007C000)
+#define REGS_USBPHY_SIZE 0x00002000
+
+#define HW_USBPHY_PWD	(0x00000000)
+#define HW_USBPHY_PWD_SET	(0x00000004)
+#define HW_USBPHY_PWD_CLR	(0x00000008)
+#define HW_USBPHY_PWD_TOG	(0x0000000c)
+#define HW_USBPHY_PWD_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_PWD)
+#define HW_USBPHY_PWD_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_PWD_SET)
+#define HW_USBPHY_PWD_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_PWD_CLR)
+#define HW_USBPHY_PWD_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_PWD_TOG)
+
+#define BP_USBPHY_PWD_RSVD2	21
+#define BM_USBPHY_PWD_RSVD2	0xFFE00000
+#define BF_USBPHY_PWD_RSVD2(v) \
+		(((v) << 21) & BM_USBPHY_PWD_RSVD2)
+#define BM_USBPHY_PWD_RXPWDRX	0x00100000
+#define BM_USBPHY_PWD_RXPWDDIFF	0x00080000
+#define BM_USBPHY_PWD_RXPWD1PT1	0x00040000
+#define BM_USBPHY_PWD_RXPWDENV	0x00020000
+#define BP_USBPHY_PWD_RSVD1	13
+#define BM_USBPHY_PWD_RSVD1	0x0001E000
+#define BF_USBPHY_PWD_RSVD1(v)  \
+		(((v) << 13) & BM_USBPHY_PWD_RSVD1)
+#define BM_USBPHY_PWD_TXPWDV2I	0x00001000
+#define BM_USBPHY_PWD_TXPWDIBIAS	0x00000800
+#define BM_USBPHY_PWD_TXPWDFS	0x00000400
+#define BP_USBPHY_PWD_RSVD0	0
+#define BM_USBPHY_PWD_RSVD0	0x000003FF
+#define BF_USBPHY_PWD_RSVD0(v)  \
+		(((v) << 0) & BM_USBPHY_PWD_RSVD0)
+
+#define HW_USBPHY_TX	(0x00000010)
+#define HW_USBPHY_TX_SET	(0x00000014)
+#define HW_USBPHY_TX_CLR	(0x00000018)
+#define HW_USBPHY_TX_TOG	(0x0000001c)
+#define HW_USBPHY_TX_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_TX)
+#define HW_USBPHY_TX_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_TX_SET)
+#define HW_USBPHY_TX_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_TX_CLR)
+#define HW_USBPHY_TX_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_TX_TOG)
+
+#define BP_USBPHY_TX_RSVD5	29
+#define BM_USBPHY_TX_RSVD5	0xE0000000
+#define BF_USBPHY_TX_RSVD5(v) \
+		(((v) << 29) & BM_USBPHY_TX_RSVD5)
+#define BP_USBPHY_TX_USBPHY_TX_EDGECTRL	26
+#define BM_USBPHY_TX_USBPHY_TX_EDGECTRL	0x1C000000
+#define BF_USBPHY_TX_USBPHY_TX_EDGECTRL(v)  \
+		(((v) << 26) & BM_USBPHY_TX_USBPHY_TX_EDGECTRL)
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_INVERT	0x02000000
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_MUX	0x01000000
+#define BP_USBPHY_TX_RSVD4	22
+#define BM_USBPHY_TX_RSVD4	0x00C00000
+#define BF_USBPHY_TX_RSVD4(v)  \
+		(((v) << 22) & BM_USBPHY_TX_RSVD4)
+#define BM_USBPHY_TX_TXENCAL45DP	0x00200000
+#define BM_USBPHY_TX_RSVD3	0x00100000
+#define BP_USBPHY_TX_TXCAL45DP	16
+#define BM_USBPHY_TX_TXCAL45DP	0x000F0000
+#define BF_USBPHY_TX_TXCAL45DP(v)  \
+		(((v) << 16) & BM_USBPHY_TX_TXCAL45DP)
+#define BP_USBPHY_TX_RSVD2	14
+#define BM_USBPHY_TX_RSVD2	0x0000C000
+#define BF_USBPHY_TX_RSVD2(v)  \
+		(((v) << 14) & BM_USBPHY_TX_RSVD2)
+#define BM_USBPHY_TX_TXENCAL45DN	0x00002000
+#define BM_USBPHY_TX_RSVD1	0x00001000
+#define BP_USBPHY_TX_TXCAL45DN	8
+#define BM_USBPHY_TX_TXCAL45DN	0x00000F00
+#define BF_USBPHY_TX_TXCAL45DN(v)  \
+		(((v) << 8) & BM_USBPHY_TX_TXCAL45DN)
+#define BP_USBPHY_TX_RSVD0	4
+#define BM_USBPHY_TX_RSVD0	0x000000F0
+#define BF_USBPHY_TX_RSVD0(v)  \
+		(((v) << 4) & BM_USBPHY_TX_RSVD0)
+#define BP_USBPHY_TX_D_CAL	0
+#define BM_USBPHY_TX_D_CAL	0x0000000F
+#define BF_USBPHY_TX_D_CAL(v)  \
+		(((v) << 0) & BM_USBPHY_TX_D_CAL)
+
+#define HW_USBPHY_RX	(0x00000020)
+#define HW_USBPHY_RX_SET	(0x00000024)
+#define HW_USBPHY_RX_CLR	(0x00000028)
+#define HW_USBPHY_RX_TOG	(0x0000002c)
+#define HW_USBPHY_RX_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_RX)
+#define HW_USBPHY_RX_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_RX_SET)
+#define HW_USBPHY_RX_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_RX_CLR)
+#define HW_USBPHY_RX_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_RX_TOG)
+
+#define BP_USBPHY_RX_RSVD2	23
+#define BM_USBPHY_RX_RSVD2	0xFF800000
+#define BF_USBPHY_RX_RSVD2(v) \
+		(((v) << 23) & BM_USBPHY_RX_RSVD2)
+#define BM_USBPHY_RX_RXDBYPASS	0x00400000
+#define BP_USBPHY_RX_RSVD1	7
+#define BM_USBPHY_RX_RSVD1	0x003FFF80
+#define BF_USBPHY_RX_RSVD1(v)  \
+		(((v) << 7) & BM_USBPHY_RX_RSVD1)
+#define BP_USBPHY_RX_DISCONADJ	4
+#define BM_USBPHY_RX_DISCONADJ	0x00000070
+#define BF_USBPHY_RX_DISCONADJ(v)  \
+		(((v) << 4) & BM_USBPHY_RX_DISCONADJ)
+#define BM_USBPHY_RX_RSVD0	0x00000008
+#define BP_USBPHY_RX_ENVADJ	0
+#define BM_USBPHY_RX_ENVADJ	0x00000007
+#define BF_USBPHY_RX_ENVADJ(v)  \
+		(((v) << 0) & BM_USBPHY_RX_ENVADJ)
+
+#define HW_USBPHY_CTRL	(0x00000030)
+#define HW_USBPHY_CTRL_SET	(0x00000034)
+#define HW_USBPHY_CTRL_CLR	(0x00000038)
+#define HW_USBPHY_CTRL_TOG	(0x0000003c)
+#define HW_USBPHY_CTRL_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_CTRL)
+#define HW_USBPHY_CTRL_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_CTRL_SET)
+#define HW_USBPHY_CTRL_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_CTRL_CLR)
+#define HW_USBPHY_CTRL_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_CTRL_TOG)
+
+#define BM_USBPHY_CTRL_SFTRST	0x80000000
+#define BM_USBPHY_CTRL_CLKGATE	0x40000000
+#define BM_USBPHY_CTRL_UTMI_SUSPENDM	0x20000000
+#define BM_USBPHY_CTRL_HOST_FORCE_LS_SE0	0x10000000
+#define BP_USBPHY_CTRL_RSVD3	14
+#define BM_USBPHY_CTRL_RSVD3	0x0FFFC000
+#define BF_USBPHY_CTRL_RSVD3(v)  \
+		(((v) << 14) & BM_USBPHY_CTRL_RSVD3)
+
+#define BM_USBPHY_CTRL_ENDPDMCHG_WKUP	0x00200000
+#define BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD	0x00100000
+#define BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE	0x00080000
+#define BM_USBPHY_CTRL_ENAUTO_PWRON_PLL	0x00040000
+#define BM_USBPHY_CTRL_WAKEUP_IRQ	0x00020000
+#define BM_USBPHY_CTRL_ENIRQWAKEUP	0x00010000
+#define BM_USBPHY_CTRL_ENUTMILEVEL3	0x00008000
+#define BM_USBPHY_CTRL_ENUTMILEVEL2	0x00004000
+#define BM_USBPHY_CTRL_DATA_ON_LRADC	0x00002000
+#define BM_USBPHY_CTRL_DEVPLUGIN_IRQ	0x00001000
+#define BM_USBPHY_CTRL_ENIRQDEVPLUGIN	0x00000800
+#define BM_USBPHY_CTRL_RESUME_IRQ	0x00000400
+#define BM_USBPHY_CTRL_ENIRQRESUMEDETECT	0x00000200
+#define BM_USBPHY_CTRL_RSVD2	0x00000100
+#define BM_USBPHY_CTRL_ENOTGIDDETECT	0x00000080
+#define BM_USBPHY_CTRL_RSVD1	0x00000040
+#define BM_USBPHY_CTRL_DEVPLUGIN_POLARITY	0x00000020
+#define BM_USBPHY_CTRL_ENDEVPLUGINDETECT	0x00000010
+#define BM_USBPHY_CTRL_HOSTDISCONDETECT_IRQ	0x00000008
+#define BM_USBPHY_CTRL_ENIRQHOSTDISCON	0x00000004
+#define BM_USBPHY_CTRL_ENHOSTDISCONDETECT	0x00000002
+#define BM_USBPHY_CTRL_RSVD0	0x00000001
+
+#define HW_USBPHY_STATUS	(0x00000040)
+#define HW_USBPHY_STATUS_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_STATUS)
+
+#define BP_USBPHY_STATUS_RSVD4	11
+#define BM_USBPHY_STATUS_RSVD4	0xFFFFF800
+#define BF_USBPHY_STATUS_RSVD4(v) \
+		(((v) << 11) & BM_USBPHY_STATUS_RSVD4)
+#define BM_USBPHY_STATUS_RESUME_STATUS	0x00000400
+#define BM_USBPHY_STATUS_RSVD3	0x00000200
+#define BM_USBPHY_STATUS_OTGID_STATUS	0x00000100
+#define BM_USBPHY_STATUS_RSVD2	0x00000080
+#define BM_USBPHY_STATUS_DEVPLUGIN_STATUS	0x00000040
+#define BP_USBPHY_STATUS_RSVD1	4
+#define BM_USBPHY_STATUS_RSVD1	0x00000030
+#define BF_USBPHY_STATUS_RSVD1(v)  \
+		(((v) << 4) & BM_USBPHY_STATUS_RSVD1)
+#define BM_USBPHY_STATUS_HOSTDISCONDETECT_STATUS	0x00000008
+#define BP_USBPHY_STATUS_RSVD0	0
+#define BM_USBPHY_STATUS_RSVD0	0x00000007
+#define BF_USBPHY_STATUS_RSVD0(v)  \
+		(((v) << 0) & BM_USBPHY_STATUS_RSVD0)
+
+#define HW_USBPHY_DEBUG	(0x00000050)
+#define HW_USBPHY_DEBUG_SET	(0x00000054)
+#define HW_USBPHY_DEBUG_CLR	(0x00000058)
+#define HW_USBPHY_DEBUG_TOG	(0x0000005c)
+#define HW_USBPHY_DEBUG_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG)
+#define HW_USBPHY_DEBUG_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG_SET)
+#define HW_USBPHY_DEBUG_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG_CLR)
+#define HW_USBPHY_DEBUG_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG_TOG)
+
+#define BM_USBPHY_DEBUG_RSVD3	0x80000000
+#define BM_USBPHY_DEBUG_CLKGATE	0x40000000
+#define BM_USBPHY_DEBUG_HOST_RESUME_DEBUG	0x20000000
+#define BP_USBPHY_DEBUG_SQUELCHRESETLENGTH	25
+#define BM_USBPHY_DEBUG_SQUELCHRESETLENGTH	0x1E000000
+#define BF_USBPHY_DEBUG_SQUELCHRESETLENGTH(v)  \
+		(((v) << 25) & BM_USBPHY_DEBUG_SQUELCHRESETLENGTH)
+#define BM_USBPHY_DEBUG_ENSQUELCHRESET	0x01000000
+#define BP_USBPHY_DEBUG_RSVD2	21
+#define BM_USBPHY_DEBUG_RSVD2	0x00E00000
+#define BF_USBPHY_DEBUG_RSVD2(v)  \
+		(((v) << 21) & BM_USBPHY_DEBUG_RSVD2)
+#define BP_USBPHY_DEBUG_SQUELCHRESETCOUNT	16
+#define BM_USBPHY_DEBUG_SQUELCHRESETCOUNT	0x001F0000
+#define BF_USBPHY_DEBUG_SQUELCHRESETCOUNT(v)  \
+		(((v) << 16) & BM_USBPHY_DEBUG_SQUELCHRESETCOUNT)
+#define BP_USBPHY_DEBUG_RSVD1	13
+#define BM_USBPHY_DEBUG_RSVD1	0x0000E000
+#define BF_USBPHY_DEBUG_RSVD1(v)  \
+		(((v) << 13) & BM_USBPHY_DEBUG_RSVD1)
+#define BM_USBPHY_DEBUG_ENTX2RXCOUNT	0x00001000
+#define BP_USBPHY_DEBUG_TX2RXCOUNT	8
+#define BM_USBPHY_DEBUG_TX2RXCOUNT	0x00000F00
+#define BF_USBPHY_DEBUG_TX2RXCOUNT(v)  \
+		(((v) << 8) & BM_USBPHY_DEBUG_TX2RXCOUNT)
+#define BP_USBPHY_DEBUG_RSVD0	6
+#define BM_USBPHY_DEBUG_RSVD0	0x000000C0
+#define BF_USBPHY_DEBUG_RSVD0(v)  \
+		(((v) << 6) & BM_USBPHY_DEBUG_RSVD0)
+#define BP_USBPHY_DEBUG_ENHSTPULLDOWN	4
+#define BM_USBPHY_DEBUG_ENHSTPULLDOWN	0x00000030
+#define BF_USBPHY_DEBUG_ENHSTPULLDOWN(v)  \
+		(((v) << 4) & BM_USBPHY_DEBUG_ENHSTPULLDOWN)
+#define BP_USBPHY_DEBUG_HSTPULLDOWN	2
+#define BM_USBPHY_DEBUG_HSTPULLDOWN	0x0000000C
+#define BF_USBPHY_DEBUG_HSTPULLDOWN(v)  \
+		(((v) << 2) & BM_USBPHY_DEBUG_HSTPULLDOWN)
+#define BM_USBPHY_DEBUG_DEBUG_INTERFACE_HOLD	0x00000002
+#define BM_USBPHY_DEBUG_OTGIDPIOLOCK	0x00000001
+
+#define HW_USBPHY_DEBUG0_STATUS	(0x00000060)
+#define HW_USBPHY_DEBUG0_STATUS_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG0_STATUS)
+
+#define BP_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT	26
+#define BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT	0xFC000000
+#define BF_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT(v) \
+		(((v) << 26) & BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT	16
+#define BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT	0x03FF0000
+#define BF_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(v)  \
+		(((v) << 16) & BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT	0
+#define BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT	0x0000FFFF
+#define BF_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(v)  \
+		(((v) << 0) & BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT)
+
+#define HW_USBPHY_DEBUG1	(0x00000070)
+#define HW_USBPHY_DEBUG1_SET	(0x00000074)
+#define HW_USBPHY_DEBUG1_CLR	(0x00000078)
+#define HW_USBPHY_DEBUG1_TOG	(0x0000007c)
+#define HW_USBPHY_DEBUG1_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG1)
+#define HW_USBPHY_DEBUG1_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG1_SET)
+#define HW_USBPHY_DEBUG1_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG1_CLR)
+#define HW_USBPHY_DEBUG1_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_DEBUG1_TOG)
+
+#define BP_USBPHY_DEBUG1_RSVD1	15
+#define BM_USBPHY_DEBUG1_RSVD1	0xFFFF8000
+#define BF_USBPHY_DEBUG1_RSVD1(v) \
+		(((v) << 15) & BM_USBPHY_DEBUG1_RSVD1)
+#define BP_USBPHY_DEBUG1_ENTAILADJVD	13
+#define BM_USBPHY_DEBUG1_ENTAILADJVD	0x00006000
+#define BF_USBPHY_DEBUG1_ENTAILADJVD(v)  \
+		(((v) << 13) & BM_USBPHY_DEBUG1_ENTAILADJVD)
+#define BM_USBPHY_DEBUG1_ENTX2TX	0x00001000
+#define BP_USBPHY_DEBUG1_RSVD0	4
+#define BM_USBPHY_DEBUG1_RSVD0	0x00000FF0
+#define BF_USBPHY_DEBUG1_RSVD0(v)  \
+		(((v) << 4) & BM_USBPHY_DEBUG1_RSVD0)
+#define BP_USBPHY_DEBUG1_DBG_ADDRESS	0
+#define BM_USBPHY_DEBUG1_DBG_ADDRESS	0x0000000F
+#define BF_USBPHY_DEBUG1_DBG_ADDRESS(v)  \
+		(((v) << 0) & BM_USBPHY_DEBUG1_DBG_ADDRESS)
+
+#define HW_USBPHY_VERSION	(0x00000080)
+#define HW_USBPHY_VERSION_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_VERSION)
+
+#define BP_USBPHY_VERSION_MAJOR	24
+#define BM_USBPHY_VERSION_MAJOR	0xFF000000
+#define BF_USBPHY_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_USBPHY_VERSION_MAJOR)
+#define BP_USBPHY_VERSION_MINOR	16
+#define BM_USBPHY_VERSION_MINOR	0x00FF0000
+#define BF_USBPHY_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_USBPHY_VERSION_MINOR)
+#define BP_USBPHY_VERSION_STEP	0
+#define BM_USBPHY_VERSION_STEP	0x0000FFFF
+#define BF_USBPHY_VERSION_STEP(v)  \
+		(((v) << 0) & BM_USBPHY_VERSION_STEP)
+
+#define HW_USBPHY_IP	(0x00000090)
+#define HW_USBPHY_IP_SET	(0x00000094)
+#define HW_USBPHY_IP_CLR	(0x00000098)
+#define HW_USBPHY_IP_TOG	(0x0000009c)
+#define HW_USBPHY_IP_ADDR  \
+		(REGS_USBPHY_BASE + HW_USBPHY_IP)
+#define HW_USBPHY_IP_SET_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_IP_SET)
+#define HW_USBPHY_IP_CLR_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_IP_CLR)
+#define HW_USBPHY_IP_TOG_ADDR \
+		(REGS_USBPHY_BASE + HW_USBPHY_IP_TOG)
+
+#define BP_USBPHY_IP_RSVD1	25
+#define BM_USBPHY_IP_RSVD1	0xFE000000
+#define BF_USBPHY_IP_RSVD1(v) \
+		(((v) << 25) & BM_USBPHY_IP_RSVD1)
+#define BP_USBPHY_IP_DIV_SEL	23
+#define BM_USBPHY_IP_DIV_SEL	0x01800000
+#define BF_USBPHY_IP_DIV_SEL(v)  \
+		(((v) << 23) & BM_USBPHY_IP_DIV_SEL)
+#define BV_USBPHY_IP_DIV_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_DIV_SEL__LOWER     0x1
+#define BV_USBPHY_IP_DIV_SEL__LOWEST    0x2
+#define BV_USBPHY_IP_DIV_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_LFR_SEL	21
+#define BM_USBPHY_IP_LFR_SEL	0x00600000
+#define BF_USBPHY_IP_LFR_SEL(v)  \
+		(((v) << 21) & BM_USBPHY_IP_LFR_SEL)
+#define BV_USBPHY_IP_LFR_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_LFR_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_LFR_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_LFR_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_CP_SEL	19
+#define BM_USBPHY_IP_CP_SEL	0x00180000
+#define BF_USBPHY_IP_CP_SEL(v)  \
+		(((v) << 19) & BM_USBPHY_IP_CP_SEL)
+#define BV_USBPHY_IP_CP_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_CP_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_CP_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_CP_SEL__UNDEFINED 0x3
+#define BM_USBPHY_IP_TSTI_TX_DP	0x00040000
+#define BM_USBPHY_IP_TSTI_TX_DM	0x00020000
+#define BM_USBPHY_IP_ANALOG_TESTMODE	0x00010000
+#define BP_USBPHY_IP_RSVD0	3
+#define BM_USBPHY_IP_RSVD0	0x0000FFF8
+#define BF_USBPHY_IP_RSVD0(v)  \
+		(((v) << 3) & BM_USBPHY_IP_RSVD0)
+#define BM_USBPHY_IP_EN_USB_CLKS	0x00000004
+#define BM_USBPHY_IP_PLL_LOCKED	0x00000002
+#define BM_USBPHY_IP_PLL_POWER	0x00000001
+#endif /* __ARCH_ARM___USBPHY_H */
diff --git a/arch/arm/plat-mxs/usb_common.c b/arch/arm/plat-mxs/usb_common.c
new file mode 100644
index 0000000..5544480
--- /dev/null
+++ b/arch/arm/plat-mxs/usb_common.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb_common.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+#include <linux/io.h>
+#include "regs-usbphy.h"
+
+#define MXC_NUMBER_USB_TRANSCEIVER 6
+struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == NULL) {
+			g_xc_ops[i] = xcvr_ops;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == xcvr_ops) {
+			g_xc_ops[i] = NULL;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+void fsl_platform_set_test_mode(
+				struct fsl_usb2_platform_data *pdata,
+				enum usb_test_mode mode)
+{
+}
+EXPORT_SYMBOL(fsl_platform_set_test_mode);
+
+/* enable/disable high-speed disconnect detector of phy ctrl */
+void fsl_platform_set_usb_phy_dis(struct fsl_usb2_platform_data *pdata,
+				  bool enable)
+{
+	void __iomem *ctrl_reg = IO_ADDRESS(pdata->phy_regs + HW_USBPHY_CTRL);
+	u32 tmp = __raw_readl(ctrl_reg);
+
+	if (enable)
+		tmp |= BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	else
+		tmp &= ~BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	__raw_writel(tmp, ctrl_reg);
+}
+EXPORT_SYMBOL(fsl_platform_set_usb_phy_dis);
+
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	pr_debug("%s xceiv=0x%p\n", __func__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	pr_debug("%s xceiv=0x%p  x=0x%p\n", __func__, xceiv, x);
+	/*
+	if (x == NULL)
+		stmp3xxx_release_pin_group(&usb_mux_pins, "usb");
+		*/
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+static struct resource *otg_resources;
+
+struct resource *otg_get_resources(void)
+{
+	pr_debug("otg_get_resources\n");
+	return otg_resources;
+}
+EXPORT_SYMBOL(otg_get_resources);
+
+int otg_set_resources(struct resource *resources)
+{
+	otg_resources = resources;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_resources);
+#endif
+
+static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	if (name == NULL) {
+		printk(KERN_ERR "get_xcvr(): No tranceiver name\n");
+		return NULL;
+	}
+
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (strcmp(g_xc_ops[i]->name, name) == 0)
+			return g_xc_ops[i];
+	}
+	pr_debug("Failed %s\n", __func__);
+	return NULL;
+}
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+static int instance_id = ~(u32) 0;
+struct platform_device *host_pdev_register(struct resource *res, int n_res,
+						struct fsl_usb2_platform_data
+						*config)
+{
+	struct platform_device *pdev;
+	int rc;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platorm_data pointer ourselves.
+	 */
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct fsl_usb2_platform_data));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	pr_debug(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	instance_id++;
+
+	return pdev;
+}
+
+int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
+{
+	u32 tmp;
+	void __iomem *phy_reg = IO_ADDRESS(pdata->phy_regs);
+	void __iomem *usb_reg = pdata->regs;
+	void __iomem *usbcmd, *phy_ctrl, *portsc;
+
+	/* Reset USB IP */
+	usbcmd = usb_reg + UOG_USBCMD;
+	tmp = __raw_readl(usbcmd); /* usb command */
+	tmp &= ~UCMD_RUN_STOP;
+	__raw_writel(tmp, usbcmd);
+	while (__raw_readl(usbcmd) & UCMD_RUN_STOP)
+		;
+
+	tmp |= UCMD_RESET;
+	__raw_writel(tmp, usbcmd);
+	while (__raw_readl(usbcmd) & UCMD_RESET)
+		;
+	mdelay(10);
+
+	/* Reset USBPHY module */
+	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
+	tmp = __raw_readl(phy_ctrl);
+	tmp |= BM_USBPHY_CTRL_SFTRST;
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* Remove CLKGATE and SFTRST */
+	tmp = __raw_readl(phy_ctrl);
+	tmp &= ~(BM_USBPHY_CTRL_CLKGATE | BM_USBPHY_CTRL_SFTRST);
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* set UTMI xcvr */
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	portsc = usb_reg + UOG_PORTSC1;
+	tmp = __raw_readl(portsc);
+	tmp &=  ~PORTSC_PTS_MASK;
+	tmp |= (PORTSC_PTS_UTMI | PORTSC_PTW);
+	__raw_writel(tmp, portsc);
+
+	/* Power up the PHY */
+	__raw_writel(0, phy_reg + HW_USBPHY_PWD);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_phy_enable);
+
+static int otg_used;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+	u32 tmp;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "DR transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	otg_used = 0;
+	if (!otg_used) {
+		pr_debug("%s: grab pins\n", __func__);
+		if (xops->init)
+			xops->init(xops);
+		usb_phy_enable(pdata);
+	}
+
+	if (pdata->operating_mode == FSL_USB2_DR_HOST) {
+		/* enable FS/LS device */
+		tmp = __raw_readl(HW_USBPHY_CTRL_ADDR);
+		tmp |= (BM_USBPHY_CTRL_ENUTMILEVEL2 |
+			BM_USBPHY_CTRL_ENUTMILEVEL3);
+		__raw_writel(tmp, HW_USBPHY_CTRL_ADDR);
+	}
+
+	otg_used++;
+	pr_debug("%s: success\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(usbotg_init);
+
+void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	pdata->regs = NULL;
+	otg_used--;
+}
+EXPORT_SYMBOL(usbotg_uninit);
+
+int fsl_usb_host_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+	u32 tmp;
+	void __iomem *phy_reg = IO_ADDRESS(pdata->phy_regs);
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "%s transceiver ops missing\n", pdata->name);
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (xops->init)
+		xops->init(xops);
+	usb_phy_enable(pdata);
+	/* enable FS/LS device */
+	tmp = __raw_readl(phy_reg + HW_USBPHY_CTRL);
+	tmp |= (BM_USBPHY_CTRL_ENUTMILEVEL2 | BM_USBPHY_CTRL_ENUTMILEVEL3);
+	__raw_writel(tmp, phy_reg + HW_USBPHY_CTRL);
+
+	pr_debug("%s: %s success\n", __func__, pdata->name);
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_host_init);
+
+void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	pdata->regs = NULL;
+}
+EXPORT_SYMBOL(fsl_usb_host_uninit);
+
+int usb_host_wakeup_irq(struct device *wkup_dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL(usb_host_wakeup_irq);
+
+void usb_host_set_wakeup(struct device *wkup_dev, bool para)
+{
+}
+EXPORT_SYMBOL(usb_host_set_wakeup);
diff --git a/arch/arm/plat-mxs/utmixc.c b/arch/arm/plat-mxs/utmixc.c
new file mode 100644
index 0000000..427526c
--- /dev/null
+++ b/arch/arm/plat-mxs/utmixc.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/pmic_external.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+
+static void usb_utmi_init(struct fsl_xcvr_ops *this)
+{
+}
+
+static void usb_utmi_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void set_power(struct fsl_xcvr_ops *this,
+		      struct fsl_usb2_platform_data *pdata, int on)
+{
+
+}
+
+static struct fsl_xcvr_ops utmi_ops = {
+	.name = "utmi",
+	.xcvr_type = PORTSC_PTS_UTMI,
+	.init = usb_utmi_init,
+	.uninit = usb_utmi_uninit,
+	.set_vbus_power = set_power,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init utmixc_init(void)
+{
+	fsl_usb_xcvr_register(&utmi_ops);
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit utmixc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&utmi_ops);
+}
+
+module_init(utmixc_init);
+module_exit(utmixc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("utmi xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 2a4c8bf..6bbf50e 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -465,9 +465,10 @@ config USB_GOKU
 
 config USB_GADGET_ARC
 	boolean "Freescale USB Device Controller"
-	depends on ARCH_MXC || ARCH_STMP3XXX
+	depends on ARCH_MXC || ARCH_STMP3XXX || ARCH_MXS
 	select USB_GADGET_DUALSPEED
 	select USB_OTG_UTILS
+	select USB_GADGET_DUALSPEED if USB_GADGET_FSL_1504 || USB_GADGET_FSL_UTMI
 	help
 	   Some Freescale processors have a USBOTG controller,
 	   which supports device mode.
@@ -559,7 +560,7 @@ config USB_GADGET_DUALSPEED
 config USB_OTG
 	boolean "OTG Support"
 	depends on (USB_GADGET_OMAP && ARCH_OMAP_OTG && USB_OHCI_HCD) || \
-		   (USB_GADGET_ARC && (ARCH_MXC || ARCH_STMP3XXX) && USB_EHCI_HCD)
+		   (USB_GADGET_ARC && (ARCH_MXC || ARCH_STMP3XXX || ARCH_MXS) && USB_EHCI_HCD)
 	help
 	   The most notable feature of USB OTG is support for a
 	   "Dual-Role" device, which can act as either a device
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index 95e431c..fa9bb98 100644
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -1,14 +1,19 @@
 /*
- * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 /*!
@@ -692,7 +697,8 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 /* Bulk only class request */
 #define USB_BULK_RESET_REQUEST          0xff
 
-#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_ARCH_STMP3XXX)
+#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_ARCH_STMP3XXX) || \
+	defined(CONFIG_ARCH_MXS)
 #include <mach/fsl_usb_gadget.h>
 #elif CONFIG_PPC32
 #include <asm/fsl_usb_gadget.h>
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 2b02c5e..6abc0ba 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -61,7 +61,7 @@ config USB_EHCI_HCD
 
 config USB_EHCI_ARC
 	bool "Support for Freescale controller"
-	depends on USB_EHCI_HCD && (ARCH_MXC || ARCH_STMP3XXX)
+	depends on USB_EHCI_HCD && (ARCH_MXC || ARCH_STMP3XXX || ARCH_MXS)
 	select USB_OTG_UTILS
 	---help---
 	   Some Freescale processors have an integrated High Speed
@@ -72,7 +72,7 @@ config USB_EHCI_ARC
 
 config USB_EHCI_ARC_H1
 	bool "Support for Host1 port on Freescale controller"
-	depends on USB_EHCI_ARC	&& (ARCH_MX27 || ARCH_MX3)
+	depends on USB_EHCI_ARC	&& (ARCH_MX27 || ARCH_MX3 || ARCH_MX28)
 	---help---
 	  Enable support for the USB Host1 port.
 
@@ -102,6 +102,54 @@ config USB_STATIC_IRAM
 
 	  If in doubt, say N.
 
+choice
+	prompt "Select transceiver for DR port"
+	depends on USB_EHCI_ARC_OTG
+	default USB_EHCI_FSL_1504 if ARCH_MX3
+	default USB_EHCI_FSL_1301 if ARCH_MX27
+	default USB_EHCI_FSL_UTMI if (ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX51 || ARCH_STMP3XXX || ARCH_MXS)
+	---help---
+	  Choose the transceiver to use with the Freescale DR port.
+
+config USB_EHCI_FSL_MC13783
+	bool "Freescale MC13783"
+	depends on !MACH_MX25_3DS
+	---help---
+	  Enable support for the Full Speed Freescale MC13783 transceiver.
+
+	  The mx27ads, mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_EHCI_FSL_1301
+	bool "Philips ISP1301"
+	depends on !MACH_MX25_3DS
+	---help---
+	  Enable support for the Full Speed Philips ISP1301 transceiver.
+
+	  This is the factory default for the mx27ads board.
+	  The mx31ads and mx32ads boards require modifications
+	  to support this transceiver.
+
+config USB_EHCI_FSL_1504
+	bool "Philips ISP1504"
+	depends on MACH_MX27ADS || MACH_MX31ADS || MACH_MX32ADS ||MACH_MX31_3DS
+	---help---
+	  Enable support for the High Speed Philips ISP1504 transceiver.
+
+	  This is the factory default for the mx31ads and mx32ads boards.
+	  The mx27ads board requires modifications to support this transceiver.
+
+config USB_EHCI_FSL_UTMI
+	bool "Internal UTMI"
+	depends on (ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX51 || ARCH_STMP3XXX || ARCH_MXS)
+	---help---
+	  Enable support for the on-chip High Speed UTMI transceiver.
+
+	  This is the factory default for the mx35ads board.
+
+endchoice
+
+
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators"
 	depends on USB_EHCI_HCD
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index d6a348b..bb030a3 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -1,17 +1,19 @@
 /*
- * include/linux/fsl_devices.h
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
- * Definitions for any platform device related flags or structures for
- * Freescale processor devices
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- * Maintainer: Kumar Gala <galak@kernel.crashing.org>
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * Copyright 2004, 2009 Freescale Semiconductor, Inc
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #ifndef _FSL_DEVICE_H_
@@ -78,6 +80,7 @@ struct fsl_usb2_platform_data {
 	int (*platform_init) (struct platform_device *);
 	void (*platform_uninit) (struct fsl_usb2_platform_data *);
 	void __iomem *regs;	/* ioremap'd register base */
+	u32 phy_regs;	/* usb phy register base */
 	u32 xcvr_type;		/* PORTSC_PTS_* */
 	char *transceiver;	/* transceiver name */
 	unsigned power_budget;	/* for hcd->power_budget */
-- 
1.5.4.4

