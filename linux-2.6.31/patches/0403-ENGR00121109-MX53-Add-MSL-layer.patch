From db27e9f4f53e8ad30cb14903122b90102535ad16 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <Dinh.Nguyen@freescale.com>
Date: Thu, 18 Mar 2010 14:43:02 -0500
Subject: [PATCH] ENGR00121109 MX53: Add MSL layer

Added MSL layer for MX53 with changes in MX51 for single kernel boot
support.
Added CCGR clocking changes.
Fixed SDHC clock dependencies.
Fix emi_intr clocks and fix warnings in clock code.

Signed-off-by: Rob Herring <r.herring@freescale.com>
Signed-off-by: Lily Zhang <r58066@freescale.com>
Signed-off-by: Xinyu Chen <xinyu.chen@freescale.com>
Signed-off-by: Ranjani Vaidyanathan-RA5478 <Ranjani.Vaidyanathan@freescale.com>
Signed-off-by: Dinh Nguyen <Dinh.Nguyen@freescale.com>
---
 arch/arm/configs/imx51_defconfig              |    6 +-
 arch/arm/configs/imx5_defconfig               | 2070 +++++++++++++++++++++++++
 arch/arm/mach-mx5/Kconfig                     |   29 +-
 arch/arm/mach-mx5/Makefile                    |    1 +
 arch/arm/mach-mx5/Makefile.boot               |    9 +-
 arch/arm/mach-mx5/board-mx53_evk.h            |   98 ++
 arch/arm/mach-mx5/bus_freq.c                  |    2 -
 arch/arm/mach-mx5/clock.c                     | 1091 ++++++++++++--
 arch/arm/mach-mx5/cpu.c                       |   31 +-
 arch/arm/mach-mx5/crm_regs.h                  |  181 ++-
 arch/arm/mach-mx5/devices.c                   |  249 ++-
 arch/arm/mach-mx5/devices.h                   |    2 +
 arch/arm/mach-mx5/dma.c                       |  709 +++++++++-
 arch/arm/mach-mx5/iomux.c                     |   58 +-
 arch/arm/mach-mx5/iomux.h                     |  178 +--
 arch/arm/mach-mx5/mm.c                        |   19 +-
 arch/arm/mach-mx5/mx51_3stack.c               |    8 +-
 arch/arm/mach-mx5/mx51_3stack_gpio.c          |    5 +-
 arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c  |    1 +
 arch/arm/mach-mx5/mx51_babbage.c              |    8 +-
 arch/arm/mach-mx5/mx51_babbage_gpio.c         |    6 +-
 arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c |    1 +
 arch/arm/mach-mx5/mx51_pins.h                 |  688 +++++----
 arch/arm/mach-mx5/mx53_evk.c                  |  598 +++++++
 arch/arm/mach-mx5/mx53_evk_gpio.c             |  749 +++++++++
 arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c     |  353 +++++
 arch/arm/mach-mx5/mx53_pins.h                 |  421 +++++
 arch/arm/mach-mx5/sdma_script_code_mx53.h     |  193 +++
 arch/arm/mach-mx5/serial.c                    |   85 +-
 arch/arm/mach-mx5/serial.h                    |   24 +
 arch/arm/plat-mxc/Kconfig                     |    6 +-
 arch/arm/plat-mxc/cpu_common.c                |    1 -
 arch/arm/plat-mxc/cpufreq.c                   |    4 +-
 arch/arm/plat-mxc/dvfs_per.c                  |    2 +-
 arch/arm/plat-mxc/include/mach/common.h       |    5 +-
 arch/arm/plat-mxc/include/mach/hardware.h     |    6 +-
 arch/arm/plat-mxc/include/mach/irqs.h         |    8 +-
 arch/arm/plat-mxc/include/mach/memory.h       |    8 +-
 arch/arm/plat-mxc/include/mach/mx51.h         |  489 ------
 arch/arm/plat-mxc/include/mach/mx5x.h         |  579 +++++++
 arch/arm/plat-mxc/include/mach/mxc.h          |   17 +-
 arch/arm/plat-mxc/include/mach/timex.h        |    4 +-
 arch/arm/plat-mxc/include/mach/uncompress.h   |    2 +
 arch/arm/tools/mach-types                     |    1 +
 drivers/video/mxc/Makefile                    |    2 +-
 45 files changed, 7737 insertions(+), 1270 deletions(-)

diff --git a/arch/arm/configs/imx51_defconfig b/arch/arm/configs/imx51_defconfig
index 3925f01..2c74777 100644
--- a/arch/arm/configs/imx51_defconfig
+++ b/arch/arm/configs/imx51_defconfig
@@ -543,7 +543,7 @@ CONFIG_MTD_MXC_DATAFLASH=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
-CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND is not set
 # CONFIG_MTD_NAND_VERIFY_WRITE is not set
 # CONFIG_MTD_NAND_ECC_SMC is not set
 # CONFIG_MTD_NAND_MUSEUM_IDS is not set
@@ -1747,8 +1747,8 @@ CONFIG_MXC_MC13892_POWER=y
 # MXC Security Drivers
 #
 # CONFIG_MXC_SECURITY_SCC is not set
-CONFIG_MXC_SECURITY_SCC2=y
-CONFIG_SCC_DEBUG=y
+# CONFIG_MXC_SECURITY_SCC2 is not set
+# CONFIG_SCC_DEBUG is not set
 # CONFIG_MXC_SECURITY_RNG is not set
 
 #
diff --git a/arch/arm/configs/imx5_defconfig b/arch/arm/configs/imx5_defconfig
new file mode 100644
index 0000000..737cd08
--- /dev/null
+++ b/arch/arm/configs/imx5_defconfig
@@ -0,0 +1,2070 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=64
+CONFIG_UTMI_MXC=y
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+# CONFIG_ARCH_MX2 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX35 is not set
+# CONFIG_ARCH_MX37 is not set
+CONFIG_ARCH_MX5=y
+CONFIG_MXC_SDMA_API=y
+CONFIG_SDMA_IRAM=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_ARCH_MXC_HAS_NFC_V3=y
+
+#
+# MX5 Options
+#
+# CONFIG_ARCH_MX51 is not set
+CONFIG_ARCH_MX53=y
+CONFIG_MX5_OPTIONS=y
+CONFIG_MACH_MX53_EVK=y
+CONFIG_ARCH_MXC_HAS_NFC_V3_2=y
+CONFIG_MXC_TZIC=y
+CONFIG_ISP1504_MXC=y
+# CONFIG_MXC_IRQ_PRIOR is not set
+# CONFIG_MXC_PWM is not set
+CONFIG_MXC_DVFS_PER=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HIGHMEM=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_IMX=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_APM_EMULATION=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=y
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+CONFIG_BT_HCIVHCI=y
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_MXC_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_IMX_NFC is not set
+# CONFIG_MTD_NAND_MXC_V3 is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+# CONFIG_PATA_PLATFORM is not set
+CONFIG_PATA_FSL=m
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+CONFIG_SMSC911X=y
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+CONFIG_FEC=y
+# CONFIG_FEC2 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_APMPOWER is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXC=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_MXC_IIM=y
+CONFIG_IMX_SIM=m
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_IMX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_IMX is not set
+CONFIG_I2C_MXC=y
+CONFIG_I2C_MXC_HS=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+# CONFIG_SPI_MXC_SELECT2 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=m
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=m
+# CONFIG_W1_MASTER_GPIO is not set
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2751 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+CONFIG_W1_SLAVE_DS2438=m
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+CONFIG_APM_POWER=y
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXC_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_MXC_CAMERA=m
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+# CONFIG_VIDEO_MXC_CSI_CAMERA is not set
+# CONFIG_MXC_CAMERA_MC521DA is not set
+# CONFIG_MXC_EMMA_CAMERA_MICRON111 is not set
+# CONFIG_MXC_CAMERA_OV2640_EMMA is not set
+# CONFIG_MXC_CAMERA_MICRON111 is not set
+# CONFIG_MXC_CAMERA_OV2640 is not set
+CONFIG_MXC_CAMERA_OV3640=m
+# CONFIG_MXC_TVIN_ADV7180 is not set
+CONFIG_MXC_IPU_PRP_VF_SDC=m
+CONFIG_MXC_IPU_PRP_ENC=m
+CONFIG_MXC_IPU_CSI_ENC=m
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+# CONFIG_VIDEO_MXC_IPUV1_WVGA_OUTPUT is not set
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL=y
+CONFIG_FB_MXC_TVOUT_TVE=y
+# CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL is not set
+CONFIG_FB_MXC_CH7026=y
+# CONFIG_FB_MXC_TVOUT_CH7024 is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_MXC=y
+CONFIG_BACKLIGHT_MXC_MC13892=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_MXC_SPDIF=m
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_MXC_SOC=y
+CONFIG_SND_MXC_SOC_SSI=y
+CONFIG_SND_MXC_SOC_IRAM=y
+CONFIG_SND_SOC_IMX_3STACK_SGTL5000=y
+# CONFIG_SND_SOC_IMX_3STACK_AK4647 is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8580 is not set
+# CONFIG_SND_SOC_IMX_3STACK_AK5702 is not set
+# CONFIG_SND_SOC_IMX_3STACK_BLUETOOTH is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_SGTL5000=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+CONFIG_HID_APPLE=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CYPRESS=m
+# CONFIG_HID_DRAGONRISE is not set
+CONFIG_HID_EZKEY=m
+# CONFIG_HID_KYE is not set
+CONFIG_HID_GYRATION=m
+# CONFIG_HID_KENSINGTON is not set
+CONFIG_HID_LOGITECH=m
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+# CONFIG_HID_NTRIG is not set
+CONFIG_HID_PANTHERLORD=m
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SUNPLUS=m
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_OTG=y
+# CONFIG_USB_STATIC_IRAM is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_ARC is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_IMX_ESDHCI=y
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_MC13892=y
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+# CONFIG_RTC_DRV_IMXDI is not set
+CONFIG_RTC_MC13892=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MC13892=y
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV is not set
+CONFIG_UIO_PDRV_GENIRQ=m
+# CONFIG_UIO_SMX is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_STAGING is not set
+
+#
+# MXC support drivers
+#
+CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V3=y
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_PMIC=y
+# CONFIG_MXC_PMIC_MC13783 is not set
+CONFIG_MXC_PMIC_MC13892=y
+CONFIG_MXC_PMIC_I2C=y
+CONFIG_MXC_PMIC_SPI=y
+# CONFIG_MXC_PMIC_MC34704 is not set
+# CONFIG_MXC_PMIC_MC9SDZ60 is not set
+# CONFIG_MXC_PMIC_CHARDEV is not set
+
+#
+# MXC PMIC Client Drivers
+#
+CONFIG_MXC_MC13892_ADC=y
+CONFIG_MXC_MC13892_RTC=y
+CONFIG_MXC_MC13892_LIGHT=y
+CONFIG_MXC_MC13892_BATTERY=y
+CONFIG_MXC_MC13892_CONNECTIVITY=y
+CONFIG_MXC_MC13892_POWER=y
+# CONFIG_MXC_PMIC_MC9S08DZ60 is not set
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_SCC2 is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+
+#
+# SAHARA2 Security Hardware Support
+#
+# CONFIG_MXC_SAHARA is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+# CONFIG_MXC_HWEVENT is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+CONFIG_MXC_VPU=y
+CONFIG_MXC_VPU_IRAM=y
+# CONFIG_MXC_VPU_DEBUG is not set
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+
+#
+# MXC Bluetooth support
+#
+
+#
+# Broadcom GPS ioctrl support
+#
+
+#
+# MXC Media Local Bus Driver
+#
+
+#
+# i.MX ADC support
+#
+# CONFIG_IMX_ADC is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4DEV_COMPAT is not set
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
index 9dc1d3a..e7bc97f 100644
--- a/arch/arm/mach-mx5/Kconfig
+++ b/arch/arm/mach-mx5/Kconfig
@@ -1,9 +1,10 @@
-menu "MX5 Options"
-	depends on ARCH_MX5
+if ARCH_MX5
 
 config ARCH_MX51
-	bool "Support MX51 based platforms"
-	default y
+	bool
+
+config ARCH_MX53
+	bool
 
 config FORCE_MAX_ZONEORDER
     int "MAX_ORDER"
@@ -17,20 +18,28 @@ config MX5_OPTIONS
 	select MXC_TZIC
 
 config MACH_MX51_3DS
-	bool "Support MX51 3-Stack platforms"
-	default y
-	depends on ARCH_MX51
+	bool "Support MX51 3-Stack platform"
+	select ARCH_MX51
 	help
 	  Include support for MX51 3-Stack platform. This includes specific
 	  configurations for the board and its peripherals.
 
 config MACH_MX51_BABBAGE
-	bool "Support MX51 BABBAGE platforms"
-	depends on ARCH_MX51
+	bool "Support MX51 BABBAGE platform"
+	select ARCH_MX51
 	help
 	  Include support for MX51 Babbage platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX53_EVK
+	bool "Support MX53 EVK platform"
+	select ARCH_MX53
+	help
+	  Include support for MX53 EVK platform. This includes specific
+	  configurations for the board and its peripherals.
+
+comment "MX5x Options:"
+
 config MXC_SDMA_API
         bool "Use SDMA API"
         default y
@@ -60,4 +69,4 @@ config SDMA_IRAM
 	help
 	  Support Internal RAM as SDMA buffer or control structures
 
-endmenu
+endif
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
index 1e94b4c..cbf2137 100644
--- a/arch/arm/mach-mx5/Makefile
+++ b/arch/arm/mach-mx5/Makefile
@@ -10,4 +10,5 @@ sdram_autogating.o bus_freq.o usb_dr.o usb_h1.o usb_h2.o dummy_gpio.o wfi.o susp
 
 obj-$(CONFIG_MACH_MX51_3DS) += mx51_3stack.o mx51_3stack_gpio.o mx51_3stack_pmic_mc13892.o
 obj-$(CONFIG_MACH_MX51_BABBAGE) += mx51_babbage.o mx51_babbage_gpio.o mx51_babbage_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX53_EVK) += mx53_evk.o mx53_evk_gpio.o mx53_evk_pmic_mc13892.o
 
diff --git a/arch/arm/mach-mx5/Makefile.boot b/arch/arm/mach-mx5/Makefile.boot
index 9939a19..741f604 100644
--- a/arch/arm/mach-mx5/Makefile.boot
+++ b/arch/arm/mach-mx5/Makefile.boot
@@ -1,3 +1,6 @@
-   zreladdr-y	:= 0x90008000
-params_phys-y	:= 0x90000100
-initrd_phys-y	:= 0x90800000
+   zreladdr-$(CONFIG_ARCH_MX51)	:= 0x90008000
+params_phys-$(CONFIG_ARCH_MX51)	:= 0x90000100
+initrd_phys-$(CONFIG_ARCH_MX51)	:= 0x90800000
+   zreladdr-$(CONFIG_ARCH_MX53)	:= 0x70008000
+params_phys-$(CONFIG_ARCH_MX53)	:= 0x70000100
+initrd_phys-$(CONFIG_ARCH_MX53)	:= 0x70800000
diff --git a/arch/arm/mach-mx5/board-mx53_evk.h b/arch/arm/mach-mx5/board-mx53_evk.h
new file mode 100644
index 0000000..14d1382
--- /dev/null
+++ b/arch/arm/mach-mx5/board-mx53_evk.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX53_EVK_H__
+#define __ASM_ARCH_MXC_BOARD_MX53_EVK_H__
+
+/*!
+ * @defgroup BRDCFG_MX53 Board Configuration Options
+ * @ingroup MSL_MX53
+ */
+
+/*!
+ * @file mach-mx53/board-mx53_evk.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX53 EVK Platform.
+ *
+ * @ingroup BRDCFG_MX53
+ */
+
+/*
+ * Include Files
+ */
+#include <mach/mxc_uart.h>
+
+/*!
+ * @name MXC UART board level configurations
+ */
+/*! @{ */
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV	0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV	0
+
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE		MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR		NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED		1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE		MODE_DCE
+#define UART2_IR		IRDA
+#define UART2_ENABLED		1
+/* UART 3 configuration */
+#define UART3_MODE		MODE_DTE
+#define UART3_IR		NO_IRDA
+#define UART3_ENABLED		1
+/* UART 4 configuration */
+#define UART4_MODE		MODE_DCE
+#define UART4_IR		NO_IRDA
+#define UART4_ENABLED		1
+/* UART 5 configuration */
+#define UART5_MODE		MODE_DCE
+#define UART5_IR		NO_IRDA
+#define UART5_ENABLED		1
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+extern int __init mx53_evk_init_mc13892(void);
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX53_EVK_H__ */
diff --git a/arch/arm/mach-mx5/bus_freq.c b/arch/arm/mach-mx5/bus_freq.c
index ae90f03..ce265fc 100644
--- a/arch/arm/mach-mx5/bus_freq.c
+++ b/arch/arm/mach-mx5/bus_freq.c
@@ -94,7 +94,6 @@ struct dvfs_wp dvfs_core_setpoint[] = {
 
 int set_low_bus_freq(void)
 {
-	struct clk *tclk;
 	u32 reg;
 
 	if (busfreq_suspended)
@@ -153,7 +152,6 @@ int set_low_bus_freq(void)
 int set_high_bus_freq(int high_bus_freq)
 {
 	u32 reg;
-	struct clk *tclk;
 
 	if (bus_freq_scaling_initialized) {
 		stop_sdram_autogating();
diff --git a/arch/arm/mach-mx5/clock.c b/arch/arm/mach-mx5/clock.c
index fe39bce..184e877 100644
--- a/arch/arm/mach-mx5/clock.c
+++ b/arch/arm/mach-mx5/clock.c
@@ -34,11 +34,12 @@ static struct clk pll1_main_clk;
 static struct clk pll1_sw_clk;
 static struct clk pll2_sw_clk;
 static struct clk pll3_sw_clk;
+static struct clk pll4_sw_clk;
 static struct clk lp_apm_clk;
 static struct clk tve_clk;
 static struct clk emi_fast_clk;
 static struct clk emi_slow_clk;
-static struct clk emi_intr_clk;
+static struct clk emi_intr_clk[];
 static struct clk ddr_clk;
 static struct clk ipu_clk[];
 static struct clk axi_a_clk;
@@ -54,6 +55,7 @@ static struct cpu_wp *cpu_wp_tbl;
 void __iomem *pll1_base;
 void __iomem *pll2_base;
 void __iomem *pll3_base;
+void __iomem *pll4_base;
 
 int cpu_wp_nr;
 int lp_high_freq;
@@ -71,6 +73,8 @@ extern void propagate_rate(struct clk *tclk);
 struct cpu_wp *(*get_cpu_wp)(int *wp);
 void (*set_num_cpu_wp)(int num);
 
+static struct clk esdhc3_clk[];
+
 static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
 {
 	u32 min_pre, temp_pre, old_err, err;
@@ -199,6 +203,8 @@ static inline void __iomem *_get_pll_base(struct clk *pll)
 		return pll2_base;
 	else if (pll == &pll3_sw_clk)
 		return pll3_base;
+	else if (pll == &pll4_sw_clk)
+		return pll4_base;
 	else
 		BUG();
 
@@ -524,6 +530,17 @@ static struct clk pll3_sw_clk = {
 	.flags = RATE_PROPAGATES,
 };
 
+/* same as pll4_main_clk. These two clocks should always be the same */
+static struct clk pll4_sw_clk = {
+	.name = "pll4",
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
 static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg;
@@ -954,7 +971,10 @@ static int _clk_max_enable(struct clk *clk)
 
 	/* Handshake with MAX when LPM is entered. */
 	reg = __raw_readl(MXC_CCM_CLPCR);
-	reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
+	else
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX53;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 
 	return 0;
@@ -969,7 +989,10 @@ static void _clk_max_disable(struct clk *clk)
 
 	/* No Handshake with MAX when LPM is entered as its disabled. */
 	reg = __raw_readl(MXC_CCM_CLPCR);
-	reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
+	else
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX53;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 }
 
@@ -1109,14 +1132,27 @@ static struct clk emi_fast_clk = {
 	.disable = _clk_disable_inwait,
 };
 
-static struct clk emi_intr_clk = {
+static struct clk emi_intr_clk[] = {
+	{
 	.name = "emi_intr_clk",
+	.id = 0,
 	.parent = &ahb_clk,
 	.secondary = &ahbmux2_clk,
 	.enable_reg = MXC_CCM_CCGR5,
 	.enable_shift = MXC_CCM_CCGR5_CG9_OFFSET,
 	.enable = _clk_enable,
 	.disable = _clk_disable_inwait,
+	},
+	{
+	.name = "emi_intr_clk",
+	.id = 1,
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG4_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	}
 };
 
 static void _clk_ipg_recalc(struct clk *clk)
@@ -1219,6 +1255,23 @@ static struct clk ipumux2_clk = {
 	.disable = _clk_ipmux_disable,
 };
 
+static int _clk_ocram_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void _clk_ocram_disable(struct clk *clk)
+{
+}
+
+static struct clk ocram_clk = {
+	.name = "ocram_clk",
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG1_OFFSET,
+	.enable = _clk_ocram_enable,
+	.disable = _clk_ocram_disable,
+};
+
 
 static struct clk aips_tz1_clk = {
 	.name = "aips_tz1_clk",
@@ -1256,7 +1309,10 @@ static int _clk_sdma_enable(struct clk *clk)
 
 	/* Handshake with SDMA when LPM is entered. */
 	reg = __raw_readl(MXC_CCM_CLPCR);
-	reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	else
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX53;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 
 	return 0;
@@ -1269,7 +1325,10 @@ static void _clk_sdma_disable(struct clk *clk)
 	_clk_disable(clk);
 	/* No handshake with SDMA as its not enabled. */
 	reg = __raw_readl(MXC_CCM_CLPCR);
-	reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	else
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX53;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 }
 
@@ -1287,7 +1346,7 @@ static struct clk sdma_clk[] = {
 	 .name = "sdma_ipg_clk",
 	 .parent = &ipg_clk,
 #ifdef CONFIG_SDMA_IRAM
-	 .secondary = &emi_intr_clk,
+	 .secondary = &emi_intr_clk[0],
 #endif
 	 },
 };
@@ -1324,7 +1383,10 @@ static void _clk_ipu_disable(struct clk *clk)
 	/* No handshake with IPU whe dividers are changed
 	 * as its not enabled. */
 	reg = __raw_readl(MXC_CCM_CCDR);
-	reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	else
+		reg |= MXC_CCM_CCDR_IPU_HS_MX53_MASK;
 	__raw_writel(reg, MXC_CCM_CCDR);
 
 	/* No handshake with IPU when LPM is entered as its not enabled. */
@@ -1378,7 +1440,11 @@ static int _clk_ipu_di_set_parent(struct clk *clk, struct clk *parent)
 		reg |= 1 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
 	else if (parent == &ckih_clk)
 		reg |= 2 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
-	else if (parent == &tve_clk)
+	else if ((parent == &pll4_sw_clk) && (clk->id == 0)) {
+		if (cpu_is_mx51())
+			return -EINVAL;
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	} else if ((parent == &tve_clk) && (clk->id == 1))
 		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
 	else		/* Assume any other clock is external clock pin */
 		reg |= 4 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
@@ -1396,11 +1462,16 @@ static void _clk_ipu_di_recalc(struct clk *clk)
 		MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
 	if (mux == 0) {
 		reg = __raw_readl(MXC_CCM_CDCDR) &
-		    MXC_CCM_CDCDR_DI_CLK_PRED_MASK;
-		div = (reg >> MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET) + 1;
+		    MXC_CCM_CDCDR_DI1_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET) + 1;
 		clk->rate = clk->parent->rate / div;
-	} else if (mux == 3) {
+	} else if ((mux == 3) && (clk->id == 1)) {
 		clk->rate = clk->parent->rate / 8;
+	} else if ((mux == 3) && (clk->id == 0)) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+			MXC_CCM_CDCDR_DI_PLL4_PODF_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET) + 1;
+		clk->rate = clk->parent->rate / div;
 	} else {
 		clk->rate = clk->parent->rate;
 	}
@@ -1416,10 +1487,20 @@ static int _clk_ipu_di_set_rate(struct clk *clk, unsigned long rate)
 	if (((clk->parent->rate / div) != rate) || (div > 8))
 		return -EINVAL;
 
-	reg = __raw_readl(MXC_CCM_CDCDR);
-	reg &= ~MXC_CCM_CDCDR_DI_CLK_PRED_MASK;
-	reg |= (div - 1) << MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET;
-	__raw_writel(reg, MXC_CCM_CDCDR);
+	if ((clk->parent == &pll4_sw_clk) && (clk->id == 0)) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		reg &= ~MXC_CCM_CDCDR_DI_PLL4_PODF_MASK;
+		reg |= (div - 1) << MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCDR);
+	} else if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		reg &= ~MXC_CCM_CDCDR_DI1_CLK_PRED_MASK;
+		reg |= (div - 1) << MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCDR);
+	} else if ((clk->parent == &tve_clk) && (clk->id == 1))
+		clk->rate = rate; /*the rate decided by tve hw actually*/
+	else
+		return -EINVAL;
 
 	clk->rate = rate;
 
@@ -1692,14 +1773,16 @@ static int _clk_tve_set_parent(struct clk *clk, struct clk *parent)
 
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 
-	if (parent == &pll3_sw_clk) {
+	if ((parent == &pll3_sw_clk) && cpu_is_mx51()) {
 		reg &= ~(MXC_CCM_CSCMR1_TVE_CLK_SEL);
-	} else if (parent == &osc_clk) {
+	} else if ((parent == &pll4_sw_clk) && cpu_is_mx53()) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL);
+	} else if ((parent == &osc_clk) && cpu_is_mx51()) {
 		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
-		reg &= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+		reg &= ~MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
 	} else if (parent == &ckih_clk) {
-		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
 		reg |= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL; /* Reserved on MX53 */
 	} else {
 		BUG();
 	}
@@ -1713,7 +1796,7 @@ static void _clk_tve_recalc(struct clk *clk)
 	u32 reg, div;
 
 	reg = __raw_readl(MXC_CCM_CSCMR1);
-	if ((reg & MXC_CCM_CSCMR1_TVE_CLK_SEL) == 0) {
+	if ((reg & (MXC_CCM_CSCMR1_TVE_CLK_SEL | MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL)) == 0) {
 		reg = __raw_readl(MXC_CCM_CDCDR) &
 		    MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
 		div = (reg >> MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET) + 1;
@@ -1729,7 +1812,9 @@ static unsigned long _clk_tve_round_rate(struct clk *clk,
 	u32 reg, div;
 
 	reg = __raw_readl(MXC_CCM_CSCMR1);
-	if (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL)
+	if (cpu_is_mx51() && (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL))
+		return -EINVAL;
+	if (cpu_is_mx53() && (reg & MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL))
 		return -EINVAL;
 
 	div = clk->parent->rate / rate;
@@ -1745,7 +1830,9 @@ static int _clk_tve_set_rate(struct clk *clk, unsigned long rate)
 	u32 reg, div;
 
 	reg = __raw_readl(MXC_CCM_CSCMR1);
-	if (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL)
+	if (cpu_is_mx51() && (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL))
+		return -EINVAL;
+	if (cpu_is_mx53() && (reg & MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL))
 		return -EINVAL;
 
 	div = clk->parent->rate / rate;
@@ -1777,9 +1864,9 @@ static void _clk_tve_disable(struct clk *clk)
 {
 	_clk_disable(clk);
 	if (clk_get_parent(&ipu_di_clk[1]) == clk) {
+		clk_disable(&ipu_di_clk[1]);
 		ipu_di_clk[1].set_parent(&ipu_di_clk[1], &pll3_sw_clk);
 		ipu_di_clk[1].parent = &pll3_sw_clk;
-		clk_disable(&ipu_di_clk[1]);
 	}
 }
 
@@ -1922,6 +2009,80 @@ static struct clk uart3_clk[] = {
 	 },
 };
 
+static struct clk uart4_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart4_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART4_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart5_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart5_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART5_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGR7_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk esai_clk[] = {
+	{
+	 .name = "esai_clk",
+	 .id = 2,
+	 .parent = &pll3_sw_clk,
+	 .secondary = &esai_clk[1],
+	 .enable_reg = MXC_CCM_CCGR6,
+	 .enable_shift = MXC_CCM_CCGR6_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .name = "esai_ipg_clk",
+	 .id = 2,
+	 .parent = &pll3_sw_clk,
+	 .enable_reg = MXC_CCM_CCGR6,
+	 .enable_shift = MXC_CCM_CCGR6_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
 static struct clk gpt_clk[] = {
 	{
 	 .name = "gpt_clk",
@@ -2022,6 +2183,15 @@ static struct clk i2c_clk[] = {
 	 .enable = _clk_enable,
 	 .disable = _clk_disable,
 	 },
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGR1_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
 };
 
 static void _clk_hsi2c_serial_recalc(struct clk *clk)
@@ -2235,7 +2405,7 @@ static struct clk ssi1_clk[] = {
 	 .id = 0,
 	 .parent = &aips_tz2_clk,
 #ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &emi_intr_clk,
+	 .secondary = &emi_intr_clk[0],
 #else
 	 .secondary = &emi_fast_clk,
 #endif
@@ -2298,7 +2468,7 @@ static struct clk ssi2_clk[] = {
 	 .id = 1,
 	 .parent = &spba_clk,
 #ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &emi_intr_clk,
+	 .secondary = &emi_intr_clk[0],
 #else
 	 .secondary = &emi_fast_clk,
 #endif
@@ -2323,6 +2493,26 @@ static void _clk_ssi_ext1_recalc(struct clk *clk)
 	}
 }
 
+static int _clk_ssi_ext1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	div = clk->parent->rate / rate;
+	if (div == 0)
+		div++;
+	if (((clk->parent->rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK;
+	reg |= (div - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
 static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg, mux;
@@ -2343,10 +2533,25 @@ static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
+static unsigned long _clk_ssi_ext1_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return clk->parent->rate / div;
+}
+
 static struct clk ssi_ext1_clk = {
 	.name = "ssi_ext1_clk",
 	.parent = &pll3_sw_clk,
 	.set_parent = _clk_ssi_ext1_set_parent,
+	.set_rate = _clk_ssi_ext1_set_rate,
+	.round_rate = _clk_ssi_ext1_round_rate,
 	.recalc = _clk_ssi_ext1_recalc,
 	.enable_reg = MXC_CCM_CCGR3,
 	.enable_shift = MXC_CCM_CCGR3_CG14_OFFSET,
@@ -2492,12 +2697,13 @@ static struct clk usboh3_clk[] = {
 	 .parent = &tmax2_clk,
 #if defined(CONFIG_USB_STATIC_IRAM) \
     || defined(CONFIG_USB_STATIC_IRAM_PPH)
-	 .secondary = &emi_intr_clk,
+	 .secondary = &emi_intr_clk[0],
 #else
 	 .secondary = &emi_fast_clk,
 #endif
 	 },
 };
+
 static struct clk usb_ahb_clk = {
 	 .name = "usb_ahb_clk",
 	 .parent = &ipg_clk,
@@ -2539,8 +2745,10 @@ static int _clk_usb_phy_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk usb_phy_clk = {
+static struct clk usb_phy_clk[] = {
+	{
 	.name = "usb_phy_clk",
+	.id = 0,
 	.parent = &pll3_sw_clk,
 	.secondary = &tmax3_clk,
 	.set_parent = _clk_usb_phy_set_parent,
@@ -2549,6 +2757,19 @@ static struct clk usb_phy_clk = {
 	.enable_reg = MXC_CCM_CCGR2,
 	.enable_shift = MXC_CCM_CCGR2_CG0_OFFSET,
 	.disable = _clk_disable,
+	},
+	{
+	.name = "usb_phy_clk",
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.recalc = _clk_usb_phy_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG6_OFFSET,
+	.disable = _clk_disable,
+	}
 };
 
 static struct clk esdhc_dep_clks = {
@@ -2557,16 +2778,15 @@ static struct clk esdhc_dep_clks = {
 	 .secondary = &emi_fast_clk,
 };
 
-
 static void _clk_esdhc1_recalc(struct clk *clk)
 {
 	u32 reg, prediv, podf;
 
 	reg = __raw_readl(MXC_CCM_CSCDR1);
-	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK) >>
-		  MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET) + 1;
-	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK) >>
-		MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET) + 1;
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET) + 1;
 
 	clk->rate = clk->parent->rate / (prediv * podf);
 }
@@ -2578,20 +2798,49 @@ static int _clk_esdhc1_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
 		       &lp_apm_clk);
 	reg = __raw_readl(MXC_CCM_CSCMR1) &
-	    ~MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK;
-	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET;
+	    ~MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
 }
 
+
+static int _clk_sdhc1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	if (cpu_is_mx53()) {
+		div = clk->parent->rate / rate;
+
+		if ((clk->parent->rate / div) != rate)
+			return -EINVAL;
+
+		 __calc_pre_post_dividers(div, &pre, &post);
+
+		/* Set sdhc1 clock divider */
+		reg = __raw_readl(MXC_CCM_CSCDR1) &
+			~(MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK |
+			MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK);
+		reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET;
+		reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET;
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	       clk->rate = rate;
+	}
+	return 0;
+}
+
 static struct clk esdhc1_clk[] = {
 	{
 	 .name = "esdhc_clk",
 	 .id = 0,
-	 .parent = &pll3_sw_clk,
+	 .parent = &pll2_sw_clk,
 	 .set_parent = _clk_esdhc1_set_parent,
 	 .recalc = _clk_esdhc1_recalc,
+	 .set_rate = _clk_sdhc1_set_rate,
 	 .enable = _clk_enable,
 	 .enable_reg = MXC_CCM_CCGR3,
 	 .enable_shift = MXC_CCM_CCGR3_CG1_OFFSET,
@@ -2621,26 +2870,39 @@ static void _clk_esdhc2_recalc(struct clk *clk)
 {
 	u32 reg, prediv, podf;
 
-	reg = __raw_readl(MXC_CCM_CSCDR1);
-	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK) >>
-		  MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET) + 1;
-	podf = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK) >>
-		MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET) + 1;
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		prediv = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET) + 1;
 
-	clk->rate = clk->parent->rate / (prediv * podf);
+		clk->rate = clk->parent->rate / (prediv * podf);
+	}
 }
 
 static int _clk_esdhc2_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg, mux;
 
-	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
-		       &lp_apm_clk);
-	reg = __raw_readl(MXC_CCM_CSCMR1) &
-	    ~MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK;
-	reg |= mux << MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET;
-	__raw_writel(reg, MXC_CCM_CSCMR1);
+	if (cpu_is_mx51()) {
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &lp_apm_clk);
+		reg = __raw_readl(MXC_CCM_CSCMR1) &
+		    ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	} else { /* MX53  */
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+		else if (parent == &esdhc3_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+		else
+			BUG();
+
+	}
 
+	__raw_writel(reg, MXC_CCM_CSCMR1);
 	return 0;
 }
 
@@ -2650,7 +2912,6 @@ static struct clk esdhc2_clk[] = {
 	 .id = 1,
 	 .parent = &pll3_sw_clk,
 	 .set_parent = _clk_esdhc2_set_parent,
-	 .recalc = _clk_esdhc2_recalc,
 	 .enable = _clk_enable,
 	 .enable_reg = MXC_CCM_CCGR3,
 	 .enable_shift = MXC_CCM_CCGR3_CG3_OFFSET,
@@ -2677,21 +2938,70 @@ static struct clk esdhc2_clk[] = {
 
 static int _clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)
 {
-	u32 reg;
+	u32 reg, mux;
 
-	reg = __raw_readl(MXC_CCM_CSCMR1);
-	if (parent == &esdhc1_clk[0])
-		reg &= ~MXC_CCM_CSCMR1_ESDHC3_CLK_SEL;
-	else if (parent == &esdhc2_clk[0])
-		reg |= MXC_CCM_CSCMR1_ESDHC3_CLK_SEL;
-	else
-		BUG();
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51;
+		else if (parent == &esdhc2_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51;
+		else
+			BUG();
+	} else { /* MX53 */
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &lp_apm_clk);
+		reg = __raw_readl(MXC_CCM_CSCMR1) &
+		    ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	}
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
 }
 
+static void _clk_esdhc3_recalc(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	clk->rate = clk->parent->rate / (prediv * podf);
+}
+
+static int _clk_sdhc3_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+
+	if (cpu_is_mx53()) {
+		div = clk->parent->rate / rate;
+
+		if ((clk->parent->rate / div) != rate)
+			return -EINVAL;
+
+		__calc_pre_post_dividers(div, &pre, &post);
+
+		/* Set sdhc1 clock divider */
+		reg = __raw_readl(MXC_CCM_CSCDR1) &
+			~(MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK |
+			MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK);
+		reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET;
+		reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET;
+		 __raw_writel(reg, MXC_CCM_CSCDR1);
+
+		clk->rate = rate;
+	}
+	return 0;
+}
+
+
 static struct clk esdhc3_clk[] = {
 	{
 	 .name = "esdhc_clk",
@@ -2722,18 +3032,26 @@ static struct clk esdhc3_clk[] = {
 	 },
 };
 
-
 static int _clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg;
-
-	reg = __raw_readl(MXC_CCM_CSCMR1);
-	if (parent == &esdhc1_clk[0])
-		reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
-	else if (parent == &esdhc2_clk[0])
-		reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
-	else
-		BUG();
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else if (parent == &esdhc2_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else
+			BUG();
+	} else {/*MX53 */
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else if (parent == &esdhc3_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else
+			BUG();
+	}
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -2770,6 +3088,73 @@ static struct clk esdhc4_clk[] = {
 	 },
 };
 
+static struct clk sata_clk = {
+	.name = "sata_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ieee_1588_clk = {
+	.name = "ieee_1588_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGR7_CG3_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mlb_clk = {
+	.name = "mlb_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGR7_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk can1_clk[] = {
+	{
+	.name = "can1_clk",
+	.parent = &pll3_sw_clk,
+	.secondary = &can1_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG11_OFFSET,
+	.disable = _clk_disable,
+	 },
+	{
+	.name = "can1_ipg_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGR6_CG10_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static struct clk can2_clk[] = {
+	{
+	.name = "can2_clk",
+	.parent = &pll3_sw_clk,
+	.secondary = &can2_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG4_OFFSET,
+	.disable = _clk_disable,
+	 },
+	{
+	.name = "can2_ipg_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGR4_CG3_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
 static int _clk_sim_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg, mux;
@@ -3104,30 +3489,39 @@ static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
 
 	reg = __raw_readl(MXC_CCM_CBCMR);
 	reg2 = __raw_readl(MXC_CCM_CBCDR);
-	mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, &ddr_hf_clk);
+	if (cpu_is_mx51()) {
+		clk->parent = &ddr_hf_clk;
+		mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, &ddr_hf_clk);
+	} else {
+		clk->parent = &axi_a_clk;
+		mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, NULL);
+	}
 	if (mux < 4) {
 		reg = (reg & ~MXC_CCM_CBCMR_DDR_CLK_SEL_MASK) |
 		    (mux << MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET);
 		__raw_writel(reg, MXC_CCM_CBCMR);
-		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL);
+		if (cpu_is_mx51())
+			reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL);
 	} else {
 		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL) |
 			(MXC_CCM_CBCDR_DDR_HF_SEL);
 	}
-	__raw_writel(reg2, MXC_CCM_CBCDR);
-	getnstimeofday(&nstimeofday);
-	while (__raw_readl(MXC_CCM_CDHIPR) &
-		MXC_CCM_CDHIPR_DDR_HF_CLK_SEL_BUSY){
-		getnstimeofday(&curtime);
-		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
-			panic("_clk_ddr_set_parent failed\n");
+	if (cpu_is_mx51()) {
+		__raw_writel(reg2, MXC_CCM_CBCDR);
+		getnstimeofday(&nstimeofday);
+		while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_DDR_HF_CLK_SEL_BUSY){
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("_clk_ddr_set_parent failed\n");
+		}
 	}
 	return 0;
 }
 
 static struct clk ddr_clk = {
 	.name = "ddr_clk",
-	.parent = &ddr_hf_clk,
+	.parent = &axi_b_clk,
 	.set_parent = _clk_ddr_set_parent,
 	.flags = RATE_PROPAGATES,
 };
@@ -3172,7 +3566,7 @@ static int _clk_vpu_enable(struct clk *clk)
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
 		clk_set_parent(&vpu_clk[0], &ahb_clk);
 		clk_set_parent(&vpu_clk[1], &ahb_clk);
-	} else {
+	} else if (cpu_is_mx51()) {
 		clk_set_parent(&vpu_clk[0], &axi_a_clk);
 		clk_set_parent(&vpu_clk[1], &axi_a_clk);
 	}
@@ -3186,8 +3580,10 @@ static void _clk_vpu_disable(struct clk *clk)
 	_clk_disable(clk);
 
 	/* Set VPU's parent to be axi_b when its disabled. */
-	clk_set_parent(&vpu_clk[0], &axi_b_clk);
-	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	if (cpu_is_mx51()) {
+		clk_set_parent(&vpu_clk[0], &axi_b_clk);
+		clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	}
 }
 
 static struct clk vpu_clk[] = {
@@ -3214,7 +3610,7 @@ static struct clk vpu_clk[] = {
 	 .name = "vpu_emi_clk",
 	 .parent = &emi_fast_clk,
 #ifdef CONFIG_MXC_VPU_IRAM
-	 .secondary = &emi_intr_clk,
+	 .secondary = &emi_intr_clk[0],
 #endif
 	 }
 };
@@ -3223,7 +3619,7 @@ static int _clk_lpsr_set_parent(struct clk *clk, struct clk *parent)
 {
 	u32 reg, mux;
 	reg = __raw_readl(MXC_CCM_CLPCR);
-	mux = _get_mux(parent, &ckil_clk, &fpm_clk, &fpm_div2_clk, NULL);
+	mux = _get_mux(parent, &ckil_clk, &osc_clk, NULL, NULL);
 	reg = (reg & ~MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK) |
 	    (mux << MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET);
 	__raw_writel(reg, MXC_CCM_CLPCR);
@@ -3424,13 +3820,111 @@ static struct clk gpu2d_clk = {
 	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
 };
 
+static void cko1_recalc(struct clk *clk)
+{
+	unsigned long rate;
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg = reg >> MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	rate = clk->parent->rate;
+	clk->rate = rate / (reg + 1);
+}
+
+static int cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg |= MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static void cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+}
+
+static int cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+
+	div = (clk->parent->rate/rate - 1) & 0x7;
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg |= div << MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static unsigned long cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	div = div < 1 ? 1 : div;
+	div = div > 8 ? 8 : div;
+	return clk->parent->rate / div;
+}
+
+static int cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 sel, reg;
+
+	if (parent == &cpu_clk)
+		sel = 0;
+	else if (parent == &pll1_sw_clk)
+		sel = 1;
+	else if (parent == &pll2_sw_clk)
+		sel = 2;
+	else if (parent == &pll3_sw_clk)
+		sel = 3;
+	else if (parent == &emi_slow_clk)
+		sel = 4;
+	else if (parent == &pll4_sw_clk)
+		sel = 5;
+	else if (parent == &emi_enfc_clk)
+		sel = 6;
+	else if (parent == &ipu_di_clk[0])
+		sel = 8;
+	else if (parent == &ahb_clk)
+		sel = 11;
+	else if (parent == &ipg_clk)
+		sel = 12;
+	else if (parent == &ipg_perclk)
+		sel = 13;
+	else if (parent == &ckil_clk)
+		sel = 14;
+	else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_SEL_MASK;
+	reg |= sel << MXC_CCM_CCOSR_CKOL_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+static struct clk cko1_clk = {
+	.name = "cko1_clk",
+	.recalc = cko1_recalc,
+	.enable = cko1_enable,
+	.disable = cko1_disable,
+	.set_rate = cko1_set_rate,
+	.round_rate = cko1_round_rate,
+	.set_parent = cko1_set_parent,
+};
+
 static struct clk *mxc_clks[] = {
 	&osc_clk,
 	&ckih_clk,
 	&ckih2_clk,
 	&ckil_clk,
-	&fpm_clk,
-	&fpm_div2_clk,
 	&pll1_main_clk,
 	&pll1_sw_clk,
 	&pll2_sw_clk,
@@ -3471,8 +3965,6 @@ static struct clk *mxc_clks[] = {
 	&spba_clk,
 	&i2c_clk[0],
 	&i2c_clk[1],
-	&hsi2c_clk,
-	&hsi2c_serial_clk,
 	&gpt_clk[0],
 	&gpt_clk[1],
 	&gpt_clk[2],
@@ -3505,7 +3997,7 @@ static struct clk *mxc_clks[] = {
 	&usboh3_clk[0],
 	&usboh3_clk[1],
 	&usb_ahb_clk,
-	&usb_phy_clk,
+	&usb_phy_clk[0],
 	&usb_utmi_clk,
 	&usb_clk,
 	&esdhc1_clk[0],
@@ -3517,18 +4009,14 @@ static struct clk *mxc_clks[] = {
 	&esdhc4_clk[0],
 	&esdhc4_clk[1],
 	&esdhc_dep_clks,
-	&sim_clk[0],
-	&sim_clk[1],
 	&emi_slow_clk,
 	&ddr_clk,
 	&emi_enfc_clk,
 	&emi_fast_clk,
-	&emi_intr_clk,
+	&emi_intr_clk[0],
 	&spdif_xtal_clk,
 	&spdif0_clk[0],
 	&spdif0_clk[1],
-	&spdif1_clk[0],
-	&spdif1_clk[1],
 	&arm_axi_clk,
 	&vpu_clk[0],
 	&vpu_clk[1],
@@ -3541,24 +4029,19 @@ static struct clk *mxc_clks[] = {
 	&fec_clk[0],
 	&fec_clk[1],
 	&fec_clk[2],
-	&mipi_hsc1_clk,
-	&mipi_hsc2_clk,
-	&mipi_esc_clk,
-	&mipi_hsp_clk,
 	&sahara_clk[0],
 	&sahara_clk[1],
 	&gpu3d_clk,
 	&garb_clk,
-	&emi_garb_clk,
-	&ddr_hf_clk,
 	&gpu2d_clk,
 	&scc_clk[0],
 	&scc_clk[1],
+	&cko1_clk,
 };
 
 static void clk_tree_init(void)
 {
-	u32 reg, reg2, dp_ctl;
+	u32 reg, dp_ctl;
 
 	ipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);
 
@@ -3575,19 +4058,32 @@ static void clk_tree_init(void)
 
 	/* set pll1_main_clk parent */
 	pll1_main_clk.parent = &osc_clk;
-	dp_ctl = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
-	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
-		pll1_main_clk.parent = &fpm_clk;
+
 	/* set pll2_sw_clk parent */
 	pll2_sw_clk.parent = &osc_clk;
-	dp_ctl = __raw_readl(pll2_base + MXC_PLL_DP_CTL);
-	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
-		pll2_sw_clk.parent = &fpm_clk;
+
 	/* set pll3_clk parent */
 	pll3_sw_clk.parent = &osc_clk;
-	dp_ctl = __raw_readl(pll3_base + MXC_PLL_DP_CTL);
-	if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
-		pll3_sw_clk.parent = &fpm_clk;
+
+	if (cpu_is_mx51()) {
+		dp_ctl = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll1_main_clk.parent = &fpm_clk;
+
+		dp_ctl = __raw_readl(pll2_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll2_sw_clk.parent = &fpm_clk;
+
+		dp_ctl = __raw_readl(pll3_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll3_sw_clk.parent = &fpm_clk;
+	} else {
+		/* set pll4_clk parent */
+		pll4_sw_clk.parent = &osc_clk;
+	}
+
+	if (cpu_is_mx53())
+		tve_clk.parent = &pll4_sw_clk;
 
 	/* set emi_slow_clk parent */
 	emi_slow_clk.parent = &main_bus_clk;
@@ -3604,32 +4100,13 @@ static void clk_tree_init(void)
 		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
 			ipg_perclk.parent = &main_bus_clk;
 	}
-
-	/* set DDR clock parent */
-	reg = __raw_readl(MXC_CCM_CBCMR) & MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
-	reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
-	reg2 = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
-	reg2 >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
-
-	if (reg2) {
-		ddr_clk.parent = &ddr_hf_clk;
-	} else {
-		if (reg == 0) {
-			ddr_clk.parent = &axi_a_clk;
-		} else if (reg == 1) {
-			ddr_clk.parent = &axi_b_clk;
-		} else if (reg == 2) {
-			ddr_clk.parent = &emi_slow_clk;
-		} else {
-			ddr_clk.parent = &ahb_clk;
-		}
-	}
 }
 
+
 int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
 {
 	__iomem void *base;
-	struct clk **clkp;
+	struct clk **clkp, *tclk;
 	int i = 0, j = 0, reg;
 	int wp_cnt = 0;
 
@@ -3680,18 +4157,62 @@ int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	ckih_clk.rate = ckih1;
 	ckih2_clk.rate = ckih2;
 
+	/* Fix up clocks unique to MX51. */
+	esdhc2_clk[0].recalc = _clk_esdhc2_recalc;
+
 	clk_tree_init();
 
 	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
 		clk_register(*clkp);
 
+	clk_register(&fpm_clk);
+	clk_register(&fpm_div2_clk);
+	clk_register(&hsi2c_clk);
+	clk_register(&hsi2c_serial_clk);
+	clk_register(&sim_clk[0]);
+	clk_register(&sim_clk[1]);
+	clk_register(&mipi_hsc1_clk);
+	clk_register(&mipi_hsc2_clk);
+	clk_register(&mipi_esc_clk);
+	clk_register(&mipi_hsp_clk);
+	clk_register(&spdif1_clk[0]);
+	clk_register(&spdif1_clk[1]);
+	clk_register(&ddr_hf_clk);
+	clk_register(&emi_garb_clk);
+
+	/* set DDR clock parent */
+	reg = 0;
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) >= 1) {
+		reg = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+		reg >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+		if (reg)
+			tclk = &ddr_hf_clk;
+	}
+	if (reg == 0) {
+		reg = __raw_readl(MXC_CCM_CBCMR) &
+					MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+		reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+
+		if (reg == 0) {
+			tclk = &axi_a_clk;
+		} else if (reg == 1) {
+			tclk = &axi_b_clk;
+		} else if (reg == 2) {
+			tclk = &emi_slow_clk;
+		} else {
+			tclk = &ahb_clk;
+		}
+	}
+	clk_set_parent(&ddr_clk, tclk);
+
 	/*Setup the LPM bypass bits */
 	reg = __raw_readl(MXC_CCM_CLPCR);
 	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS
 		| MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
 		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
-		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
-		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX51
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
 	__raw_writel(reg, MXC_CCM_CLPCR);
 
 	/* Disable the handshake with HSC block as its not
@@ -3710,13 +4231,7 @@ int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	propagate_rate(&pll2_sw_clk);
 
 	clk_enable(&cpu_clk);
-	reg = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
-	reg >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
 
-	if (reg)
-		clk_set_parent(&ddr_clk, &ddr_hf_clk);
-	else
-		clk_set_parent(&ddr_clk, &axi_a_clk);
 
 	/* Initialise the parents to be axi_b, parents are set to
 	 * axi_a when the clocks are enabled.
@@ -3768,7 +4283,7 @@ int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
 
 	/* move usb_phy_clk to 24MHz */
-	clk_set_parent(&usb_phy_clk, &osc_clk);
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
 
 	/* set usboh3_clk to pll2 */
 	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
@@ -3895,6 +4410,308 @@ int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	return 0;
 }
 
+int __init mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
+{
+	__iomem void *base;
+	struct clk **clkp, *tclk;
+	int i = 0, j = 0, reg;
+	int wp_cnt = 0;
+
+	pll1_base = ioremap(MX53_BASE_ADDR(PLL1_BASE_ADDR), SZ_4K);
+	pll2_base = ioremap(MX53_BASE_ADDR(PLL2_BASE_ADDR), SZ_4K);
+	pll3_base = ioremap(MX53_BASE_ADDR(PLL3_BASE_ADDR), SZ_4K);
+	pll4_base = ioremap(MX53_BASE_ADDR(PLL4_BASE_ADDR), SZ_4K);
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGR0_CG0_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG1_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG2_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG3_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG4_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG8_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG9_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG12_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG13_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGR0_CG0_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG1_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG3_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG8_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG9_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG12_OFFSET |
+			      1 << MXC_CCM_CCGR0_CG13_OFFSET |
+			      3 << MXC_CCM_CCGR0_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(1 << MXC_CCM_CCGR4_CG8_OFFSET, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGR5_CG2_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG6_OFFSET |
+		     3 << MXC_CCM_CCGR5_CG7_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG8_OFFSET |
+		     3 << MXC_CCM_CCGR5_CG9_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG10_OFFSET |
+		     3 << MXC_CCM_CCGR5_CG11_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(3 << MXC_CCM_CCGR6_CG0_OFFSET |
+				3 << MXC_CCM_CCGR6_CG1_OFFSET |
+				3 << MXC_CCM_CCGR6_CG4_OFFSET |
+				3 << MXC_CCM_CCGR6_CG8_OFFSET |
+				3 << MXC_CCM_CCGR6_CG9_OFFSET |
+				3 << MXC_CCM_CCGR6_CG12_OFFSET |
+				3 << MXC_CCM_CCGR6_CG13_OFFSET , MXC_CCM_CCGR6);
+
+	__raw_writel(0, MXC_CCM_CCGR7);
+
+	ckil_clk.rate = ckil;
+	osc_clk.rate = osc;
+	ckih_clk.rate = ckih1;
+	ckih2_clk.rate = ckih2;
+
+	usb_phy_clk[0].enable_reg = MXC_CCM_CCGR4;
+	usb_phy_clk[0].enable_shift = MXC_CCM_CCGR4_CG5_OFFSET;
+
+	ipumux1_clk.enable_reg = MXC_CCM_CCGR5;
+	ipumux1_clk.enable_shift = MXC_CCM_CCGR5_CG6_OFFSET;
+	ipumux2_clk.enable_reg = MXC_CCM_CCGR6;
+	ipumux2_clk.enable_shift = MXC_CCM_CCGR6_CG0_OFFSET;
+
+	esdhc3_clk[0].recalc = _clk_esdhc3_recalc;
+	esdhc3_clk[0].set_rate = _clk_sdhc3_set_rate;
+
+#ifdef CONFIG_MXC_VPU_IRAM
+	 vpu_clk[2].secondary = &emi_intr_clk[1];
+#endif
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+	usboh3_clk[1].secondary = &emi_intr_clk[1];
+#endif
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	ssi2_clk[2].secondary = &emi_intr_clk[1];
+	ssi1_clk[2].secondary = &emi_intr_clk[1];
+#endif
+#ifdef CONFIG_SDMA_IRAM
+	sdma_clk[1].secondary = &emi_intr_clk[1];
+#endif
+
+	clk_tree_init();
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++)
+		clk_register(*clkp);
+
+	clk_register(&pll4_sw_clk);
+	clk_register(&emi_intr_clk[1]);
+	clk_register(&uart4_clk[0]);
+	clk_register(&uart4_clk[1]);
+	clk_register(&uart5_clk[0]);
+	clk_register(&uart5_clk[1]);
+	clk_register(&i2c_clk[2]);
+	clk_register(&usb_phy_clk[1]);
+	clk_register(&ocram_clk);
+	clk_register(&sata_clk);
+	clk_register(&ieee_1588_clk);
+	clk_register(&mlb_clk);
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CBCMR) &
+				MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+	reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+	if (reg == 0) {
+		tclk = &axi_a_clk;
+	} else if (reg == 1) {
+		tclk = &axi_b_clk;
+	} else if (reg == 2) {
+		tclk = &emi_slow_clk;
+	} else {
+		tclk = &ahb_clk;
+	}
+	clk_set_parent(&ddr_clk, tclk);
+
+	clk_set_parent(&esdhc1_clk[2], &tmax2_clk);
+	clk_set_parent(&esdhc2_clk[0], &esdhc1_clk[0]);
+	clk_set_parent(&esdhc3_clk[0], &pll2_sw_clk);
+
+#if 0
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+#endif
+
+	/* Disable the handshake with HSC block as its not
+	  * initialised right now.
+	  */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_EMI_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&osc_clk);
+	propagate_rate(&ckih_clk);
+	propagate_rate(&ckih2_clk);
+	propagate_rate(&ckil_clk);
+	propagate_rate(&pll1_sw_clk);
+	propagate_rate(&pll2_sw_clk);
+	propagate_rate(&pll3_sw_clk);
+
+	clk_enable(&cpu_clk);
+
+	clk_enable(&main_bus_clk);
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+
+	clk_set_parent(&vpu_clk[0], &axi_b_clk);
+	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	clk_set_parent(&gpu3d_clk, &axi_a_clk);
+	clk_set_parent(&gpu2d_clk, &axi_a_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+	/*move the spdif0 to spdif_xtal_ckl */
+	clk_set_parent(&spdif0_clk[0], &spdif_xtal_clk);
+	/*set the SPDIF dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from SSI1_CLK_ROOT */
+	clk_set_parent(&ssi_ext1_clk, &ssi1_clk[0]);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+	clk_set_parent(&usb_phy_clk[1], &osc_clk);
+
+	/* set usboh3_clk to pll2 */
+	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
+	reg |= 4 << MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
+	reg |= 1 << MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	/* set SDHC root clock as 200MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 200000000);
+	clk_set_rate(&esdhc3_clk[0], 200000000);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	if (pll1_main_clk.rate <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (pll1_main_clk.rate <= cpu_wp_tbl[1].cpu_rate &&
+				pll1_main_clk.rate > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = pll1_main_clk.rate;
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+
+	for (j = 0; j < cpu_wp_nr; j++) {
+		if ((ddr_clk.parent == &ddr_hf_clk)) {
+			/* Change the CPU podf divider based on the boot up
+			 * pll1 rate.
+			 */
+			cpu_wp_tbl[j].cpu_podf =
+				(pll1_main_clk.rate / cpu_wp_tbl[j].cpu_rate)
+				- 1;
+			if (pll1_main_clk.rate/(cpu_wp_tbl[j].cpu_podf + 1) >
+					cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_podf++;
+				cpu_wp_tbl[j].cpu_rate =
+					 pll1_main_clk.rate/
+					 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+				cpu_wp_tbl[j].cpu_rate *= 1000;
+			}
+			if (pll1_main_clk.rate/(cpu_wp_tbl[j].cpu_podf + 1) <
+						cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_rate = pll1_main_clk.rate;
+			}
+		}
+	cpu_wp_tbl[j].pll_rate = pll1_main_clk.rate;
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	propagate_rate(&osc_clk);
+	propagate_rate(&pll1_sw_clk);
+	propagate_rate(&pll2_sw_clk);
+	propagate_rate(&pll3_sw_clk);
+
+	clk_set_parent(&arm_axi_clk, &axi_b_clk);
+	clk_set_parent(&ipu_clk[0], &axi_b_clk);
+	clk_set_parent(&uart_main_clk, &pll3_sw_clk);
+	clk_set_parent(&gpu3d_clk, &axi_b_clk);
+	clk_set_parent(&gpu2d_clk, &axi_b_clk);
+
+	clk_set_parent(&emi_slow_clk, &ahb_clk);
+	clk_set_rate(&emi_slow_clk, clk_round_rate(&emi_slow_clk, 130000000));
+
+	/* Change the NFC clock rate to be 1:4 ratio with emi clock. */
+	clk_set_rate(&emi_enfc_clk, clk_round_rate(&emi_enfc_clk,
+			(clk_get_rate(&emi_slow_clk))/4));
+
+	base = ioremap(MX53_BASE_ADDR(GPT1_BASE_ADDR), SZ_4K);
+	mxc_timer_init(&gpt_clk[0], base, MXC_INT_GPT);
+	return 0;
+}
+
 /*!
  * Setup cpu clock based on working point.
  * @param	wp	cpu freq working point
diff --git a/arch/arm/mach-mx5/cpu.c b/arch/arm/mach-mx5/cpu.c
index be1c43d..b487d2d 100644
--- a/arch/arm/mach-mx5/cpu.c
+++ b/arch/arm/mach-mx5/cpu.c
@@ -26,21 +26,13 @@
 #include <linux/iram_alloc.h>
 #include <linux/io.h>
 #include <linux/clk.h>
+#include <mach/common.h>
 #include <mach/hardware.h>
 #include "crm_regs.h"
 
 void __iomem *arm_plat_base;
 void __iomem *gpc_base;
 
-/*!
- * CPU initialization. It is called by fixup_mxc_board()
- */
-void __init mxc_cpu_init(void)
-{
-	if (!system_rev)
-		mxc_set_system_rev(0x51, CHIP_REV_1_0);
-}
-
 static void __init mipi_hsc_disable(void)
 {
 	void __iomem *reg_hsc_mcd = ioremap(MIPI_HSC_BASE_ADDR, SZ_4K);
@@ -76,7 +68,7 @@ void mx51_vpu_reset(void)
 	u32 reg;
 	void __iomem *src_base;
 
-	src_base = ioremap(SRC_BASE_ADDR, PAGE_SIZE);
+	src_base = ioremap(MX53_BASE_ADDR(SRC_BASE_ADDR), PAGE_SIZE);
 
 	/* mask interrupt due to vpu passed reset */
 	reg = __raw_readl(src_base + 0x18);
@@ -98,22 +90,25 @@ static int __init post_cpu_init(void)
 	unsigned int reg;
 	int iram_size = IRAM_SIZE;
 
-	mipi_hsc_disable();
+	if (cpu_is_mx51()) {
+		mipi_hsc_disable();
 
 #if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
-	if (cpu_is_mx51())
 		iram_size -= SCC_RAM_SIZE;
 #endif
-	iram_init(IRAM_BASE_ADDR, iram_size);
+		iram_init(MX51_IRAM_BASE_ADDR, iram_size);
+	} else {
+		iram_init(MX53_IRAM_BASE_ADDR, iram_size);
+	}
 
-	gpc_base = ioremap(GPC_BASE_ADDR, SZ_4K);
+	gpc_base = ioremap(MX53_BASE_ADDR(GPC_BASE_ADDR), SZ_4K);
 
 	/* Set ALP bits to 000. Set ALP_EN bit in Arm Memory Controller reg. */
-	arm_plat_base = ioremap(ARM_BASE_ADDR, SZ_4K);
+	arm_plat_base = ioremap(MX53_BASE_ADDR(ARM_BASE_ADDR), SZ_4K);
 	reg = 0x8;
 	__raw_writel(reg, MXC_CORTEXA8_PLAT_AMC);
 
-	base = ioremap(AIPS1_BASE_ADDR, SZ_4K);
+	base = ioremap(MX53_BASE_ADDR(AIPS1_BASE_ADDR), SZ_4K);
 	__raw_writel(0x0, base + 0x40);
 	__raw_writel(0x0, base + 0x44);
 	__raw_writel(0x0, base + 0x48);
@@ -122,7 +117,7 @@ static int __init post_cpu_init(void)
 	__raw_writel(reg, base + 0x50);
 	iounmap(base);
 
-	base = ioremap(AIPS2_BASE_ADDR, SZ_4K);
+	base = ioremap(MX53_BASE_ADDR(AIPS2_BASE_ADDR), SZ_4K);
 	__raw_writel(0x0, base + 0x40);
 	__raw_writel(0x0, base + 0x44);
 	__raw_writel(0x0, base + 0x48);
@@ -134,7 +129,7 @@ static int __init post_cpu_init(void)
 	/*Allow for automatic gating of the EMI internal clock.
 	 * If this is done, emi_intr CCGR bits should be set to 11.
 	 */
-	base = ioremap(M4IF_BASE_ADDR, SZ_4K);
+	base = ioremap(MX53_BASE_ADDR(M4IF_BASE_ADDR), SZ_4K);
 	reg = __raw_readl(base + 0x8c);
 	reg &= ~0x1;
 	__raw_writel(reg, base + 0x8c);
diff --git a/arch/arm/mach-mx5/crm_regs.h b/arch/arm/mach-mx5/crm_regs.h
index 32b2add..e53f55d 100644
--- a/arch/arm/mach-mx5/crm_regs.h
+++ b/arch/arm/mach-mx5/crm_regs.h
@@ -17,11 +17,13 @@ extern void __iomem *ccm_base;
 extern void __iomem *pll1_base;
 extern void __iomem *pll2_base;
 extern void __iomem *pll3_base;
+extern void __iomem *pll4_base;
 
 #define MXC_CCM_BASE	(IO_ADDRESS(CCM_BASE_ADDR))
 #define MXC_DPLL1_BASE	(pll1_base)
 #define MXC_DPLL2_BASE	(pll2_base)
 #define MXC_DPLL3_BASE	(pll3_base)
+#define MXC_DPLL4_BASE (pll4_base)
 
 /* PLL Register Offsets */
 #define MXC_PLL_DP_CTL			0x00
@@ -112,7 +114,8 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CCGR4		(MXC_CCM_BASE + 0x78)
 #define MXC_CCM_CCGR5		(MXC_CCM_BASE + 0x7C)
 #define MXC_CCM_CCGR6		(MXC_CCM_BASE + 0x80)
-#define MXC_CCM_CMEOR		(MXC_CCM_BASE + 0x84)
+#define MXC_CCM_CCGR7		(MXC_CCM_BASE + 0x84)
+#define MXC_CCM_CMEOR		(MXC_CCM_BASE + 0x88)
 
 /* Define the bits in register CCR */
 #define MXC_CCM_CCR_COSC_EN		(1 << 12)
@@ -124,9 +127,17 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CCR_OSCNT_MASK	(0xFF)
 
 /* Define the bits in register CCDR */
+/* MX51 */
 #define MXC_CCM_CCDR_HSC_HS_MASK	(0x1 << 18)
 #define MXC_CCM_CCDR_IPU_HS_MASK	(0x1 << 17)
 #define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
+/* MX53 */
+#define MXC_CCM_CCDR_IPU_HS_MX53_MASK	(0x1 << 21)
+#define MXC_CCM_CCDR_EMI_HS_INT2_MASK	(0x1 << 20)
+#define MXC_CCM_CCDR_EMI_HS_INT1_MASK	(0x1 << 19)
+#define MXC_CCM_CCDR_EMI_HS_SLOW_MASK	(0x1 << 18)
+#define MXC_CCM_CCDR_EMI_HS_FAST_MASK	(0x1 << 17)
+#define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
 
 /* Define the bits in register CSR */
 #define MXC_CCM_CSR_COSR_READY	(1 << 5)
@@ -134,10 +145,13 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSR_CAMP2_READY	(1 << 3)
 #define MXC_CCM_CSR_CAMP1_READY	(1 << 2)
 #define MXC_CCM_CSR_FPM_READY	(1 << 1)
+#define MXC_CCM_CSR_TEMP_MON_ALARM	(1 << 1)
 #define MXC_CCM_CSR_REF_EN_B		(1 << 0)
 
 /* Define the bits in register CCSR */
 #define MXC_CCM_CCSR_LP_APM_SEL		(0x1 << 9)
+#define MXC_CCM_CCSR_LP_APM_SEL_MX53		(0x1 << 10)
+#define MXC_CCM_CCSR_PLL4_SW_CLK_SEL		(1 << 9)
 #define MXC_CCM_CCSR_STEP_SEL_OFFSET		(7)
 #define MXC_CCM_CCSR_STEP_SEL_MASK		(0x3 << 7)
 #define MXC_CCM_CCSR_PLL2_PODF_OFFSET	(5)
@@ -179,6 +193,8 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CBCDR_PERCLK_PODF_MASK		(0x7)
 
 /* Define the bits in register CBCMR */
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MX53_OFFSET	(16)
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MX53_MASK		(0x3 << 16)
 #define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET	(14)
 #define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK		(0x3 << 14)
 #define MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET		(12)
@@ -207,12 +223,13 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSCMR1_UART_CLK_SEL_MASK			(0x3 << 24)
 #define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET		(22)
 #define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK			(0x3 << 22)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET	(20)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK		(0x3 << 20)
-#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL			(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET	(20)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK		(0x3 << 20)
+#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51		(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC2_CLK_SEL			(0x1 << 19)
 #define MXC_CCM_CSCMR1_ESDHC4_CLK_SEL			(0x1 << 18)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET	(16)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK		(0x3 << 16)
+#define MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET			(14)
 #define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK			(0x3 << 14)
 #define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET			(12)
@@ -237,6 +254,7 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK	(0x3 << 24)
 #define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET	(22)
 #define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK	(0x3 << 22)
+/* MX51 */
 #define MXC_CCM_CSCMR2_ESC_CLK_SEL_OFFSET		(20)
 #define MXC_CCM_CSCMR2_ESC_CLK_SEL_MASK		(0x3 << 20)
 #define MXC_CCM_CSCMR2_HSC2_CLK_SEL_OFFSET		(18)
@@ -245,13 +263,29 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSCMR2_HSC1_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_OFFSET		(14)
 #define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_MASK		(0x3 << 14)
+/* MX53 */
+#define MXC_CCM_CSCMR2_ASRC_CLK_SEL				(1<<21)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET		(19)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK		(0x3 << 19)
+#define MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK		(0x7 << 16)
+#define MXC_CCM_CSCMR2_IEEE_CLK_SEL_OFFSET		(14)
+#define MXC_CCM_CSCMR2_IEEE_CLK_SEL_MASK		(0x3 << 14)
 #define MXC_CCM_CSCMR2_FIRI_CLK_SEL_OFFSET		(12)
 #define MXC_CCM_CSCMR2_FIRI_CLK_SEL_MASK		(0x3 << 12)
+/* MX51 */
 #define MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET		(10)
 #define MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK		(0x3 << 10)
 #define MXC_CCM_CSCMR2_SLIMBUS_COM			(0x1 << 9)
 #define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_OFFSET	(6)
 #define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_MASK		(0x7 << 6)
+/* MX51 */
+#define MXC_CCM_CSCMR2_LBD_DI1_IPU_DIV			(0x1 << 11)
+#define MXC_CCM_CSCMR2_LBD_DI0_IPU_DIV			(0x1 << 10)
+#define MXC_CCM_CSCMR2_LBD_DI1_CLK_SEL			(0x1 << 9)
+#define MXC_CCM_CSCMR2_LBD_DI0_CLK_SEL			(0x1 << 8)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET		(6)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK		(0x3 << 6)
 #define MXC_CCM_CSCMR2_SPDIF1_COM			(1 << 5)
 #define MXC_CCM_CSCMR2_SPDIF0_COM			(1 << 4)
 #define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET	(2)
@@ -264,12 +298,16 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK		(0x7 << 22)
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET	(19)
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK		(0x7 << 19)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET	(16)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET	(19)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK		(0x7 << 16)
 #define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET			(14)
 #define MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK			(0x3 << 14)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET	(11)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK		(0x7 << 11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET	(11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK		(0x7 << 11)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET		(8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK		(0x7 << 8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET		(6)
@@ -280,10 +318,14 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK			(0x7)
 
 /* Define the bits in register CS1CDR and CS2CDR */
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET	(25)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET	(22)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK	(0x7 << 22)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET	(16)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK	(0x3F << 16)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_OFFSET		(9)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK	(0x7 << 9)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		(6)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		(0)
@@ -305,18 +347,23 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK		(0x7 << 25)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET	(19)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x3F << 19)
+/* MX51 */
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET	(16)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK		(0x7 << 16)
+/* MX53 */
+#define MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET		(16)
+#define MXC_CCM_CDCDR_DI_PLL4_PODF_MASK			(0x7 << 16)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET	(9)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK		(0x3F << 9)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET		(6)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CDCDR_DI1_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET		(3)
 #define MXC_CCM_CDCDR_USB_PHY_PRED_MASK		(0x7 << 3)
 #define MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET		(0)
 #define MXC_CCM_CDCDR_USB_PHY_PODF_MASK		(0x7)
 
 /* Define the bits in register CHSCCDR */
+/* MX51 */
 #define MXC_CCM_CHSCCDR_ESC_CLK_PRED_OFFSET		(12)
 #define MXC_CCM_CHSCCDR_ESC_CLK_PRED_MASK		(0x7 << 12)
 #define MXC_CCM_CHSCCDR_ESC_CLK_PODF_OFFSET	(6)
@@ -325,12 +372,24 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_MASK		(0x7 << 3)
 #define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_OFFSET	(0)
 #define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_MASK		(0x7)
+/* MX53 */
+#define MXC_CCM_CHSCCDR_ESAI_HCKT_SEL_OFFSET		(6)
+#define MXC_CCM_CHSCCDR_ESAI_HCKT_SEL_MASK			(0x3 << 6)
+#define MXC_CCM_CHSCCDR_ESAI_HCKR_SEL_OFFSET		(4)
+#define MXC_CCM_CHSCCDR_ESAI_HCKR_SEL_MASK			(0x3 << 4)
+#define MXC_CCM_CHSCCDR_SSI2_MLB_SPDIF_SRC_OFFSET		(2)
+#define MXC_CCM_CHSCCDR_SSI2_MLB_SPDIF_SRC_MASK		(0x3 << 2)
+#define MXC_CCM_CHSCCDR_SSI1_MLB_SPDIF_SRC_OFFSET		(0)
+#define MXC_CCM_CHSCCDR_SSI1_MLB_SPDIF_SRC_MASK		(0x3)
 
 /* Define the bits in register CSCDR2 */
+#define MXC_CCM_CSCDR2_ASRC_CLK_PRED_OFFSET	(28)
+#define MXC_CCM_CSCDR2_ASRC_CLK_PRED_MASK		(0x7 << 28)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET		(25)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK		(0x7 << 25)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET		(19)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK		(0x3F << 19)
+/* MX51 */
 #define MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET		(16)
 #define MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK		(0x7 << 16)
 #define MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET		(9)
@@ -339,6 +398,13 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CSCDR2_SLIMBUS_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CSCDR2_SLIMBUS_PODF_OFFSET		(0)
 #define MXC_CCM_CSCDR2_SLIMBUS_PODF_MASK		(0x3F)
+/* MX53 */
+#define MXC_CCM_CSCDR2_ASRC_CLK_PODF_OFFSET	(9)
+#define MXC_CCM_CSCDR2_ASRC_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PODF_MASK		(0x3F)
 
 /* Define the bits in register CSCDR3 */
 #define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET	(16)
@@ -378,10 +444,21 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK		(0x3)
 
 /* Define the bits in register CLPCR */
+/* MX51 */
 #define MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS		(0x1 << 23)
-#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS		(0x1 << 22)
-#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS		(0x1 << 21)
-#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS		(0x1 << 20)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX51		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51		(0x1 << 20)
+/* MX53 */
+#define MXC_CCM_CLPCR_BYPASS_CAN2_LPM_HS			(0x1 << 27)
+#define MXC_CCM_CLPCR_BYPASS_CAN1_LPM_HS			(0x1 << 27)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX53			(0x1 << 26)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX53			(0x1 << 25)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX53			(0x1 << 24)
+#define MXC_CCM_CLPCR_BYPASS_EMI_INT2_LPM_HS		(0x1 << 23)
+#define MXC_CCM_CLPCR_BYPASS_EMI_INT1_LPM_HS		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_EMI_SLOW_LPM_HS		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_EMI_FAST_LPM_HS		(0x1 << 20)
 #define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS		(0x1 << 19)
 #define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS		(0x1 << 18)
 #define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS		(0x1 << 17)
@@ -399,7 +476,11 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CLPCR_LPM_MASK			(0x3)
 
 /* Define the bits in register CISR */
-#define MXC_CCM_CISR_ARM_PODF_LOADED			(0x1 << 25)
+#define MXC_CCM_CISR_ARM_PODF_LOADED_MX51		(0x1 << 25)
+#define MXC_CCM_CISR_ARM_PODF_LOADED_MX53		(0x1 << 26)
+#define MXC_CCM_CISR_TEMP_MON_ALARM				(0x1 << 25)
+#define MXC_CCM_CISR_EMI_CLK_SEL_LOADED			(0x1 << 23)
+#define MXC_CCM_CISR_PER_CLK_SEL_LOADED			(0x1 << 22)
 #define MXC_CCM_CISR_NFC_IPG_INT_MEM_PODF_LOADED		(0x1 << 21)
 #define MXC_CCM_CISR_AHB_PODF_LOADED			(0x1 << 20)
 #define MXC_CCM_CISR_EMI_PODF_LOADED				(0x1 << 19)
@@ -415,16 +496,28 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CISR_LRF_PLL1					(0x1)
 
 /* Define the bits in register CIMR */
-#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED_MX51		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED_MX51		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED_MX51	(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED_MX53		(0x1 << 26)
+#define MXC_CCM_CIMR_MASK_TEMP_MON_ALARM		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_EMI_CLK_SEL_LOADED		(0x1 << 23)
+#define MXC_CCM_CIMR_MASK_PER_CLK_SEL_LOADED		(0x1 << 22)
 #define MXC_CCM_CIMR_MASK_NFC_IPG_INT_MEM_PODF_LOADED	(0x1 << 21)
-#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED		(0x1 << 20)
-#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED		(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_AHB_PODF_LOADED_MX53		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_EMI_SLOW_PODF_LOADED_MX53		(0x1 << 19)
 #define MXC_CCM_CIMR_MASK_AXI_B_PODF_LOADED		(0x1 << 18)
 #define MXC_CCM_CIMR_MASK_AXI_A_PODF_LOADED		(0x1 << 17)
 #define MXC_CCM_CIMR_MASK_DIVIDER_LOADED		(0x1 << 16)
-#define MXC_CCM_CIMR_MASK_COSC_READY			(0x1 << 5)
+/* MX51 */
+#define MXC_CCM_CIMR_MASK_COSC_READY_MX51			(0x1 << 5)
 #define MXC_CCM_CIMR_MASK_CKIH_READY			(0x1 << 4)
 #define MXC_CCM_CIMR_MASK_FPM_READY			(0x1 << 3)
+/* MX53 */
+#define MXC_CCM_CIMR_MASK_COSC_READY_MX53			(0x1 << 6)
+#define MXC_CCM_CIMR_MASK_CAMP2_READY			(0x1 << 5)
+#define MXC_CCM_CIMR_MASK_CAMP1_READY			(0x1 << 4)
+#define MXC_CCM_CIMR_MASK_LRF_PLL4			(0x1 << 3)
 #define MXC_CCM_CIMR_MASK_LRF_PLL3			(0x1 << 2)
 #define MXC_CCM_CIMR_MASK_LRF_PLL2			(0x1 << 1)
 #define MXC_CCM_CIMR_MASK_LRF_PLL1			(0x1)
@@ -442,6 +535,8 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CCOSR_CKOL_SEL_MASK			(0xF)
 
 /* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_ARM_CLK_INPUT_SEL				(0x1 << 24)
+#define MXC_CCM_CGPR_ARM_ASYNC_REF_EN				(0x1 << 23)
 #define MXC_CCM_CGPR_EFUSE_PROG_SUPPLY_GATE		(0x1 << 4)
 #define MXC_CCM_CGPR_FPM_SEL				(0x1 << 3)
 #define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_OFFSET		(0)
@@ -568,6 +663,8 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CCGR5_CG7_MASK			(0x3 << 14)
 #define MXC_CCM_CCGR5_CG6_1_OFFSET		12
 #define MXC_CCM_CCGR5_CG6_2_OFFSET		13
+#define MXC_CCM_CCGR5_CG6_OFFSET			12
+#define MXC_CCM_CCGR5_CG6_MASK			(0x3 << 12)
 #define MXC_CCM_CCGR5_CG5_OFFSET			10
 #define MXC_CCM_CCGR5_CG4_OFFSET			8
 #define MXC_CCM_CCGR5_CG3_OFFSET			6
@@ -575,6 +672,22 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CCGR5_CG2_MASK			(0x3 << 4)
 #define MXC_CCM_CCGR5_CG1_OFFSET			2
 #define MXC_CCM_CCGR5_CG0_OFFSET			0
+
+#define MXC_CCM_CCGR6_CG15_OFFSET			30
+#define MXC_CCM_CCGR6_CG14_OFFSET			28
+#define MXC_CCM_CCGR6_CG14_MASK			(0x3 << 28)
+#define MXC_CCM_CCGR6_CG13_OFFSET			26
+#define MXC_CCM_CCGR6_CG13_MASK			(0x3 << 26)
+#define MXC_CCM_CCGR6_CG12_OFFSET			24
+#define MXC_CCM_CCGR6_CG12_MASK			(0x3 << 24)
+#define MXC_CCM_CCGR6_CG11_OFFSET			22
+#define MXC_CCM_CCGR6_CG11_MASK			(0x3 << 22)
+#define MXC_CCM_CCGR6_CG10_OFFSET			20
+#define MXC_CCM_CCGR6_CG10_MASK			(0x3 << 20)
+#define MXC_CCM_CCGR6_CG9_OFFSET			18
+#define MXC_CCM_CCGR6_CG9_MASK			(0x3 << 18)
+#define MXC_CCM_CCGR6_CG8_OFFSET			16
+#define MXC_CCM_CCGR6_CG8_MASK			(0x3 << 16)
 #define MXC_CCM_CCGR6_CG7_OFFSET            14
 #define MXC_CCM_CCGR6_CG7_MASK          (0x3 << 14)
 #define MXC_CCM_CCGR6_CG6_OFFSET			12
@@ -585,9 +698,37 @@ extern void __iomem *pll3_base;
 #define MXC_CCM_CCGR6_CG4_MASK			(0x3 << 8)
 #define MXC_CCM_CCGR6_CG3_OFFSET			6
 #define MXC_CCM_CCGR6_CG2_OFFSET			4
+#define MXC_CCM_CCGR6_CG2_MASK			(0x3 << 4)
 #define MXC_CCM_CCGR6_CG1_OFFSET			2
 #define MXC_CCM_CCGR6_CG0_OFFSET			0
 
+#define MXC_CCM_CCGR7_CG15_OFFSET			30
+#define MXC_CCM_CCGR7_CG14_OFFSET			28
+#define MXC_CCM_CCGR7_CG14_MASK			(0x3 << 28)
+#define MXC_CCM_CCGR7_CG13_OFFSET			26
+#define MXC_CCM_CCGR7_CG13_MASK			(0x3 << 26)
+#define MXC_CCM_CCGR7_CG12_OFFSET			24
+#define MXC_CCM_CCGR7_CG12_MASK			(0x3 << 24)
+#define MXC_CCM_CCGR7_CG11_OFFSET			22
+#define MXC_CCM_CCGR7_CG11_MASK			(0x3 << 22)
+#define MXC_CCM_CCGR7_CG10_OFFSET			20
+#define MXC_CCM_CCGR7_CG10_MASK			(0x3 << 20)
+#define MXC_CCM_CCGR7_CG9_OFFSET			18
+#define MXC_CCM_CCGR7_CG9_MASK			(0x3 << 18)
+#define MXC_CCM_CCGR7_CG8_OFFSET			16
+#define MXC_CCM_CCGR7_CG8_MASK			(0x3 << 16)
+#define MXC_CCM_CCGR7_CG7_OFFSET			14
+#define MXC_CCM_CCGR7_CG7_MASK			(0x3 << 14)
+#define MXC_CCM_CCGR7_CG6_OFFSET			12
+#define MXC_CCM_CCGR7_CG6_MASK			(0x3 << 12)
+#define MXC_CCM_CCGR7_CG5_OFFSET			10
+#define MXC_CCM_CCGR7_CG4_OFFSET			8
+#define MXC_CCM_CCGR7_CG3_OFFSET			6
+#define MXC_CCM_CCGR7_CG2_OFFSET			4
+#define MXC_CCM_CCGR7_CG2_MASK			(0x3 << 4)
+#define MXC_CCM_CCGR7_CG1_OFFSET			2
+#define MXC_CCM_CCGR7_CG0_OFFSET			0
+
 #define MXC_GPC_BASE		(IO_ADDRESS(GPC_BASE_ADDR))
 #define MXC_DPTC_LP_BASE	(MXC_GPC_BASE + 0x80)
 #define MXC_DPTC_GP_BASE	(MXC_GPC_BASE + 0x100)
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
index bcf7da7..c83bdd9 100644
--- a/arch/arm/mach-mx5/devices.c
+++ b/arch/arm/mach-mx5/devices.c
@@ -25,7 +25,6 @@
 #include <mach/hardware.h>
 #include <mach/gpio.h>
 #include <mach/sdma.h>
-#include "sdma_script_code.h"
 #include "crm_regs.h"
 
 /* Flag used to indicate when IRAM has been initialized */
@@ -33,68 +32,6 @@ int iram_ready;
 /* Flag used to indicate if dvfs_core is active. */
 int dvfs_core_is_active;
 
-void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
-{
-	/* AP<->BP */
-	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
-	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
-	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
-	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
-
-	/*misc */
-	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
-
-	/* firi */
-	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
-	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
-
-	/* uart */
-	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
-
-	/* UART SH */
-	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
-
-	/* SHP */
-	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
-	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
-	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
-
-	/* ATA */
-	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
-	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
-
-	/* app */
-	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
-	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
-	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
-	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
-
-	/* MSHC */
-	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
-
-	/* spdif */
-	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
-	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
-
-	/* IPU */
-	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
-
-	/* DVFS */
-	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
-
-	/* core */
-	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
-	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
-	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
-}
-
 static struct resource sdma_resources[] = {
 	{
 		.start = SDMA_BASE_ADDR,
@@ -183,14 +120,14 @@ struct platform_device mxc_nandv2_mtd_device = {
 static struct resource imx_nfc_resources[] = {
 	{
 		.flags = IORESOURCE_MEM,
-		.start = NFC_BASE_ADDR_AXI + 0x0000,
-		.end   = NFC_BASE_ADDR_AXI + 0x1200 - 1,
+		.start = MX51_NFC_BASE_ADDR_AXI,
+		.end   = MX51_NFC_BASE_ADDR_AXI + 0x1200 - 1,
 		.name  = IMX_NFC_BUFFERS_ADDR_RES_NAME,
 	},
 	{
 		.flags = IORESOURCE_MEM,
-		.start = NFC_BASE_ADDR_AXI + 0x1E00,
-		.end   = NFC_BASE_ADDR_AXI + 0x1E44 - 1,
+		.start = MX51_NFC_BASE_ADDR_AXI + 0x1E00,
+		.end   = MX51_NFC_BASE_ADDR_AXI + 0x1E44 - 1,
 		.name  = IMX_NFC_PRIMARY_REGS_ADDR_RES_NAME,
 	},
 	{
@@ -276,8 +213,8 @@ struct platform_device mxc_pwm_backlight_device = {
 
 static struct resource ipu_resources[] = {
 	{
-		.start = IPU_CTRL_BASE_ADDR,
-		.end = IPU_CTRL_BASE_ADDR + SZ_512M,
+		.start = MX51_IPU_CTRL_BASE_ADDR,
+		.end = MX51_IPU_CTRL_BASE_ADDR + SZ_512M,
 		.flags = IORESOURCE_MEM,
 	},
 	{
@@ -447,6 +384,18 @@ static struct resource mxci2c2_resources[] = {
 	},
 };
 
+static struct resource mxci2c3_resources[] = {
+	{
+	       .start = I2C3_BASE_ADDR,
+	       .end = I2C3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	{
+	       .start = MXC_INT_I2C3,
+	       .end = MXC_INT_I2C3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
 
 struct platform_device mxci2c_devices[] = {
 	{
@@ -461,6 +410,12 @@ struct platform_device mxci2c_devices[] = {
 		.num_resources = ARRAY_SIZE(mxci2c2_resources),
 		.resource = mxci2c2_resources,
 	},
+	{
+		.name = "mxc_i2c",
+		.id = 2,
+		.num_resources = ARRAY_SIZE(mxci2c3_resources),
+		.resource = mxci2c3_resources,
+	},
 };
 
 static struct resource mxci2c_hs_resources[] = {
@@ -611,10 +566,33 @@ struct mxc_gpio_port mxc_gpio_ports[] = {
 		.irq_high = MXC_INT_GPIO4_HIGH,
 		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
 	},
+	{
+		.chip.label = "gpio-4",
+		.base = IO_ADDRESS(GPIO5_BASE_ADDR),
+		.irq = MXC_INT_GPIO5_LOW,
+		.irq_high = MXC_INT_GPIO5_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 4
+	},
+	{
+		.chip.label = "gpio-5",
+		.base = IO_ADDRESS(GPIO6_BASE_ADDR),
+		.irq = MXC_INT_GPIO6_LOW,
+		.irq_high = MXC_INT_GPIO6_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 5
+	},
+	{
+		.chip.label = "gpio-6",
+		.base = IO_ADDRESS(GPIO7_BASE_ADDR),
+		.irq = MXC_INT_GPIO7_LOW,
+		.irq_high = MXC_INT_GPIO7_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 6
+	},
 };
 
 int __init mxc_register_gpios(void)
 {
+	if (cpu_is_mx51())
+		return mxc_gpio_init(mxc_gpio_ports, 4);
 	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
 }
 
@@ -625,8 +603,8 @@ static struct resource spdif_resources[] = {
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = MXC_INT_SPDIF,
-		.end = MXC_INT_SPDIF,
+		.start = MXC_INT_SPDIF_MX51,
+		.end = MXC_INT_SPDIF_MX51,
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -735,6 +713,22 @@ static struct resource mxcsdhc2_resources[] = {
 	},
 };
 
+static struct resource mxcsdhc3_resources[] = {
+	{
+		.start = MMC_SDHC3_BASE_ADDR,
+		.end = MMC_SDHC3_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_MMC_SDHC3,
+		.end = MXC_INT_MMC_SDHC3,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
 struct platform_device mxcsdhc1_device = {
 	.name = "mxsdhci",
 	.id = 0,
@@ -749,6 +743,13 @@ struct platform_device mxcsdhc2_device = {
 	.resource = mxcsdhc2_resources,
 };
 
+struct platform_device mxcsdhc3_device = {
+	.name = "mxsdhci",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(mxcsdhc3_resources),
+	.resource = mxcsdhc3_resources,
+};
+
 static struct resource pata_fsl_resources[] = {
 	{
 		.start = ATA_BASE_ADDR,
@@ -891,8 +892,8 @@ static struct resource mxc_gpu_resources[] = {
 		.flags = IORESOURCE_IRQ,
 	},
 	{
-		.start = GPU2D_BASE_ADDR,
-		.end = GPU2D_BASE_ADDR + SZ_4K - 1,
+		.start = MX51_GPU2D_BASE_ADDR,
+		.end = MX51_GPU2D_BASE_ADDR + SZ_4K - 1,
 		.name = "gpu_2d_registers",
 		.flags = IORESOURCE_MEM,
 	},
@@ -903,8 +904,8 @@ static struct resource mxc_gpu_resources[] = {
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = GPU_GMEM_BASE_ADDR,
-		.end = GPU_GMEM_BASE_ADDR + SZ_128K - 1,
+		.start = MX51_GPU_GMEM_BASE_ADDR,
+		.end = MX51_GPU_GMEM_BASE_ADDR + SZ_128K - 1,
 		.name = "gpu_graphics_mem",
 		.flags = IORESOURCE_MEM,
 	},
@@ -919,8 +920,8 @@ struct platform_device gpu_device = {
 
 static struct resource mxc_gpu2d_resources[] = {
 	{
-		.start = GPU2D_BASE_ADDR,
-		.end = GPU2D_BASE_ADDR + SZ_4K - 1,
+		.start = MX51_GPU2D_BASE_ADDR,
+		.end = MX51_GPU2D_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
 	},
 	{
@@ -1004,14 +1005,16 @@ static inline void mxc_init_gpu2d(void)
 }
 #endif
 
-void __init mx51_init_irq(void)
+void __init mx5_init_irq(void)
 {
 	unsigned long tzic_addr;
 
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
-		tzic_addr = TZIC_BASE_ADDR_T01;
-	else
-		tzic_addr = TZIC_BASE_ADDR;
+		tzic_addr = MX51_TZIC_BASE_ADDR_T01;
+	else if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		tzic_addr = MX51_TZIC_BASE_ADDR;
+	else /* mx53 */
+		tzic_addr = MX53_TZIC_BASE_ADDR;
 
 	mxc_tzic_init_irq(tzic_addr);
 }
@@ -1036,6 +1039,9 @@ static __init void mxc_init_scc_iram(void)
 	long cur_ns = 0;
 	long start_ns = 0;
 
+	if (!cpu_is_mx51())
+		return;
+
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
 		iram_partitions = 12;
 
@@ -1044,7 +1050,7 @@ static __init void mxc_init_scc_iram(void)
 		printk(KERN_ERR "FAILED TO MAP IRAM REGS\n");
 		return;
 	}
-	scm_ram_base = ioremap((uint32_t) IRAM_BASE_ADDR, IRAM_SIZE);
+	scm_ram_base = ioremap((uint32_t) MX51_IRAM_BASE_ADDR, IRAM_SIZE);
 	if (scm_ram_base == NULL) {
 		printk(KERN_ERR "FAILED TO MAP IRAM\n");
 		return;
@@ -1196,8 +1202,87 @@ static __init void mxc_init_scc_iram(void)
 	iram_ready = 1;
 }
 
+#define MX53_OFFSET 0x20000000
+
 int __init mxc_init_devices(void)
 {
+	if (cpu_is_mx53()) {
+		sdma_resources[0].start -= MX53_OFFSET;
+		sdma_resources[0].end -= MX53_OFFSET;
+		mxc_w1_master_resources[0].start -= MX53_OFFSET;
+		mxc_w1_master_resources[0].end -= MX53_OFFSET;
+		mxc_kpp_resources[0].start -= MX53_OFFSET;
+		mxc_kpp_resources[0].end -= MX53_OFFSET;
+		rtc_resources[0].start -= MX53_OFFSET;
+		rtc_resources[0].end -= MX53_OFFSET;
+		imx_nfc_resources[0].start = MX53_NFC_BASE_ADDR_AXI;
+		imx_nfc_resources[0].end = MX53_NFC_BASE_ADDR_AXI + 0x1200 - 1;
+		imx_nfc_resources[1].start = MX53_NFC_BASE_ADDR_AXI + 0x1E00;
+		imx_nfc_resources[1].end = MX53_NFC_BASE_ADDR_AXI + 0x1E44 - 1;
+		imx_nfc_resources[2].start -= MX53_OFFSET;
+		imx_nfc_resources[2].end -= MX53_OFFSET;
+		wdt_resources[0].start -= MX53_OFFSET;
+		wdt_resources[0].end -= MX53_OFFSET;
+		pwm1_resources[0].start -= MX53_OFFSET;
+		pwm1_resources[0].end -= MX53_OFFSET;
+		pwm2_resources[0].start -= MX53_OFFSET;
+		pwm2_resources[0].end -= MX53_OFFSET;
+		mxc_fec_resources[0].start -= MX53_OFFSET;
+		mxc_fec_resources[0].end -= MX53_OFFSET;
+		mxcspi1_resources[0].start -= MX53_OFFSET;
+		mxcspi1_resources[0].end -= MX53_OFFSET;
+		mxcspi2_resources[0].start -= MX53_OFFSET;
+		mxcspi2_resources[0].end -= MX53_OFFSET;
+		mxcspi3_resources[0].start -= MX53_OFFSET;
+		mxcspi3_resources[0].end -= MX53_OFFSET;
+		mxci2c1_resources[0].start -= MX53_OFFSET;
+		mxci2c1_resources[0].end -= MX53_OFFSET;
+		mxci2c2_resources[0].start -= MX53_OFFSET;
+		mxci2c2_resources[0].end -= MX53_OFFSET;
+		mxci2c3_resources[0].start -= MX53_OFFSET;
+		mxci2c3_resources[0].end -= MX53_OFFSET;
+		ssi1_resources[0].start -= MX53_OFFSET;
+		ssi1_resources[0].end -= MX53_OFFSET;
+		ssi2_resources[0].start -= MX53_OFFSET;
+		ssi2_resources[0].end -= MX53_OFFSET;
+		tve_resources[0].start -= MX53_OFFSET;
+		tve_resources[0].end -= MX53_OFFSET;
+		dvfs_per_resources[0].start -= MX53_OFFSET;
+		dvfs_per_resources[0].end -= MX53_OFFSET;
+		spdif_resources[0].start -= MX53_OFFSET;
+		spdif_resources[0].end -= MX53_OFFSET;
+		spdif_resources[1].start = MXC_INT_SPDIF_MX53;
+		spdif_resources[1].end = MXC_INT_SPDIF_MX53;
+		mxc_m4if_resources[0].start -= MX53_OFFSET;
+		mxc_m4if_resources[0].end -= MX53_OFFSET;
+		mxc_iim_resources[0].start -= MX53_OFFSET;
+		mxc_iim_resources[0].end -= MX53_OFFSET;
+		mxc_sim_resources[0].start -= MX53_OFFSET;
+		mxc_sim_resources[0].end -= MX53_OFFSET;
+		mxcsdhc1_resources[0].start -= MX53_OFFSET;
+		mxcsdhc1_resources[0].end -= MX53_OFFSET;
+		mxcsdhc2_resources[0].start -= MX53_OFFSET;
+		mxcsdhc2_resources[0].end -= MX53_OFFSET;
+		mxcsdhc3_resources[0].start -= MX53_OFFSET;
+		mxcsdhc3_resources[0].end -= MX53_OFFSET;
+		usbotg_resources[0].start -= MX53_OFFSET;
+		usbotg_resources[0].end -= MX53_OFFSET;
+		usbotg_xcvr_resources[0].start -= MX53_OFFSET;
+		usbotg_xcvr_resources[0].end -= MX53_OFFSET;
+		usbh1_resources[0].start -= MX53_OFFSET;
+		usbh1_resources[0].end -= MX53_OFFSET;
+		usbh2_resources[0].start -= MX53_OFFSET;
+		usbh2_resources[0].end -= MX53_OFFSET;
+		mxc_gpu_resources[2].start = MX53_GPU2D_BASE_ADDR;
+		mxc_gpu_resources[2].end = MX53_GPU2D_BASE_ADDR + SZ_4K - 1;
+		mxc_gpu_resources[4].start = MX53_GPU_GMEM_BASE_ADDR;
+		mxc_gpu_resources[4].end = MX53_GPU_GMEM_BASE_ADDR + SZ_256K - 1;
+		mxc_gpu2d_resources[0].start = MX53_GPU2D_BASE_ADDR;
+		mxc_gpu2d_resources[0].end = MX53_GPU2D_BASE_ADDR + SZ_4K - 1;
+		ipu_resources[0].start = MX53_IPU_CTRL_BASE_ADDR;
+		ipu_resources[0].end = MX53_IPU_CTRL_BASE_ADDR + SZ_128M - 1;
+	}
+
 	mxc_init_scc_iram();
 	mxc_init_gpu2d();
 	return 0;
diff --git a/arch/arm/mach-mx5/devices.h b/arch/arm/mach-mx5/devices.h
index 5a60052..52b79f7 100644
--- a/arch/arm/mach-mx5/devices.h
+++ b/arch/arm/mach-mx5/devices.h
@@ -42,12 +42,14 @@ extern struct platform_device mxc_ssi1_device;
 extern struct platform_device mxc_ssi2_device;
 extern struct platform_device mxc_alsa_spdif_device;
 extern struct platform_device mx51_lpmode_device;
+extern struct platform_device mx53_lpmode_device;
 extern struct platform_device busfreq_device;
 extern struct platform_device sdram_autogating_device;
 extern struct platform_device mxc_iim_device;
 extern struct platform_device mxc_sim_device;
 extern struct platform_device mxcsdhc1_device;
 extern struct platform_device mxcsdhc2_device;
+extern struct platform_device mxcsdhc3_device;
 extern struct platform_device pata_fsl_device;
 extern struct platform_device gpu_device;
 extern struct platform_device mxc_fec_device;
diff --git a/arch/arm/mach-mx5/dma.c b/arch/arm/mach-mx5/dma.c
index a27d7e2..b79fab7 100644
--- a/arch/arm/mach-mx5/dma.c
+++ b/arch/arm/mach-mx5/dma.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -16,6 +16,8 @@
 #include <mach/hardware.h>
 
 #include "serial.h"
+#include "sdma_script_code.h"
+#include "sdma_script_code_mx53.h"
 
 #define MXC_MMC_BUFFER_ACCESS     0x20
 #define MXC_SDHC_MMC_WML          64
@@ -27,11 +29,23 @@
 #define MXC_SSI_TXFIFO_WML        0x4
 #define MXC_SSI_RXFIFO_WML        0x6
 #define MXC_SPDIF_TXFIFO_WML      0x8
+#define MXC_SPDIF_RXFIFO_WML      0x8
 #define MXC_SPDIF_TX_REG          0x2C
+#define MXC_SPDIF_RX_REG          0x14
+#define MXC_ASRC_FIFO_WML         0x40
+#define MXC_ASRCA_RX_REG          0x60
+#define MXC_ASRCA_TX_REG          0x64
+#define MXC_ASRCB_RX_REG          0x68
+#define MXC_ASRCB_TX_REG          0x6C
+#define MXC_ASRCC_RX_REG          0x70
+#define MXC_ASRCC_TX_REG          0x74
+#define MXC_ESAI_TX_REG           0x00
+#define MXC_ESAI_RX_REG           0x04
+#define MXC_ESAI_FIFO_WML         0x40
 
 typedef struct mxc_sdma_info_entry_s {
 	mxc_dma_device_t device;
-	mxc_sdma_channel_params_t *chnl_info;
+	void *chnl_info;
 } mxc_sdma_info_entry_t;
 
 static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
@@ -96,7 +110,7 @@ static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
 			.per_address = UART3_BASE_ADDR,
 			.peripheral_type = UART_SP,
 			.transfer_type = per_2_emi,
-			.event_id = DMA_REQ_UART3_RX,
+			.event_id = DMA_REQ_UART3_RX_MX51,
 			.bd_number = 32,
 			.word_size = TRANSFER_8BIT,
 			},
@@ -110,7 +124,7 @@ static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
 			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
 			.peripheral_type = UART_SP,
 			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_UART3_TX,
+			.event_id = DMA_REQ_UART3_TX_MX51,
 			.bd_number = 32,
 			.word_size = TRANSFER_8BIT,
 			},
@@ -118,6 +132,62 @@ static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = UART4_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = UART5_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
 static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
 	.chnl_params = {
 			.watermark_level = MXC_SDHC_MMC_WML,
@@ -561,7 +631,7 @@ static mxc_sdma_channel_params_t mxc_sdma_spdif_16bit_tx_params = {
 			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
 			.peripheral_type = SPDIF,
 			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SPDIF,
+			.event_id = DMA_REQ_SPDIF_MX51,
 			.bd_number = 32,
 			.word_size = TRANSFER_16BIT,
 			},
@@ -575,7 +645,7 @@ static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
 			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
 			.peripheral_type = SPDIF,
 			.transfer_type = emi_2_per,
-			.event_id = DMA_REQ_SPDIF,
+			.event_id = DMA_REQ_SPDIF_MX51,
 			.bd_number = 32,
 			.word_size = TRANSFER_32BIT,
 			},
@@ -583,6 +653,442 @@ static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
 	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
 };
 
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_RXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_RX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SPDIF_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA4,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA5,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA3,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA6,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi1_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI1_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi1_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI1_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi2_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI2_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi2_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI2_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi1_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI1_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi1_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI1_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi2_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI2_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi2_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI2_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_ESAI_TX,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ESAI_FIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_ESAI,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_ESAI_TX,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ESAI_FIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_ESAI,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcc_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_ESAI_TX,
+				       .event_id2 = DMA_REQ_ASRC_DMA6,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ASRC_FIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_ESAI,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = int_2_per,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = int_2_per,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
 static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
 	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
@@ -590,6 +1096,10 @@ static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
 	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
 	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
 	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
 	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
 	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
@@ -623,11 +1133,60 @@ static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
 	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
 	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
 	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_RX, &mxc_sdma_spdif_32bit_rx_params},
+	{MXC_DMA_ASRC_A_RX, &mxc_sdma_asrca_rx_params},
+	{MXC_DMA_ASRC_A_TX, &mxc_sdma_asrca_tx_params},
+	{MXC_DMA_ASRC_B_RX, &mxc_sdma_asrcb_rx_params},
+	{MXC_DMA_ASRC_B_TX, &mxc_sdma_asrcb_tx_params},
+	{MXC_DMA_ASRC_C_RX, &mxc_sdma_asrcc_rx_params},
+	{MXC_DMA_ASRC_C_TX, &mxc_sdma_asrcc_tx_params},
+	{MXC_DMA_ASRCA_SSI1_TX0, &mxc_sdma_asrca_ssi1_tx0_params},
+	{MXC_DMA_ASRCA_SSI1_TX1, &mxc_sdma_asrca_ssi1_tx1_params},
+	{MXC_DMA_ASRCA_SSI2_TX0, &mxc_sdma_asrca_ssi2_tx0_params},
+	{MXC_DMA_ASRCA_SSI2_TX1, &mxc_sdma_asrca_ssi2_tx1_params},
+	{MXC_DMA_ASRCB_SSI1_TX0, &mxc_sdma_asrcb_ssi1_tx0_params},
+	{MXC_DMA_ASRCB_SSI1_TX1, &mxc_sdma_asrcb_ssi1_tx1_params},
+	{MXC_DMA_ASRCB_SSI2_TX0, &mxc_sdma_asrcb_ssi2_tx0_params},
+	{MXC_DMA_ASRCB_SSI2_TX1, &mxc_sdma_asrcb_ssi2_tx1_params},
+	{MXC_DMA_ASRCA_ESAI, &mxc_sdma_asrca_esai_params},
+	{MXC_DMA_ASRCB_ESAI, &mxc_sdma_asrcb_esai_params},
+	{MXC_DMA_ASRCC_ESAI, &mxc_sdma_asrcc_esai_params},
+	{MXC_DMA_ESAI_16BIT_RX, &mxc_sdma_esai_16bit_rx_params},
+	{MXC_DMA_ESAI_16BIT_TX, &mxc_sdma_esai_16bit_tx_params},
+	{MXC_DMA_ESAI_24BIT_RX, &mxc_sdma_esai_24bit_rx_params},
+	{MXC_DMA_ESAI_24BIT_TX, &mxc_sdma_esai_24bit_tx_params},
 };
 
 static int mxc_sdma_info_entrys =
     sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
 
+static int __init dma_fixups(void)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+	dma_channel_ext_params *params;
+
+	if (cpu_is_mx51())
+		return 0;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		params = &(((mxc_sdma_channel_ext_params_t *)p->chnl_info)->chnl_ext_params);
+		params->common.per_address -= 0x20000000;
+		if (params->common.ext)
+			params->per_address2 -= 0x20000000;
+	}
+
+	mxc_sdma_uart2_rx_params.chnl_params.event_id = DMA_REQ_FIRI_RX;
+	mxc_sdma_uart2_tx_params.chnl_params.event_id = DMA_REQ_FIRI_TX;
+	mxc_sdma_uart3_rx_params.chnl_params.event_id = DMA_REQ_UART3_RX_MX53;
+	mxc_sdma_uart3_tx_params.chnl_params.event_id = DMA_REQ_UART3_TX_MX53;
+	mxc_sdma_spdif_16bit_tx_params.chnl_params.event_id = DMA_REQ_SPDIF_TX;
+	mxc_sdma_spdif_32bit_tx_params.chnl_params.event_id = DMA_REQ_SPDIF_TX;
+
+	return 0;
+}
+arch_initcall(dma_fixups);
+
 /*!
  * This functions Returns the SDMA paramaters associated for a module
  *
@@ -647,6 +1206,7 @@ mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
 
 /*!
  * This functions marks the SDMA channels that are statically allocated
@@ -661,6 +1221,139 @@ void mxc_get_static_channels(mxc_dma_channel_t *chnl)
 		chnl[i].dynamic = 0;
 #endif
 }
-
-EXPORT_SYMBOL(mxc_sdma_get_channel_params);
 EXPORT_SYMBOL(mxc_get_static_channels);
+
+static void __init mx51_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	/* ATA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+}
+
+static void __init mx53_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = firi_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = mcu_2_firi_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR_MX53;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_MX53;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR_MX53;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = mcu_2_shp_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_MX53;
+
+	/* ATA use it's own DMA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = -1;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = -1;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = mcu_2_app_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_MX53;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = spdif_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR_MX53;
+
+	sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = asrc__mcu_ADDR_MX53;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = mcu_2_app_ADDR_MX53;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_MX53;
+}
+
+void __init mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	if (cpu_is_mx51())
+		mx51_sdma_get_script_info(sdma_script_addr);
+	else
+		mx53_sdma_get_script_info(sdma_script_addr);
+}
+
diff --git a/arch/arm/mach-mx5/iomux.c b/arch/arm/mach-mx5/iomux.c
index 3af8133..2d01d8b 100644
--- a/arch/arm/mach-mx5/iomux.c
+++ b/arch/arm/mach-mx5/iomux.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,15 +12,15 @@
  */
 
 /*!
- * @defgroup GPIO_MX51 Board GPIO and Muxing Setup
- * @ingroup MSL_MX51
+ * @defgroup GPIO_MX5 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX5
  */
 /*!
- * @file mach-mx51/iomux.c
+ * @file mach-mx5/iomux.c
  *
  * @brief I/O Muxing control functions
  *
- * @ingroup GPIO_MX51
+ * @ingroup GPIO_MX5
  */
 
 #include <linux/io.h>
@@ -30,22 +30,32 @@
 #include <mach/gpio.h>
 #include <mach/irqs.h>
 #include "iomux.h"
+#include "mx51_pins.h"
+
+#define MUX_I_START_MX53	0x0020
+#define PAD_I_START_MX53	0x348
+#define INPUT_CTL_START_MX53	0x730
+#define MUX_I_END_MX53		(PAD_I_START_MX53 - 4)
 
 /*!
- * IOMUX register (base) addresses
+ * IOMUX register (base) addressesf
  */
 #define IOMUXGPR0		(IO_ADDRESS(IOMUXC_BASE_ADDR))
 #define IOMUXGPR1		(IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x004)
 #define IOMUXSW_MUX_CTL		(IO_ADDRESS(IOMUXC_BASE_ADDR))
-#define IOMUXSW_MUX_END		(IO_ADDRESS(IOMUXC_BASE_ADDR) + MUX_I_END)
-#define IOMUXSW_PAD_CTL		(IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START)
 #define IOMUXSW_INPUT_CTL	(IO_ADDRESS(IOMUXC_BASE_ADDR))
 
-#define MUX_PIN_NUM_MAX        ((MUX_I_END >> 2) + 1)
-
-static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+static u8 iomux_pin_res_table[(0x3F0 / 4) + 1];
 static DEFINE_SPINLOCK(gpio_mux_lock);
 
+static inline void *_get_sw_pad(void)
+{
+	if (cpu_is_mx51())
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX51;
+	else
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX53;
+}
+
 static inline void * _get_mux_reg(iomux_pin_name_t pin)
 {
 	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
@@ -66,26 +76,28 @@ static inline void * _get_mux_reg(iomux_pin_name_t pin)
 static inline void * _get_pad_reg(iomux_pin_name_t pin)
 {
 	u32 pad_reg = PIN_TO_IOMUX_PAD(pin);
+	void __iomem *sw_pad_reg = _get_sw_pad();
+
 
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
 		if ((pin == MX51_PIN_NANDF_RB5) ||
 			(pin == MX51_PIN_NANDF_RB6) ||
 			(pin == MX51_PIN_NANDF_RB7))
 			; /* Do nothing */
-		else if (pad_reg == 0x4D0 - PAD_I_START)
+		else if (pad_reg == 0x4D0 - PAD_I_START_MX51)
 			pad_reg += 0x4C;
-		else if (pad_reg == 0x860 - PAD_I_START)
+		else if (pad_reg == 0x860 - PAD_I_START_MX51)
 			pad_reg += 0x9C;
-		else if (pad_reg >= 0x804 - PAD_I_START)
+		else if (pad_reg >= 0x804 - PAD_I_START_MX51)
 			pad_reg += 0xB0;
-		else if (pad_reg >= 0x7FC - PAD_I_START)
+		else if (pad_reg >= 0x7FC - PAD_I_START_MX51)
 			pad_reg += 0xB4;
-		else if (pad_reg >= 0x4E4 - PAD_I_START)
+		else if (pad_reg >= 0x4E4 - PAD_I_START_MX51)
 			pad_reg += 0xCC;
 		else
 			pad_reg += 8;
 	}
-	return IOMUXSW_PAD_CTL + pad_reg;
+	return sw_pad_reg + pad_reg;
 }
 
 static inline void * _get_mux_end(void)
@@ -193,8 +205,9 @@ EXPORT_SYMBOL(mxc_free_iomux);
 void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
 {
 	void __iomem *pad_reg = _get_pad_reg(pin);
+	void __iomem *sw_pad_reg = _get_sw_pad();
 
-	BUG_ON(pad_reg < IOMUXSW_PAD_CTL);
+	BUG_ON(pad_reg < sw_pad_reg);
 	__raw_writel(config, pad_reg);
 }
 EXPORT_SYMBOL(mxc_iomux_set_pad);
@@ -233,10 +246,11 @@ void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
 		else if (input >= MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT)
 			input -= 1;
 
-		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_TO1;
-	} else {
-		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START;
-	}
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX51_TO1;
+	} else if (cpu_is_mx51()) {
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX51;
+	} else
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX53;
 
 	BUG_ON(input >= MUX_INPUT_NUM_MUX);
 	__raw_writel(config, reg);
diff --git a/arch/arm/mach-mx5/iomux.h b/arch/arm/mach-mx5/iomux.h
index e314ab2..0732f21 100644
--- a/arch/arm/mach-mx5/iomux.h
+++ b/arch/arm/mach-mx5/iomux.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -10,22 +10,80 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
-#ifndef __MACH_MX51_IOMUX_H__
-#define __MACH_MX51_IOMUX_H__
+#ifndef __MACH_MX5_IOMUX_H__
+#define __MACH_MX5_IOMUX_H__
 
 #include <linux/types.h>
 #include <mach/gpio.h>
-#include "mx51_pins.h"
 
 /*!
- * @file mach-mx51/iomux.h
+ * @file mach-mx5/iomux.h
  *
  * @brief I/O Muxing control definitions and functions
  *
- * @ingroup GPIO_MX51
+ * @ingroup GPIO_MX5
  */
 
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |  23 - 21 | 20  - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I  | GPIO_I | PAD_I  | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 9 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX51_PIN_ETM_D0 is defined in the enumeration:
+ *    ( (0x28 - MUX_I_START) << MUX_I)|( (0x250 - PAD_I_START) << PAD_I)
+ * It means the mux control register is at register offset 0x28. The pad control
+ * register offset is: 0x250 and also occupy the least significant bits
+ * within the register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I			0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I			10
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent which
+ * mux mode is for GPIO (0-based)
+ */
+#define GPIO_I			21
+
+#define NON_GPIO_PORT		0x7
+#define PIN_TO_MUX_MASK		((1 << (PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK		((1 << (GPIO_I - PAD_I)) - 1)
+#define PIN_TO_ALT_GPIO_MASK		((1 << (MUX_IO_I - GPIO_I)) - 1)
+
+#define NON_MUX_I		PIN_TO_MUX_MASK
+#define NON_PAD_I		PIN_TO_PAD_MASK
+
+#define PIN_TO_IOMUX_MUX(pin)	((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin)	((pin >> PAD_I) & PIN_TO_PAD_MASK)
+#define PIN_TO_ALT_GPIO(pin)	((pin >> GPIO_I) & PIN_TO_ALT_GPIO_MASK)
+#define PIN_TO_IOMUX_INDEX(pin)	(PIN_TO_IOMUX_MUX(pin) >> 2)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
 typedef unsigned int iomux_pin_name_t;
+typedef unsigned int iomux_input_select_t;
 
 /*!
  * various IOMUX output functions
@@ -56,7 +114,9 @@ typedef enum iomux_pad_config {
 	PAD_CTL_ODE_OPENDRAIN_NONE = 0x0 << 3,
 	PAD_CTL_ODE_OPENDRAIN_ENABLE = 0x1 << 3,
 	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_360K_PD = 0x0 << 4,
 	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_75k_PU = 0x1 << 4,
 	PAD_CTL_100K_PU = 0x2 << 4,
 	PAD_CTL_22K_PU = 0x3 << 4,
 	PAD_CTL_PUE_KEEPER = 0x0 << 6,
@@ -72,110 +132,6 @@ typedef enum iomux_pad_config {
 } iomux_pad_config_t;
 
 /*!
- * various IOMUX input select register index
- */
-typedef enum iomux_input_select {
-	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
-	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
-	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P5_INPUT_RXFS_AMX_SELECT,
-	MUX_IN_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT,
-	MUX_IN_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT,
-	MUX_IN_CCM_IPP_DI_CLK_SELECT_INPUT,
-	/* TO2 */
-	MUX_IN_CCM_IPP_DI1_CLK_SELECT_INPUT,
-	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
-	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
-	MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT,
-	MUX_IN_CSPI_IPP_IND_MISO_SELECT_INPUT,
-	MUX_IN_CSPI_IPP_IND_MOSI_SELECT_INPUT,
-	MUX_IN_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
-	MUX_IN_CSPI_IPP_IND_SS_B_2_SELECT_INPUT,
-	MUX_IN_CSPI_IPP_IND_SS_B_3_SELECT_INPUT,
-	MUX_IN_DPLLIP1_L1T_TOG_EN_SELECT_INPUT,
-	/* TO2 */
-	MUX_IN_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT,
-	MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT,
-	MUX_IN_EMI_IPP_IND_RDY_INT_SELECT_INPUT,
-	MUX_IN_ESDHC3_IPP_DAT0_IN_SELECT_INPUT,
-	MUX_IN_ESDHC3_IPP_DAT1_IN_SELECT_INPUT,
-	MUX_IN_ESDHC3_IPP_DAT2_IN_SELECT_INPUT,
-	MUX_IN_ESDHC3_IPP_DAT3_IN_SELECT_INPUT,
-	MUX_IN_FEC_FEC_COL_SELECT_INPUT,
-	MUX_IN_FEC_FEC_CRS_SELECT_INPUT,
-	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RDATA_2_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RDATA_3_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
-	MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
-	MUX_IN_FEC_FEC_TX_CLK_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_1_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_2_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_3_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_4_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_6_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_7_SELECT_INPUT,
-	MUX_IN_GPIO3_IPP_IND_G_IN_8_SELECT_INPUT,
-	/* TO2 */
-	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
-	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT,
-	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
-	/* TO2 */
-	MUX_IN_HSC_MIPI_MIX_PAR_VSYNC_SELECT_INPUT,
-	/* TO2 */
-	MUX_IN_HSC_MIPI_MIX_PAR_DI_WAIT_SELECT_INPUT,
-	MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT,
-	MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
-	MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
-	MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
-	MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
-
-	MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT,
-
-	MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT,
-
-	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
-	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
-	MUX_IN_KPP_IPP_IND_ROW_4_SELECT_INPUT,
-	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
-	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
-	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
-	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
-	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
-	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
-	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
-	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
-	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_CLK_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_0_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_1_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_2_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_3_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_4_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_5_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_6_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DATA_7_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_DIR_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_NXT_SELECT_INPUT,
-	MUX_IN_USBOH3_IPP_IND_UH3_STP_SELECT_INPUT,
-	MUX_INPUT_NUM_MUX,
-} iomux_input_select_t;
-
-/*!
  * various IOMUX input functions
  */
 typedef enum iomux_input_config {
@@ -243,4 +199,4 @@ unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin);
  */
 void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
 
-#endif				/*  __MACH_MX51_IOMUX_H__ */
+#endif				/*  __MACH_MX5_IOMUX_H__ */
diff --git a/arch/arm/mach-mx5/mm.c b/arch/arm/mach-mx5/mm.c
index 39222b8..810cb1b 100644
--- a/arch/arm/mach-mx5/mm.c
+++ b/arch/arm/mach-mx5/mm.c
@@ -28,7 +28,7 @@
 /*!
  * This structure defines the MX51 memory map.
  */
-static struct map_desc mx51_io_desc[] __initdata = {
+static struct map_desc mx5_io_desc[] __initdata = {
 	{
 	 .virtual = AIPS1_BASE_ADDR_VIRT,
 	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
@@ -44,11 +44,6 @@ static struct map_desc mx51_io_desc[] __initdata = {
 	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
 	 .length = AIPS2_SIZE,
 	 .type = MT_DEVICE},
-	{
-	 .virtual = NFC_BASE_ADDR_AXI_VIRT,
-	 .pfn = __phys_to_pfn(NFC_BASE_ADDR_AXI),
-	 .length = NFC_AXI_SIZE,
-	 .type = MT_DEVICE},
 };
 
 /*!
@@ -56,7 +51,15 @@ static struct map_desc mx51_io_desc[] __initdata = {
  * system startup to create static physical to virtual memory map for
  * the IO modules.
  */
-void __init mx51_map_io(void)
+void __init mx5_map_io(void)
 {
-	iotable_init(mx51_io_desc, ARRAY_SIZE(mx51_io_desc));
+	int i;
+
+	/* Fixup the mappings for MX53 */
+	if (cpu_is_mx53()) {
+		for (i = 0; i < ARRAY_SIZE(mx5_io_desc); i++)
+			mx5_io_desc[i].pfn -= __phys_to_pfn(0x20000000);
+	}
+
+	iotable_init(mx5_io_desc, ARRAY_SIZE(mx5_io_desc));
 }
diff --git a/arch/arm/mach-mx5/mx51_3stack.c b/arch/arm/mach-mx5/mx51_3stack.c
index 995cd36..7e992c5 100644
--- a/arch/arm/mach-mx5/mx51_3stack.c
+++ b/arch/arm/mach-mx5/mx51_3stack.c
@@ -49,6 +49,7 @@
 #include "devices.h"
 #include "board-mx51_3stack.h"
 #include "iomux.h"
+#include "mx51_pins.h"
 #include "crm_regs.h"
 #include "usb.h"
 
@@ -836,7 +837,7 @@ EXPORT_SYMBOL(get_unifi_plat_data);
 static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
 				   char **cmdline, struct meminfo *mi)
 {
-	mxc_cpu_init();
+	mxc_set_cpu_type(MXC_CPU_MX51);
 
 	get_cpu_wp = mx51_3stack_get_cpu_wp;
 	set_num_cpu_wp = mx51_3stack_set_num_cpu_wp;
@@ -991,10 +992,9 @@ MACHINE_START(MX51_3DS, "Freescale MX51 3-Stack Board")
 	/* Maintainer: Freescale Semiconductor, Inc. */
 	.phys_io = AIPS1_BASE_ADDR,
 	.io_pg_offst = ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
-	.boot_params = PHYS_OFFSET + 0x100,
 	.fixup = fixup_mxc_board,
-	.map_io = mx51_map_io,
-	.init_irq = mx51_init_irq,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
 	.init_machine = mxc_board_init,
 	.timer = &mxc_timer,
 MACHINE_END
diff --git a/arch/arm/mach-mx5/mx51_3stack_gpio.c b/arch/arm/mach-mx5/mx51_3stack_gpio.c
index dd08add..b0fca77 100644
--- a/arch/arm/mach-mx5/mx51_3stack_gpio.c
+++ b/arch/arm/mach-mx5/mx51_3stack_gpio.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,9 +21,10 @@
 #include <mach/gpio.h>
 
 #include "iomux.h"
+#include "mx51_pins.h"
 
 /*!
- * @file mach-mx51/mx51_3stack_gpio.c
+ * @file mach-mx5/mx51_3stack_gpio.c
  *
  * @brief This file contains all the GPIO setup functions for the board.
  *
diff --git a/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c b/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
index 7b4cd31..6206b62 100644
--- a/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
+++ b/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
@@ -24,6 +24,7 @@
 #include <linux/mfd/mc13892/core.h>
 #include <mach/irqs.h>
 #include "iomux.h"
+#include "mx51_pins.h"
 
 /*
  * Convenience conversion.
diff --git a/arch/arm/mach-mx5/mx51_babbage.c b/arch/arm/mach-mx5/mx51_babbage.c
index ab7dd28..e346c2e 100644
--- a/arch/arm/mach-mx5/mx51_babbage.c
+++ b/arch/arm/mach-mx5/mx51_babbage.c
@@ -47,6 +47,7 @@
 #include "devices.h"
 #include "board-mx51_babbage.h"
 #include "iomux.h"
+#include "mx51_pins.h"
 #include "crm_regs.h"
 #include "usb.h"
 
@@ -798,7 +799,7 @@ static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
 	int size = SZ_512M - SZ_32M;
 	struct tag *t;
 
-	mxc_cpu_init();
+	mxc_set_cpu_type(MXC_CPU_MX51);
 
 	get_cpu_wp = mx51_babbage_get_cpu_wp;
 	set_num_cpu_wp = mx51_babbage_set_num_cpu_wp;
@@ -984,10 +985,9 @@ static struct sys_timer mxc_timer = {
 /* *INDENT-OFF* */
 MACHINE_START(MX51_BABBAGE, "Freescale MX51 Babbage Board")
 	/* Maintainer: Freescale Semiconductor, Inc. */
-	.boot_params = PHYS_OFFSET + 0x100,
 	.fixup = fixup_mxc_board,
-	.map_io = mx51_map_io,
-	.init_irq = mx51_init_irq,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
 	.init_machine = mxc_board_init,
 	.timer = &mxc_timer,
 MACHINE_END
diff --git a/arch/arm/mach-mx5/mx51_babbage_gpio.c b/arch/arm/mach-mx5/mx51_babbage_gpio.c
index 58324ef..4b3e2ee 100644
--- a/arch/arm/mach-mx5/mx51_babbage_gpio.c
+++ b/arch/arm/mach-mx5/mx51_babbage_gpio.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -19,9 +19,9 @@
 #include <mach/gpio.h>
 
 #include "iomux.h"
-
+#include "mx51_pins.h"
 /*!
- * @file mach-mx51/mx51_babbage_gpio.c
+ * @file mach-mx5/mx51_babbage_gpio.c
  *
  * @brief This file contains all the GPIO setup functions for the board.
  *
diff --git a/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c b/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c
index 5f703fb..cb442e4 100644
--- a/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c
+++ b/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c
@@ -24,6 +24,7 @@
 #include <linux/mfd/mc13892/core.h>
 #include <mach/irqs.h>
 #include "iomux.h"
+#include "mx51_pins.h"
 
 /*
  * Convenience conversion.
diff --git a/arch/arm/mach-mx5/mx51_pins.h b/arch/arm/mach-mx5/mx51_pins.h
index c0905a0..351cdb2 100644
--- a/arch/arm/mach-mx5/mx51_pins.h
+++ b/arch/arm/mach-mx5/mx51_pins.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,6 +12,7 @@
  */
 #ifndef __ASM_ARCH_MXC_MX51_PINS_H__
 #define __ASM_ARCH_MXC_MX51_PINS_H__
+#include "iomux.h"
 
 /*!
  * @file arch-mxc/mx51_pins.h
@@ -23,338 +24,385 @@
 
 #ifndef __ASSEMBLY__
 
-/*!
- * @name IOMUX/PAD Bit field definitions
- */
-
-/*! @{ */
-
-/*!
- * In order to identify pins more effectively, each mux-controlled pin's
- * enumerated value is constructed in the following way:
- *
- * -------------------------------------------------------------------
- * 31-29 | 28 - 24 |  23 - 21 | 20  - 10| 9 - 0
- * -------------------------------------------------------------------
- * IO_P  |  IO_I  | GPIO_I | PAD_I  | MUX_I
- * -------------------------------------------------------------------
- *
- * Bit 0 to 9 contains MUX_I used to identify the register
- * offset (0-based. base is IOMUX_module_base) defined in the Section
- * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
- * similar field definitions are used for the pad control register.
- * For example, the MX51_PIN_ETM_D0 is defined in the enumeration:
- *    ( (0x28 - MUX_I_START) << MUX_I)|( (0x250 - PAD_I_START) << PAD_I)
- * It means the mux control register is at register offset 0x28. The pad control
- * register offset is: 0x250 and also occupy the least significant bits
- * within the register.
- */
-
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent the
- * MUX control register offset
- */
-#define MUX_I			0
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent the
- * PAD control register offset
- */
-#define PAD_I			10
-/*!
- * Starting bit position within each entry of \b iomux_pins to represent which
- * mux mode is for GPIO (0-based)
- */
-#define GPIO_I			21
+#define PAD_I_START_MX51		0x3F0
+#define INPUT_CTL_START_MX51		0x8C4
+#define INPUT_CTL_START_MX51_TO1	0x928
 
-#define NON_GPIO_PORT		0x7
-#define PIN_TO_MUX_MASK		((1 << (PAD_I - MUX_I)) - 1)
-#define PIN_TO_PAD_MASK		((1 << (GPIO_I - PAD_I)) - 1)
-#define PIN_TO_ALT_GPIO_MASK		((1 << (MUX_IO_I - GPIO_I)) - 1)
+#define MUX_I_END_MX51		(PAD_I_START_MX51 - 4)
 
-#define NON_MUX_I		PIN_TO_MUX_MASK
-#define MUX_I_START		0x001C
-#define PAD_I_START		0x3F0
-#define INPUT_CTL_START		0x8C4
-#define INPUT_CTL_START_TO1	0x928
-#define MUX_I_END		(PAD_I_START - 4)
-
-#define _MXC_BUILD_PIN(gp, gi, ga, mi, pi) \
+#define _MXC_BUILD_PIN_MX51(gp, gi, ga, mi, pi) \
 	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
 	((mi) << MUX_I) | \
-	((pi - PAD_I_START) << PAD_I) | \
+	((pi - PAD_I_START_MX51) << PAD_I) | \
 	((ga) << GPIO_I))
 
-#define _MXC_BUILD_GPIO_PIN(gp, gi, ga, mi, pi) \
-    _MXC_BUILD_PIN(gp, gi, ga, mi, pi)
-
-#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
-    _MXC_BUILD_PIN(NON_GPIO_PORT, 0, 0, mi, pi)
-
-#define PIN_TO_IOMUX_MUX(pin)	((pin >> MUX_I) & PIN_TO_MUX_MASK)
-#define PIN_TO_IOMUX_PAD(pin)	((pin >> PAD_I) & PIN_TO_PAD_MASK)
-#define PIN_TO_ALT_GPIO(pin)	((pin >> GPIO_I) & PIN_TO_ALT_GPIO_MASK)
-#define PIN_TO_IOMUX_INDEX(pin)	(PIN_TO_IOMUX_MUX(pin) >> 2)
-
-/*! @} End IOMUX/PAD Bit field definitions */
+#define _MXC_BUILD_GPIO_PIN_MX51(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN_MX51(gp, gi, ga, mi, pi)
 
+#define _MXC_BUILD_NON_GPIO_PIN_MX51(mi, pi) \
+    _MXC_BUILD_PIN_MX51(NON_GPIO_PORT, 0, 0, mi, pi)
 /*!
  * This enumeration is constructed based on the Section
  * "sw_pad_ctl & sw_mux_ctl details" of the MX51 IC Spec. Each enumerated
  * value is constructed based on the rules described above.
  */
-enum iomux_pins {
-	MX51_PIN_EIM_DA0 = _MXC_BUILD_NON_GPIO_PIN(0x1C, 0x7A8),
-	MX51_PIN_EIM_DA1 = _MXC_BUILD_NON_GPIO_PIN(0x20, 0x7A8),
-	MX51_PIN_EIM_DA2 = _MXC_BUILD_NON_GPIO_PIN(0x24, 0x7A8),
-	MX51_PIN_EIM_DA3 = _MXC_BUILD_NON_GPIO_PIN(0x28, 0x7A8),
-	MX51_PIN_EIM_DA4 = _MXC_BUILD_NON_GPIO_PIN(0x2C, 0x7AC),
-	MX51_PIN_EIM_DA5 = _MXC_BUILD_NON_GPIO_PIN(0x30, 0x7AC),
-	MX51_PIN_EIM_DA6 = _MXC_BUILD_NON_GPIO_PIN(0x34, 0x7AC),
-	MX51_PIN_EIM_DA7 = _MXC_BUILD_NON_GPIO_PIN(0x38, 0x7AC),
-	MX51_PIN_EIM_DA8 = _MXC_BUILD_NON_GPIO_PIN(0x3C, 0x7B0),
-	MX51_PIN_EIM_DA9 = _MXC_BUILD_NON_GPIO_PIN(0x40, 0x7B0),
-	MX51_PIN_EIM_DA10 = _MXC_BUILD_NON_GPIO_PIN(0x44, 0x7B0),
-	MX51_PIN_EIM_DA11 = _MXC_BUILD_NON_GPIO_PIN(0x48, 0x7B0),
-	MX51_PIN_EIM_DA12 = _MXC_BUILD_NON_GPIO_PIN(0x4C, 0x7BC),
-	MX51_PIN_EIM_DA13 = _MXC_BUILD_NON_GPIO_PIN(0x50, 0x7BC),
-	MX51_PIN_EIM_DA14 = _MXC_BUILD_NON_GPIO_PIN(0x54, 0x7BC),
-	MX51_PIN_EIM_DA15 = _MXC_BUILD_NON_GPIO_PIN(0x58, 0x7BC),
-	MX51_PIN_EIM_D16 = _MXC_BUILD_GPIO_PIN(1, 0, 1, 0x5C, 0x3F0),
-	MX51_PIN_EIM_D17 = _MXC_BUILD_GPIO_PIN(1, 1, 1, 0x60, 0x3F4),
-	MX51_PIN_EIM_D18 = _MXC_BUILD_GPIO_PIN(1, 2, 1, 0x64, 0x3F8),
-	MX51_PIN_EIM_D19 = _MXC_BUILD_GPIO_PIN(1, 3, 1, 0x68, 0x3FC),
-	MX51_PIN_EIM_D20 = _MXC_BUILD_GPIO_PIN(1, 4, 1, 0x6C, 0x400),
-	MX51_PIN_EIM_D21 = _MXC_BUILD_GPIO_PIN(1, 5, 1, 0x70, 0x404),
-	MX51_PIN_EIM_D22 = _MXC_BUILD_GPIO_PIN(1, 6, 1, 0x74, 0x408),
-	MX51_PIN_EIM_D23 = _MXC_BUILD_GPIO_PIN(1, 7, 1, 0x78, 0x40C),
-	MX51_PIN_EIM_D24 = _MXC_BUILD_GPIO_PIN(1, 8, 1, 0x7C, 0x410),
-	MX51_PIN_EIM_D25 = _MXC_BUILD_NON_GPIO_PIN(0x80, 0x414),
-	MX51_PIN_EIM_D26 = _MXC_BUILD_NON_GPIO_PIN(0x84, 0x418),
-	MX51_PIN_EIM_D27 = _MXC_BUILD_GPIO_PIN(1, 9, 1, 0x88, 0x41C),
-	MX51_PIN_EIM_D28 = _MXC_BUILD_NON_GPIO_PIN(0x8C, 0x420),
-	MX51_PIN_EIM_D29 = _MXC_BUILD_NON_GPIO_PIN(0x90, 0x424),
-	MX51_PIN_EIM_D30 = _MXC_BUILD_NON_GPIO_PIN(0x94, 0x428),
-	MX51_PIN_EIM_D31 = _MXC_BUILD_NON_GPIO_PIN(0x98, 0x42C),
-	MX51_PIN_EIM_A16 = _MXC_BUILD_GPIO_PIN(1, 10, 1, 0x9C, 0x430),
-	MX51_PIN_EIM_A17 = _MXC_BUILD_GPIO_PIN(1, 11, 1, 0xA0, 0x434),
-	MX51_PIN_EIM_A18 = _MXC_BUILD_GPIO_PIN(1, 12, 1, 0xA4, 0x438),
-	MX51_PIN_EIM_A19 = _MXC_BUILD_GPIO_PIN(1, 13, 1, 0xA8, 0x43C),
-	MX51_PIN_EIM_A20 = _MXC_BUILD_GPIO_PIN(1, 14, 1, 0xAC, 0x440),
-	MX51_PIN_EIM_A21 = _MXC_BUILD_GPIO_PIN(1, 15, 1, 0xB0, 0x444),
-	MX51_PIN_EIM_A22 = _MXC_BUILD_GPIO_PIN(1, 16, 1, 0xB4, 0x448),
-	MX51_PIN_EIM_A23 = _MXC_BUILD_GPIO_PIN(1, 17, 1, 0xB8, 0x44C),
-	MX51_PIN_EIM_A24 = _MXC_BUILD_GPIO_PIN(1, 18, 1, 0xBC, 0x450),
-	MX51_PIN_EIM_A25 = _MXC_BUILD_GPIO_PIN(1, 19, 1, 0xC0, 0x454),
-	MX51_PIN_EIM_A26 = _MXC_BUILD_GPIO_PIN(1, 20, 1, 0xC4, 0x458),
-	MX51_PIN_EIM_A27 = _MXC_BUILD_GPIO_PIN(1, 21, 1, 0xC8, 0x45C),
-	MX51_PIN_EIM_EB0 = _MXC_BUILD_NON_GPIO_PIN(0xCC, 0x460),
-	MX51_PIN_EIM_EB1 = _MXC_BUILD_NON_GPIO_PIN(0xD0, 0x464),
-	MX51_PIN_EIM_EB2 = _MXC_BUILD_GPIO_PIN(1, 22, 1, 0xD4, 0x468),
-	MX51_PIN_EIM_EB3 = _MXC_BUILD_GPIO_PIN(1, 23, 1, 0xD8, 0x46C),
-	MX51_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN(1, 24, 1, 0xDC, 0x470),
-	MX51_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN(1, 25, 1, 0xE0, 0x474),
-	MX51_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN(1, 26, 1, 0xE4, 0x478),
-	MX51_PIN_EIM_CS2 = _MXC_BUILD_GPIO_PIN(1, 27, 1, 0xE8, 0x47C),
-	MX51_PIN_EIM_CS3 = _MXC_BUILD_GPIO_PIN(1, 28, 1, 0xEC, 0x480),
-	MX51_PIN_EIM_CS4 = _MXC_BUILD_GPIO_PIN(1, 29, 1, 0xF0, 0x484),
-	MX51_PIN_EIM_CS5 = _MXC_BUILD_GPIO_PIN(1, 30, 1, 0xF4, 0x488),
-	MX51_PIN_EIM_DTACK = _MXC_BUILD_GPIO_PIN(1, 31, 1, 0xF8, 0x48C),
-	MX51_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN(2, 1, 1, 0xFC, 0x494),
-	MX51_PIN_EIM_CRE = _MXC_BUILD_GPIO_PIN(2, 2, 1, 0x100, 0x4A0),
-	MX51_PIN_DRAM_CS1 = _MXC_BUILD_NON_GPIO_PIN(0x104, 0x4D0),
-	MX51_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN(2, 3, 3, 0x108, 0x4E4),
-	MX51_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN(2, 4, 3, 0x10C, 0x4E8),
-	MX51_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN(2, 5, 3, 0x110, 0x4EC),
-	MX51_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN(2, 6, 3, 0x114, 0x4F0),
-	MX51_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN(2, 7, 3, 0x118, 0x4F4),
-	MX51_PIN_NANDF_RB0 = _MXC_BUILD_GPIO_PIN(2, 8, 3, 0x11C, 0x4F8),
-	MX51_PIN_NANDF_RB1 = _MXC_BUILD_GPIO_PIN(2, 9, 3, 0x120, 0x4FC),
-	MX51_PIN_NANDF_RB2 = _MXC_BUILD_GPIO_PIN(2, 10, 3, 0x124, 0x500),
-	MX51_PIN_NANDF_RB3 = _MXC_BUILD_GPIO_PIN(2, 11, 3, 0x128, 0x504),
-	MX51_PIN_GPIO_NAND = _MXC_BUILD_GPIO_PIN(2, 12, 3, 0x12C, 0x514),
+enum iomux_pins_mx51 {
+	MX51_PIN_EIM_DA0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1C, 0x7A8),
+	MX51_PIN_EIM_DA1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x20, 0x7A8),
+	MX51_PIN_EIM_DA2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x24, 0x7A8),
+	MX51_PIN_EIM_DA3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x28, 0x7A8),
+	MX51_PIN_EIM_DA4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2C, 0x7AC),
+	MX51_PIN_EIM_DA5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x30, 0x7AC),
+	MX51_PIN_EIM_DA6 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x34, 0x7AC),
+	MX51_PIN_EIM_DA7 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x38, 0x7AC),
+	MX51_PIN_EIM_DA8 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C, 0x7B0),
+	MX51_PIN_EIM_DA9 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x40, 0x7B0),
+	MX51_PIN_EIM_DA10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x44, 0x7B0),
+	MX51_PIN_EIM_DA11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x48, 0x7B0),
+	MX51_PIN_EIM_DA12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x4C, 0x7BC),
+	MX51_PIN_EIM_DA13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x50, 0x7BC),
+	MX51_PIN_EIM_DA14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x54, 0x7BC),
+	MX51_PIN_EIM_DA15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x58, 0x7BC),
+	MX51_PIN_EIM_D16 = _MXC_BUILD_GPIO_PIN_MX51(1, 0, 1, 0x5C, 0x3F0),
+	MX51_PIN_EIM_D17 = _MXC_BUILD_GPIO_PIN_MX51(1, 1, 1, 0x60, 0x3F4),
+	MX51_PIN_EIM_D18 = _MXC_BUILD_GPIO_PIN_MX51(1, 2, 1, 0x64, 0x3F8),
+	MX51_PIN_EIM_D19 = _MXC_BUILD_GPIO_PIN_MX51(1, 3, 1, 0x68, 0x3FC),
+	MX51_PIN_EIM_D20 = _MXC_BUILD_GPIO_PIN_MX51(1, 4, 1, 0x6C, 0x400),
+	MX51_PIN_EIM_D21 = _MXC_BUILD_GPIO_PIN_MX51(1, 5, 1, 0x70, 0x404),
+	MX51_PIN_EIM_D22 = _MXC_BUILD_GPIO_PIN_MX51(1, 6, 1, 0x74, 0x408),
+	MX51_PIN_EIM_D23 = _MXC_BUILD_GPIO_PIN_MX51(1, 7, 1, 0x78, 0x40C),
+	MX51_PIN_EIM_D24 = _MXC_BUILD_GPIO_PIN_MX51(1, 8, 1, 0x7C, 0x410),
+	MX51_PIN_EIM_D25 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x80, 0x414),
+	MX51_PIN_EIM_D26 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x84, 0x418),
+	MX51_PIN_EIM_D27 = _MXC_BUILD_GPIO_PIN_MX51(1, 9, 1, 0x88, 0x41C),
+	MX51_PIN_EIM_D28 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x8C, 0x420),
+	MX51_PIN_EIM_D29 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x90, 0x424),
+	MX51_PIN_EIM_D30 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x94, 0x428),
+	MX51_PIN_EIM_D31 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x98, 0x42C),
+	MX51_PIN_EIM_A16 = _MXC_BUILD_GPIO_PIN_MX51(1, 10, 1, 0x9C, 0x430),
+	MX51_PIN_EIM_A17 = _MXC_BUILD_GPIO_PIN_MX51(1, 11, 1, 0xA0, 0x434),
+	MX51_PIN_EIM_A18 = _MXC_BUILD_GPIO_PIN_MX51(1, 12, 1, 0xA4, 0x438),
+	MX51_PIN_EIM_A19 = _MXC_BUILD_GPIO_PIN_MX51(1, 13, 1, 0xA8, 0x43C),
+	MX51_PIN_EIM_A20 = _MXC_BUILD_GPIO_PIN_MX51(1, 14, 1, 0xAC, 0x440),
+	MX51_PIN_EIM_A21 = _MXC_BUILD_GPIO_PIN_MX51(1, 15, 1, 0xB0, 0x444),
+	MX51_PIN_EIM_A22 = _MXC_BUILD_GPIO_PIN_MX51(1, 16, 1, 0xB4, 0x448),
+	MX51_PIN_EIM_A23 = _MXC_BUILD_GPIO_PIN_MX51(1, 17, 1, 0xB8, 0x44C),
+	MX51_PIN_EIM_A24 = _MXC_BUILD_GPIO_PIN_MX51(1, 18, 1, 0xBC, 0x450),
+	MX51_PIN_EIM_A25 = _MXC_BUILD_GPIO_PIN_MX51(1, 19, 1, 0xC0, 0x454),
+	MX51_PIN_EIM_A26 = _MXC_BUILD_GPIO_PIN_MX51(1, 20, 1, 0xC4, 0x458),
+	MX51_PIN_EIM_A27 = _MXC_BUILD_GPIO_PIN_MX51(1, 21, 1, 0xC8, 0x45C),
+	MX51_PIN_EIM_EB0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0xCC, 0x460),
+	MX51_PIN_EIM_EB1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0xD0, 0x464),
+	MX51_PIN_EIM_EB2 = _MXC_BUILD_GPIO_PIN_MX51(1, 22, 1, 0xD4, 0x468),
+	MX51_PIN_EIM_EB3 = _MXC_BUILD_GPIO_PIN_MX51(1, 23, 1, 0xD8, 0x46C),
+	MX51_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN_MX51(1, 24, 1, 0xDC, 0x470),
+	MX51_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN_MX51(1, 25, 1, 0xE0, 0x474),
+	MX51_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN_MX51(1, 26, 1, 0xE4, 0x478),
+	MX51_PIN_EIM_CS2 = _MXC_BUILD_GPIO_PIN_MX51(1, 27, 1, 0xE8, 0x47C),
+	MX51_PIN_EIM_CS3 = _MXC_BUILD_GPIO_PIN_MX51(1, 28, 1, 0xEC, 0x480),
+	MX51_PIN_EIM_CS4 = _MXC_BUILD_GPIO_PIN_MX51(1, 29, 1, 0xF0, 0x484),
+	MX51_PIN_EIM_CS5 = _MXC_BUILD_GPIO_PIN_MX51(1, 30, 1, 0xF4, 0x488),
+	MX51_PIN_EIM_DTACK = _MXC_BUILD_GPIO_PIN_MX51(1, 31, 1, 0xF8, 0x48C),
+	MX51_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN_MX51(2, 1, 1, 0xFC, 0x494),
+	MX51_PIN_EIM_CRE = _MXC_BUILD_GPIO_PIN_MX51(2, 2, 1, 0x100, 0x4A0),
+	MX51_PIN_DRAM_CS1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x104, 0x4D0),
+	MX51_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN_MX51(2, 3, 3, 0x108, 0x4E4),
+	MX51_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN_MX51(2, 4, 3, 0x10C, 0x4E8),
+	MX51_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN_MX51(2, 5, 3, 0x110, 0x4EC),
+	MX51_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN_MX51(2, 6, 3, 0x114, 0x4F0),
+	MX51_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN_MX51(2, 7, 3, 0x118, 0x4F4),
+	MX51_PIN_NANDF_RB0 = _MXC_BUILD_GPIO_PIN_MX51(2, 8, 3, 0x11C, 0x4F8),
+	MX51_PIN_NANDF_RB1 = _MXC_BUILD_GPIO_PIN_MX51(2, 9, 3, 0x120, 0x4FC),
+	MX51_PIN_NANDF_RB2 = _MXC_BUILD_GPIO_PIN_MX51(2, 10, 3, 0x124, 0x500),
+	MX51_PIN_NANDF_RB3 = _MXC_BUILD_GPIO_PIN_MX51(2, 11, 3, 0x128, 0x504),
+	MX51_PIN_GPIO_NAND = _MXC_BUILD_GPIO_PIN_MX51(2, 12, 3, 0x12C, 0x514),
 	MX51_PIN_NANDF_RB4 = MX51_PIN_GPIO_NAND,
-	MX51_PIN_NANDF_RB5 = _MXC_BUILD_GPIO_PIN(2, 13, 3, 0x130, 0x5D8),
-	MX51_PIN_NANDF_RB6 = _MXC_BUILD_GPIO_PIN(2, 14, 3, 0x134, 0x5DC),
-	MX51_PIN_NANDF_RB7 = _MXC_BUILD_GPIO_PIN(2, 15, 3, 0x138, 0x5E0),
-	MX51_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN(2, 16, 3, 0x130, 0x518),
-	MX51_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN(2, 17, 3, 0x134, 0x51C),
-	MX51_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN(2, 18, 3, 0x138, 0x520),
-	MX51_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN(2, 19, 3, 0x13C, 0x524),
-	MX51_PIN_NANDF_CS4 = _MXC_BUILD_GPIO_PIN(2, 20, 3, 0x140, 0x528),
-	MX51_PIN_NANDF_CS5 = _MXC_BUILD_GPIO_PIN(2, 21, 3, 0x144, 0x52C),
-	MX51_PIN_NANDF_CS6 = _MXC_BUILD_GPIO_PIN(2, 22, 3, 0x148, 0x530),
-	MX51_PIN_NANDF_CS7 = _MXC_BUILD_GPIO_PIN(2, 23, 3, 0x14C, 0x534),
-	MX51_PIN_NANDF_RDY_INT = _MXC_BUILD_GPIO_PIN(2, 24, 3, 0x150, 0x538),
-	MX51_PIN_NANDF_D15 = _MXC_BUILD_GPIO_PIN(2, 25, 3, 0x154, 0x53C),
-	MX51_PIN_NANDF_D14 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0x158, 0x540),
-	MX51_PIN_NANDF_D13 = _MXC_BUILD_GPIO_PIN(2, 27, 3, 0x15C, 0x544),
-	MX51_PIN_NANDF_D12 = _MXC_BUILD_GPIO_PIN(2, 28, 3, 0x160, 0x548),
-	MX51_PIN_NANDF_D11 = _MXC_BUILD_GPIO_PIN(2, 29, 3, 0x164, 0x54C),
-	MX51_PIN_NANDF_D10 = _MXC_BUILD_GPIO_PIN(2, 30, 3, 0x168, 0x550),
-	MX51_PIN_NANDF_D9 = _MXC_BUILD_GPIO_PIN(2, 31, 3, 0x16C, 0x554),
-	MX51_PIN_NANDF_D8 = _MXC_BUILD_GPIO_PIN(3, 0, 3, 0x170, 0x558),
-	MX51_PIN_NANDF_D7 = _MXC_BUILD_GPIO_PIN(3, 1, 3, 0x174, 0x55C),
-	MX51_PIN_NANDF_D6 = _MXC_BUILD_GPIO_PIN(3, 2, 3, 0x178, 0x560),
-	MX51_PIN_NANDF_D5 = _MXC_BUILD_GPIO_PIN(3, 3, 3, 0x17C, 0x564),
-	MX51_PIN_NANDF_D4 = _MXC_BUILD_GPIO_PIN(3, 4, 3, 0x180, 0x568),
-	MX51_PIN_NANDF_D3 = _MXC_BUILD_GPIO_PIN(3, 5, 3, 0x184, 0x56C),
-	MX51_PIN_NANDF_D2 = _MXC_BUILD_GPIO_PIN(3, 6, 3, 0x188, 0x570),
-	MX51_PIN_NANDF_D1 = _MXC_BUILD_GPIO_PIN(3, 7, 3, 0x18C, 0x574),
-	MX51_PIN_NANDF_D0 = _MXC_BUILD_GPIO_PIN(3, 8, 3, 0x190, 0x578),
-	MX51_PIN_CSI1_D8 = _MXC_BUILD_GPIO_PIN(2, 12, 3, 0x194, 0x57C),
-	MX51_PIN_CSI1_D9 = _MXC_BUILD_GPIO_PIN(2, 13, 3, 0x198, 0x580),
-	MX51_PIN_CSI1_D10 = _MXC_BUILD_NON_GPIO_PIN(0x19C, 0x584),
-	MX51_PIN_CSI1_D11 = _MXC_BUILD_NON_GPIO_PIN(0x1A0, 0x588),
-	MX51_PIN_CSI1_D12 = _MXC_BUILD_NON_GPIO_PIN(0x1A4, 0x58C),
-	MX51_PIN_CSI1_D13 = _MXC_BUILD_NON_GPIO_PIN(0x1A8, 0x590),
-	MX51_PIN_CSI1_D14 = _MXC_BUILD_NON_GPIO_PIN(0x1AC, 0x594),
-	MX51_PIN_CSI1_D15 = _MXC_BUILD_NON_GPIO_PIN(0x1B0, 0x598),
-	MX51_PIN_CSI1_D16 = _MXC_BUILD_NON_GPIO_PIN(0x1B4, 0x59C),
-	MX51_PIN_CSI1_D17 = _MXC_BUILD_NON_GPIO_PIN(0x1B8, 0x5A0),
-	MX51_PIN_CSI1_D18 = _MXC_BUILD_NON_GPIO_PIN(0x1BC, 0x5A4),
-	MX51_PIN_CSI1_D19 = _MXC_BUILD_NON_GPIO_PIN(0x1C0, 0x5A8),
-	MX51_PIN_CSI1_VSYNC = _MXC_BUILD_GPIO_PIN(2, 14, 3, 0x1C4, 0x5AC),
-	MX51_PIN_CSI1_HSYNC = _MXC_BUILD_GPIO_PIN(2, 15, 3, 0x1C8, 0x5B0),
-	MX51_PIN_CSI1_PIXCLK = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x5B4),
-	MX51_PIN_CSI1_MCLK = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x5B8),
-	MX51_PIN_CSI1_PKE0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x860),
-	MX51_PIN_CSI2_D12 = _MXC_BUILD_GPIO_PIN(3, 9, 3, 0x1CC, 0x5BC),
-	MX51_PIN_CSI2_D13 = _MXC_BUILD_GPIO_PIN(3, 10, 3, 0x1D0, 0x5C0),
-	MX51_PIN_CSI2_D14 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1D4, 0x5C4),
-	MX51_PIN_CSI2_D15 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1D8, 0x5C8),
-	MX51_PIN_CSI2_D16 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1DC, 0x5CC),
-	MX51_PIN_CSI2_D17 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1E0, 0x5D0),
-	MX51_PIN_CSI2_D18 = _MXC_BUILD_GPIO_PIN(3, 11, 3, 0x1E4, 0x5D4),
-	MX51_PIN_CSI2_D19 = _MXC_BUILD_GPIO_PIN(3, 12, 3, 0x1E8, 0x5D8),
-	MX51_PIN_CSI2_VSYNC = _MXC_BUILD_GPIO_PIN(3, 13, 3, 0x1EC, 0x5DC),
-	MX51_PIN_CSI2_HSYNC = _MXC_BUILD_GPIO_PIN(3, 14, 3, 0x1F0, 0x5E0),
-	MX51_PIN_CSI2_PIXCLK = _MXC_BUILD_GPIO_PIN(3, 15, 3, 0x1F4, 0x5E4),
-	MX51_PIN_CSI2_PKE0 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x81C),
-	MX51_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(3, 16, 3, 0x1F8, 0x5E8),
-	MX51_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(3, 17, 3, 0x1FC, 0x5EC),
-	MX51_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN(3, 18, 3, 0x200, 0x5F0),
-	MX51_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN(3, 19, 3, 0x204, 0x5F4),
-	MX51_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN(3, 20, 3, 0x208, 0x5F8),
-	MX51_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN(3, 21, 3, 0x20C, 0x5FC),
-	MX51_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(3, 22, 3, 0x210, 0x600),
-	MX51_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(3, 23, 3, 0x214, 0x604),
-	MX51_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(3, 24, 3, 0x218, 0x608),
-	MX51_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(3, 25, 3, 0x21C, 0x60C),
-	MX51_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN(3, 26, 3, 0x220, 0x610),
-	MX51_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(3, 27, 3, 0x224, 0x614),
-	MX51_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(3, 28, 3, 0x228, 0x618),
-	MX51_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(3, 29, 3, 0x22C, 0x61C),
-	MX51_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(3, 30, 3, 0x230, 0x620),
-	MX51_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(3, 31, 3, 0x234, 0x624),
-	MX51_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(0, 20, 3, 0x238, 0x628),
-	MX51_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(0, 21, 3, 0x23C, 0x62C),
-	MX51_PIN_UART3_RXD = _MXC_BUILD_GPIO_PIN(0, 22, 3, 0x240, 0x630),
-	MX51_PIN_UART3_TXD = _MXC_BUILD_GPIO_PIN(0, 23, 3, 0x244, 0x634),
-	MX51_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN(0, 24, 3, 0x248, 0x638),
-	MX51_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(0x24C, 0x63C),
-	MX51_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(0x250, 0x640),
-	MX51_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(0x254, 0x644),
-	MX51_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(0x258, 0x648),
-	MX51_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(0x25C, 0x64C),
-	MX51_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(0x260, 0x650),
-	MX51_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(0x264, 0x654),
-	MX51_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(0x268, 0x658),
-	MX51_PIN_KEY_COL4 = _MXC_BUILD_NON_GPIO_PIN(0x26C, 0x65C),
-	MX51_PIN_KEY_COL5 = _MXC_BUILD_NON_GPIO_PIN(0x270, 0x660),
-	MX51_PIN_USBH1_CLK = _MXC_BUILD_GPIO_PIN(0, 25, 2, 0x278, 0x678),
-	MX51_PIN_USBH1_DIR = _MXC_BUILD_GPIO_PIN(0, 26, 2, 0x27C, 0x67C),
-	MX51_PIN_USBH1_STP = _MXC_BUILD_GPIO_PIN(0, 27, 2, 0x280, 0x680),
-	MX51_PIN_USBH1_NXT = _MXC_BUILD_GPIO_PIN(0, 28, 2, 0x284, 0x684),
-	MX51_PIN_USBH1_DATA0 = _MXC_BUILD_GPIO_PIN(0, 11, 2, 0x288, 0x688),
-	MX51_PIN_USBH1_DATA1 = _MXC_BUILD_GPIO_PIN(0, 12, 2, 0x28C, 0x68C),
-	MX51_PIN_USBH1_DATA2 = _MXC_BUILD_GPIO_PIN(0, 13, 2, 0x290, 0x690),
-	MX51_PIN_USBH1_DATA3 = _MXC_BUILD_GPIO_PIN(0, 14, 2, 0x294, 0x694),
-	MX51_PIN_USBH1_DATA4 = _MXC_BUILD_GPIO_PIN(0, 15, 2, 0x298, 0x698),
-	MX51_PIN_USBH1_DATA5 = _MXC_BUILD_GPIO_PIN(0, 16, 2, 0x29C, 0x69C),
-	MX51_PIN_USBH1_DATA6 = _MXC_BUILD_GPIO_PIN(0, 17, 2, 0x2A0, 0x6A0),
-	MX51_PIN_USBH1_DATA7 = _MXC_BUILD_GPIO_PIN(0, 18, 2, 0x2A4, 0x6A4),
-	MX51_PIN_DI1_PIN11 = _MXC_BUILD_GPIO_PIN(2, 0, 4, 0x2A8, 0x6A8),
-	MX51_PIN_DI1_PIN12 = _MXC_BUILD_GPIO_PIN(2, 1, 4, 0x2AC, 0x6AC),
-	MX51_PIN_DI1_PIN13 = _MXC_BUILD_GPIO_PIN(2, 2, 4, 0x2B0, 0x6B0),
-	MX51_PIN_DI1_D0_CS = _MXC_BUILD_GPIO_PIN(2, 3, 4, 0x2B4, 0x6B4),
-	MX51_PIN_DI1_D1_CS = _MXC_BUILD_GPIO_PIN(2, 4, 4, 0x2B8, 0x6B8),
-	MX51_PIN_DISPB2_SER_DIN = _MXC_BUILD_GPIO_PIN(2, 5, 4, 0x2BC, 0x6BC),
-	MX51_PIN_DISPB2_SER_DIO = _MXC_BUILD_GPIO_PIN(2, 6, 4, 0x2C0, 0x6C0),
-	MX51_PIN_DISPB2_SER_CLK = _MXC_BUILD_GPIO_PIN(2, 7, 4, 0x2C4, 0x6C4),
-	MX51_PIN_DISPB2_SER_RS = _MXC_BUILD_GPIO_PIN(2, 8, 4, 0x2C8, 0x6C8),
-	MX51_PIN_DISP1_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x2CC, 0x6CC),
-	MX51_PIN_DISP1_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x2D0, 0x6D0),
-	MX51_PIN_DISP1_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x2D4, 0x6D4),
-	MX51_PIN_DISP1_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x2D8, 0x6D8),
-	MX51_PIN_DISP1_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x2DC, 0x6DC),
-	MX51_PIN_DISP1_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x2E0, 0x6E0),
-	MX51_PIN_DISP1_DAT6 = _MXC_BUILD_NON_GPIO_PIN(0x2E4, 0x6E4),
-	MX51_PIN_DISP1_DAT7 = _MXC_BUILD_NON_GPIO_PIN(0x2E8, 0x6E8),
-	MX51_PIN_DISP1_DAT8 = _MXC_BUILD_NON_GPIO_PIN(0x2EC, 0x6EC),
-	MX51_PIN_DISP1_DAT9 = _MXC_BUILD_NON_GPIO_PIN(0x2F0, 0x6F0),
-	MX51_PIN_DISP1_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x2F4, 0x6F4),
-	MX51_PIN_DISP1_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x2F8, 0x6F8),
-	MX51_PIN_DISP1_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x2FC, 0x6FC),
-	MX51_PIN_DISP1_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x300, 0x700),
-	MX51_PIN_DISP1_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x304, 0x704),
-	MX51_PIN_DISP1_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x308, 0x708),
-	MX51_PIN_DISP1_DAT16 = _MXC_BUILD_NON_GPIO_PIN(0x30C, 0x70C),
-	MX51_PIN_DISP1_DAT17 = _MXC_BUILD_NON_GPIO_PIN(0x310, 0x710),
-	MX51_PIN_DISP1_DAT18 = _MXC_BUILD_NON_GPIO_PIN(0x314, 0x714),
-	MX51_PIN_DISP1_DAT19 = _MXC_BUILD_NON_GPIO_PIN(0x318, 0x718),
-	MX51_PIN_DISP1_DAT20 = _MXC_BUILD_NON_GPIO_PIN(0x31C, 0x71C),
-	MX51_PIN_DISP1_DAT21 = _MXC_BUILD_NON_GPIO_PIN(0x320, 0x720),
-	MX51_PIN_DISP1_DAT22 = _MXC_BUILD_NON_GPIO_PIN(0x324, 0x724),
-	MX51_PIN_DISP1_DAT23 = _MXC_BUILD_NON_GPIO_PIN(0x328, 0x728),
-	MX51_PIN_DI1_PIN3 = _MXC_BUILD_NON_GPIO_PIN(0x32C, 0x72C),
-	MX51_PIN_DI1_PIN2 = _MXC_BUILD_NON_GPIO_PIN(0x330, 0x734),
-	MX51_PIN_DI_GP1 = _MXC_BUILD_NON_GPIO_PIN(0x334, 0x73C),
-	MX51_PIN_DI_GP2 = _MXC_BUILD_NON_GPIO_PIN(0x338, 0x740),
-	MX51_PIN_DI_GP3 = _MXC_BUILD_NON_GPIO_PIN(0x33C, 0x744),
-	MX51_PIN_DI2_PIN4 = _MXC_BUILD_NON_GPIO_PIN(0x340, 0x748),
-	MX51_PIN_DI2_PIN2 = _MXC_BUILD_NON_GPIO_PIN(0x344, 0x74C),
-	MX51_PIN_DI2_PIN3 = _MXC_BUILD_NON_GPIO_PIN(0x348, 0x750),
-	MX51_PIN_DI2_DISP_CLK = _MXC_BUILD_NON_GPIO_PIN(0x34C, 0x754),
-	MX51_PIN_DI_GP4 = _MXC_BUILD_NON_GPIO_PIN(0x350, 0x758),
-	MX51_PIN_DISP2_DAT0 = _MXC_BUILD_NON_GPIO_PIN(0x354, 0x75C),
-	MX51_PIN_DISP2_DAT1 = _MXC_BUILD_NON_GPIO_PIN(0x358, 0x760),
-	MX51_PIN_DISP2_DAT2 = _MXC_BUILD_NON_GPIO_PIN(0x35C, 0x764),
-	MX51_PIN_DISP2_DAT3 = _MXC_BUILD_NON_GPIO_PIN(0x360, 0x768),
-	MX51_PIN_DISP2_DAT4 = _MXC_BUILD_NON_GPIO_PIN(0x364, 0x76C),
-	MX51_PIN_DISP2_DAT5 = _MXC_BUILD_NON_GPIO_PIN(0x368, 0x770),
-	MX51_PIN_DISP2_DAT6 = _MXC_BUILD_GPIO_PIN(0, 19, 5, 0x36C, 0x774),
-	MX51_PIN_DISP2_DAT7 = _MXC_BUILD_GPIO_PIN(0, 29, 5, 0x370, 0x778),
-	MX51_PIN_DISP2_DAT8 = _MXC_BUILD_GPIO_PIN(0, 30, 5, 0x374, 0x77C),
-	MX51_PIN_DISP2_DAT9 = _MXC_BUILD_GPIO_PIN(0, 31, 5, 0x378, 0x780),
-	MX51_PIN_DISP2_DAT10 = _MXC_BUILD_NON_GPIO_PIN(0x37C, 0x784),
-	MX51_PIN_DISP2_DAT11 = _MXC_BUILD_NON_GPIO_PIN(0x380, 0x788),
-	MX51_PIN_DISP2_DAT12 = _MXC_BUILD_NON_GPIO_PIN(0x384, 0x78C),
-	MX51_PIN_DISP2_DAT13 = _MXC_BUILD_NON_GPIO_PIN(0x388, 0x790),
-	MX51_PIN_DISP2_DAT14 = _MXC_BUILD_NON_GPIO_PIN(0x38C, 0x794),
-	MX51_PIN_DISP2_DAT15 = _MXC_BUILD_NON_GPIO_PIN(0x390, 0x798),
-	MX51_PIN_SD1_CMD = _MXC_BUILD_NON_GPIO_PIN(0x394, 0x79C),
-	MX51_PIN_SD1_CLK = _MXC_BUILD_NON_GPIO_PIN(0x398, 0x7A0),
-	MX51_PIN_SD1_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x39C, 0x7A4),
-	MX51_PIN_SD1_DATA1 = _MXC_BUILD_NON_GPIO_PIN(0x3A0, 0x7A8),
-	MX51_PIN_SD1_DATA2 = _MXC_BUILD_NON_GPIO_PIN(0x3A4, 0x7AC),
-	MX51_PIN_SD1_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x3A8, 0x7B0),
-	MX51_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 1, 0x3AC, 0x7B4),
-	MX51_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 1, 0x3B0, 0x7B8),
-	MX51_PIN_SD2_CMD = _MXC_BUILD_NON_GPIO_PIN(0x3B4, 0x7BC),
-	MX51_PIN_SD2_CLK = _MXC_BUILD_NON_GPIO_PIN(0x3B8, 0x7C0),
-	MX51_PIN_SD2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(0x3BC, 0x7C4),
-	MX51_PIN_SD2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(0x3C0, 0x7C8),
-	MX51_PIN_SD2_DATA2 = _MXC_BUILD_NON_GPIO_PIN(0x3C4, 0x7CC),
-	MX51_PIN_SD2_DATA3 = _MXC_BUILD_NON_GPIO_PIN(0x3C8, 0x7D0),
-	MX51_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 0, 0x3CC, 0x7D4),
-	MX51_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 0, 0x3D0, 0x7D8),
-	MX51_PIN_PMIC_INT_REQ = _MXC_BUILD_NON_GPIO_PIN(0x3D4, 0x7FC),
-	MX51_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 0, 0x3D8, 0x804),
-	MX51_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 0, 0x3DC, 0x808),
-	MX51_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 0, 0x3E0, 0x80C),
-	MX51_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN(0, 7, 0, 0x3E4, 0x810),
-	MX51_PIN_GPIO1_8 = _MXC_BUILD_GPIO_PIN(0, 8, 0, 0x3E8, 0x814),
-	MX51_PIN_GPIO1_9 = _MXC_BUILD_GPIO_PIN(0, 9, 0, 0x3EC, 0x818),
+	MX51_PIN_NANDF_RB5 = _MXC_BUILD_GPIO_PIN_MX51(2, 13, 3, 0x130, 0x5D8),
+	MX51_PIN_NANDF_RB6 = _MXC_BUILD_GPIO_PIN_MX51(2, 14, 3, 0x134, 0x5DC),
+	MX51_PIN_NANDF_RB7 = _MXC_BUILD_GPIO_PIN_MX51(2, 15, 3, 0x138, 0x5E0),
+	MX51_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN_MX51(2, 16, 3, 0x130, 0x518),
+	MX51_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN_MX51(2, 17, 3, 0x134, 0x51C),
+	MX51_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN_MX51(2, 18, 3, 0x138, 0x520),
+	MX51_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN_MX51(2, 19, 3, 0x13C, 0x524),
+	MX51_PIN_NANDF_CS4 = _MXC_BUILD_GPIO_PIN_MX51(2, 20, 3, 0x140, 0x528),
+	MX51_PIN_NANDF_CS5 = _MXC_BUILD_GPIO_PIN_MX51(2, 21, 3, 0x144, 0x52C),
+	MX51_PIN_NANDF_CS6 = _MXC_BUILD_GPIO_PIN_MX51(2, 22, 3, 0x148, 0x530),
+	MX51_PIN_NANDF_CS7 = _MXC_BUILD_GPIO_PIN_MX51(2, 23, 3, 0x14C, 0x534),
+	MX51_PIN_NANDF_RDY_INT = _MXC_BUILD_GPIO_PIN_MX51(2, 24, 3, 0x150, 0x538),
+	MX51_PIN_NANDF_D15 = _MXC_BUILD_GPIO_PIN_MX51(2, 25, 3, 0x154, 0x53C),
+	MX51_PIN_NANDF_D14 = _MXC_BUILD_GPIO_PIN_MX51(2, 26, 3, 0x158, 0x540),
+	MX51_PIN_NANDF_D13 = _MXC_BUILD_GPIO_PIN_MX51(2, 27, 3, 0x15C, 0x544),
+	MX51_PIN_NANDF_D12 = _MXC_BUILD_GPIO_PIN_MX51(2, 28, 3, 0x160, 0x548),
+	MX51_PIN_NANDF_D11 = _MXC_BUILD_GPIO_PIN_MX51(2, 29, 3, 0x164, 0x54C),
+	MX51_PIN_NANDF_D10 = _MXC_BUILD_GPIO_PIN_MX51(2, 30, 3, 0x168, 0x550),
+	MX51_PIN_NANDF_D9 = _MXC_BUILD_GPIO_PIN_MX51(2, 31, 3, 0x16C, 0x554),
+	MX51_PIN_NANDF_D8 = _MXC_BUILD_GPIO_PIN_MX51(3, 0, 3, 0x170, 0x558),
+	MX51_PIN_NANDF_D7 = _MXC_BUILD_GPIO_PIN_MX51(3, 1, 3, 0x174, 0x55C),
+	MX51_PIN_NANDF_D6 = _MXC_BUILD_GPIO_PIN_MX51(3, 2, 3, 0x178, 0x560),
+	MX51_PIN_NANDF_D5 = _MXC_BUILD_GPIO_PIN_MX51(3, 3, 3, 0x17C, 0x564),
+	MX51_PIN_NANDF_D4 = _MXC_BUILD_GPIO_PIN_MX51(3, 4, 3, 0x180, 0x568),
+	MX51_PIN_NANDF_D3 = _MXC_BUILD_GPIO_PIN_MX51(3, 5, 3, 0x184, 0x56C),
+	MX51_PIN_NANDF_D2 = _MXC_BUILD_GPIO_PIN_MX51(3, 6, 3, 0x188, 0x570),
+	MX51_PIN_NANDF_D1 = _MXC_BUILD_GPIO_PIN_MX51(3, 7, 3, 0x18C, 0x574),
+	MX51_PIN_NANDF_D0 = _MXC_BUILD_GPIO_PIN_MX51(3, 8, 3, 0x190, 0x578),
+	MX51_PIN_CSI1_D8 = _MXC_BUILD_GPIO_PIN_MX51(2, 12, 3, 0x194, 0x57C),
+	MX51_PIN_CSI1_D9 = _MXC_BUILD_GPIO_PIN_MX51(2, 13, 3, 0x198, 0x580),
+	MX51_PIN_CSI1_D10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x19C, 0x584),
+	MX51_PIN_CSI1_D11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1A0, 0x588),
+	MX51_PIN_CSI1_D12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1A4, 0x58C),
+	MX51_PIN_CSI1_D13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1A8, 0x590),
+	MX51_PIN_CSI1_D14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1AC, 0x594),
+	MX51_PIN_CSI1_D15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1B0, 0x598),
+	MX51_PIN_CSI1_D16 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1B4, 0x59C),
+	MX51_PIN_CSI1_D17 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1B8, 0x5A0),
+	MX51_PIN_CSI1_D18 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1BC, 0x5A4),
+	MX51_PIN_CSI1_D19 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1C0, 0x5A8),
+	MX51_PIN_CSI1_VSYNC = _MXC_BUILD_GPIO_PIN_MX51(2, 14, 3, 0x1C4, 0x5AC),
+	MX51_PIN_CSI1_HSYNC = _MXC_BUILD_GPIO_PIN_MX51(2, 15, 3, 0x1C8, 0x5B0),
+	MX51_PIN_CSI1_PIXCLK = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x5B4),
+	MX51_PIN_CSI1_MCLK = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x5B8),
+	MX51_PIN_CSI1_PKE0 = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x860),
+	MX51_PIN_CSI2_D12 = _MXC_BUILD_GPIO_PIN_MX51(3, 9, 3, 0x1CC, 0x5BC),
+	MX51_PIN_CSI2_D13 = _MXC_BUILD_GPIO_PIN_MX51(3, 10, 3, 0x1D0, 0x5C0),
+	MX51_PIN_CSI2_D14 = _MXC_BUILD_GPIO_PIN_MX51(3, 11, 3, 0x1D4, 0x5C4),
+	MX51_PIN_CSI2_D15 = _MXC_BUILD_GPIO_PIN_MX51(3, 12, 3, 0x1D8, 0x5C8),
+	MX51_PIN_CSI2_D16 = _MXC_BUILD_GPIO_PIN_MX51(3, 11, 3, 0x1DC, 0x5CC),
+	MX51_PIN_CSI2_D17 = _MXC_BUILD_GPIO_PIN_MX51(3, 12, 3, 0x1E0, 0x5D0),
+	MX51_PIN_CSI2_D18 = _MXC_BUILD_GPIO_PIN_MX51(3, 11, 3, 0x1E4, 0x5D4),
+	MX51_PIN_CSI2_D19 = _MXC_BUILD_GPIO_PIN_MX51(3, 12, 3, 0x1E8, 0x5D8),
+	MX51_PIN_CSI2_VSYNC = _MXC_BUILD_GPIO_PIN_MX51(3, 13, 3, 0x1EC, 0x5DC),
+	MX51_PIN_CSI2_HSYNC = _MXC_BUILD_GPIO_PIN_MX51(3, 14, 3, 0x1F0, 0x5E0),
+	MX51_PIN_CSI2_PIXCLK = _MXC_BUILD_GPIO_PIN_MX51(3, 15, 3, 0x1F4, 0x5E4),
+	MX51_PIN_CSI2_PKE0 = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x81C),
+	MX51_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN_MX51(3, 16, 3, 0x1F8, 0x5E8),
+	MX51_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN_MX51(3, 17, 3, 0x1FC, 0x5EC),
+	MX51_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN_MX51(3, 18, 3, 0x200, 0x5F0),
+	MX51_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN_MX51(3, 19, 3, 0x204, 0x5F4),
+	MX51_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN_MX51(3, 20, 3, 0x208, 0x5F8),
+	MX51_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN_MX51(3, 21, 3, 0x20C, 0x5FC),
+	MX51_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN_MX51(3, 22, 3, 0x210, 0x600),
+	MX51_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN_MX51(3, 23, 3, 0x214, 0x604),
+	MX51_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN_MX51(3, 24, 3, 0x218, 0x608),
+	MX51_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN_MX51(3, 25, 3, 0x21C, 0x60C),
+	MX51_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN_MX51(3, 26, 3, 0x220, 0x610),
+	MX51_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN_MX51(3, 27, 3, 0x224, 0x614),
+	MX51_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN_MX51(3, 28, 3, 0x228, 0x618),
+	MX51_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN_MX51(3, 29, 3, 0x22C, 0x61C),
+	MX51_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN_MX51(3, 30, 3, 0x230, 0x620),
+	MX51_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN_MX51(3, 31, 3, 0x234, 0x624),
+	MX51_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN_MX51(0, 20, 3, 0x238, 0x628),
+	MX51_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN_MX51(0, 21, 3, 0x23C, 0x62C),
+	MX51_PIN_UART3_RXD = _MXC_BUILD_GPIO_PIN_MX51(0, 22, 3, 0x240, 0x630),
+	MX51_PIN_UART3_TXD = _MXC_BUILD_GPIO_PIN_MX51(0, 23, 3, 0x244, 0x634),
+	MX51_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN_MX51(0, 24, 3, 0x248, 0x638),
+	MX51_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x24C, 0x63C),
+	MX51_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x250, 0x640),
+	MX51_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x254, 0x644),
+	MX51_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x258, 0x648),
+	MX51_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x25C, 0x64C),
+	MX51_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x260, 0x650),
+	MX51_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x264, 0x654),
+	MX51_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x268, 0x658),
+	MX51_PIN_KEY_COL4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x26C, 0x65C),
+	MX51_PIN_KEY_COL5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x270, 0x660),
+	MX51_PIN_USBH1_CLK = _MXC_BUILD_GPIO_PIN_MX51(0, 25, 2, 0x278, 0x678),
+	MX51_PIN_USBH1_DIR = _MXC_BUILD_GPIO_PIN_MX51(0, 26, 2, 0x27C, 0x67C),
+	MX51_PIN_USBH1_STP = _MXC_BUILD_GPIO_PIN_MX51(0, 27, 2, 0x280, 0x680),
+	MX51_PIN_USBH1_NXT = _MXC_BUILD_GPIO_PIN_MX51(0, 28, 2, 0x284, 0x684),
+	MX51_PIN_USBH1_DATA0 = _MXC_BUILD_GPIO_PIN_MX51(0, 11, 2, 0x288, 0x688),
+	MX51_PIN_USBH1_DATA1 = _MXC_BUILD_GPIO_PIN_MX51(0, 12, 2, 0x28C, 0x68C),
+	MX51_PIN_USBH1_DATA2 = _MXC_BUILD_GPIO_PIN_MX51(0, 13, 2, 0x290, 0x690),
+	MX51_PIN_USBH1_DATA3 = _MXC_BUILD_GPIO_PIN_MX51(0, 14, 2, 0x294, 0x694),
+	MX51_PIN_USBH1_DATA4 = _MXC_BUILD_GPIO_PIN_MX51(0, 15, 2, 0x298, 0x698),
+	MX51_PIN_USBH1_DATA5 = _MXC_BUILD_GPIO_PIN_MX51(0, 16, 2, 0x29C, 0x69C),
+	MX51_PIN_USBH1_DATA6 = _MXC_BUILD_GPIO_PIN_MX51(0, 17, 2, 0x2A0, 0x6A0),
+	MX51_PIN_USBH1_DATA7 = _MXC_BUILD_GPIO_PIN_MX51(0, 18, 2, 0x2A4, 0x6A4),
+	MX51_PIN_DI1_PIN11 = _MXC_BUILD_GPIO_PIN_MX51(2, 0, 4, 0x2A8, 0x6A8),
+	MX51_PIN_DI1_PIN12 = _MXC_BUILD_GPIO_PIN_MX51(2, 1, 4, 0x2AC, 0x6AC),
+	MX51_PIN_DI1_PIN13 = _MXC_BUILD_GPIO_PIN_MX51(2, 2, 4, 0x2B0, 0x6B0),
+	MX51_PIN_DI1_D0_CS = _MXC_BUILD_GPIO_PIN_MX51(2, 3, 4, 0x2B4, 0x6B4),
+	MX51_PIN_DI1_D1_CS = _MXC_BUILD_GPIO_PIN_MX51(2, 4, 4, 0x2B8, 0x6B8),
+	MX51_PIN_DISPB2_SER_DIN = _MXC_BUILD_GPIO_PIN_MX51(2, 5, 4, 0x2BC, 0x6BC),
+	MX51_PIN_DISPB2_SER_DIO = _MXC_BUILD_GPIO_PIN_MX51(2, 6, 4, 0x2C0, 0x6C0),
+	MX51_PIN_DISPB2_SER_CLK = _MXC_BUILD_GPIO_PIN_MX51(2, 7, 4, 0x2C4, 0x6C4),
+	MX51_PIN_DISPB2_SER_RS = _MXC_BUILD_GPIO_PIN_MX51(2, 8, 4, 0x2C8, 0x6C8),
+	MX51_PIN_DISP1_DAT0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2CC, 0x6CC),
+	MX51_PIN_DISP1_DAT1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2D0, 0x6D0),
+	MX51_PIN_DISP1_DAT2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2D4, 0x6D4),
+	MX51_PIN_DISP1_DAT3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2D8, 0x6D8),
+	MX51_PIN_DISP1_DAT4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2DC, 0x6DC),
+	MX51_PIN_DISP1_DAT5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2E0, 0x6E0),
+	MX51_PIN_DISP1_DAT6 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2E4, 0x6E4),
+	MX51_PIN_DISP1_DAT7 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2E8, 0x6E8),
+	MX51_PIN_DISP1_DAT8 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2EC, 0x6EC),
+	MX51_PIN_DISP1_DAT9 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2F0, 0x6F0),
+	MX51_PIN_DISP1_DAT10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2F4, 0x6F4),
+	MX51_PIN_DISP1_DAT11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2F8, 0x6F8),
+	MX51_PIN_DISP1_DAT12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2FC, 0x6FC),
+	MX51_PIN_DISP1_DAT13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x300, 0x700),
+	MX51_PIN_DISP1_DAT14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x304, 0x704),
+	MX51_PIN_DISP1_DAT15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x308, 0x708),
+	MX51_PIN_DISP1_DAT16 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x30C, 0x70C),
+	MX51_PIN_DISP1_DAT17 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x310, 0x710),
+	MX51_PIN_DISP1_DAT18 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x314, 0x714),
+	MX51_PIN_DISP1_DAT19 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x318, 0x718),
+	MX51_PIN_DISP1_DAT20 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x31C, 0x71C),
+	MX51_PIN_DISP1_DAT21 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x320, 0x720),
+	MX51_PIN_DISP1_DAT22 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x324, 0x724),
+	MX51_PIN_DISP1_DAT23 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x328, 0x728),
+	MX51_PIN_DI1_PIN3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x32C, 0x72C),
+	MX51_PIN_DI1_PIN2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x330, 0x734),
+	MX51_PIN_DI_GP1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x334, 0x73C),
+	MX51_PIN_DI_GP2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x338, 0x740),
+	MX51_PIN_DI_GP3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x33C, 0x744),
+	MX51_PIN_DI2_PIN4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x340, 0x748),
+	MX51_PIN_DI2_PIN2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x344, 0x74C),
+	MX51_PIN_DI2_PIN3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x348, 0x750),
+	MX51_PIN_DI2_DISP_CLK = _MXC_BUILD_NON_GPIO_PIN_MX51(0x34C, 0x754),
+	MX51_PIN_DI_GP4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x350, 0x758),
+	MX51_PIN_DISP2_DAT0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x354, 0x75C),
+	MX51_PIN_DISP2_DAT1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x358, 0x760),
+	MX51_PIN_DISP2_DAT2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x35C, 0x764),
+	MX51_PIN_DISP2_DAT3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x360, 0x768),
+	MX51_PIN_DISP2_DAT4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x364, 0x76C),
+	MX51_PIN_DISP2_DAT5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x368, 0x770),
+	MX51_PIN_DISP2_DAT6 = _MXC_BUILD_GPIO_PIN_MX51(0, 19, 5, 0x36C, 0x774),
+	MX51_PIN_DISP2_DAT7 = _MXC_BUILD_GPIO_PIN_MX51(0, 29, 5, 0x370, 0x778),
+	MX51_PIN_DISP2_DAT8 = _MXC_BUILD_GPIO_PIN_MX51(0, 30, 5, 0x374, 0x77C),
+	MX51_PIN_DISP2_DAT9 = _MXC_BUILD_GPIO_PIN_MX51(0, 31, 5, 0x378, 0x780),
+	MX51_PIN_DISP2_DAT10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x37C, 0x784),
+	MX51_PIN_DISP2_DAT11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x380, 0x788),
+	MX51_PIN_DISP2_DAT12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x384, 0x78C),
+	MX51_PIN_DISP2_DAT13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x388, 0x790),
+	MX51_PIN_DISP2_DAT14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x38C, 0x794),
+	MX51_PIN_DISP2_DAT15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x390, 0x798),
+	MX51_PIN_SD1_CMD = _MXC_BUILD_NON_GPIO_PIN_MX51(0x394, 0x79C),
+	MX51_PIN_SD1_CLK = _MXC_BUILD_NON_GPIO_PIN_MX51(0x398, 0x7A0),
+	MX51_PIN_SD1_DATA0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x39C, 0x7A4),
+	MX51_PIN_SD1_DATA1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3A0, 0x7A8),
+	MX51_PIN_SD1_DATA2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3A4, 0x7AC),
+	MX51_PIN_SD1_DATA3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3A8, 0x7B0),
+	MX51_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN_MX51(0, 0, 1, 0x3AC, 0x7B4),
+	MX51_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN_MX51(0, 1, 1, 0x3B0, 0x7B8),
+	MX51_PIN_SD2_CMD = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3B4, 0x7BC),
+	MX51_PIN_SD2_CLK = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3B8, 0x7C0),
+	MX51_PIN_SD2_DATA0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3BC, 0x7C4),
+	MX51_PIN_SD2_DATA1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C0, 0x7C8),
+	MX51_PIN_SD2_DATA2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C4, 0x7CC),
+	MX51_PIN_SD2_DATA3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C8, 0x7D0),
+	MX51_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN_MX51(0, 2, 0, 0x3CC, 0x7D4),
+	MX51_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN_MX51(0, 3, 0, 0x3D0, 0x7D8),
+	MX51_PIN_PMIC_INT_REQ = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3D4, 0x7FC),
+	MX51_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN_MX51(0, 4, 0, 0x3D8, 0x804),
+	MX51_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN_MX51(0, 5, 0, 0x3DC, 0x808),
+	MX51_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN_MX51(0, 6, 0, 0x3E0, 0x80C),
+	MX51_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN_MX51(0, 7, 0, 0x3E4, 0x810),
+	MX51_PIN_GPIO1_8 = _MXC_BUILD_GPIO_PIN_MX51(0, 8, 0, 0x3E8, 0x814),
+	MX51_PIN_GPIO1_9 = _MXC_BUILD_GPIO_PIN_MX51(0, 9, 0, 0x3EC, 0x818),
+};
+
+/*!
+ * various IOMUX input select register index
+ */
+enum iomux_input_select_mx51 {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXFS_AMX_SELECT,
+	MUX_IN_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_CCM_IPP_DI_CLK_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_CCM_IPP_DI1_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_DPLLIP1_L1T_TOG_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_EMI_IPP_IND_RDY_INT_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT0_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT1_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT2_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT3_IN_SELECT_INPUT,
+	MUX_IN_FEC_FEC_COL_SELECT_INPUT,
+	MUX_IN_FEC_FEC_CRS_SELECT_INPUT,
+	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_2_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_3_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
+	MUX_IN_FEC_FEC_TX_CLK_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_1_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_2_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_3_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_4_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_6_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_7_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_8_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_VSYNC_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_DI_WAIT_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_4_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_CLK_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_0_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_1_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_2_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_3_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_4_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_5_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_6_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_7_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DIR_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_NXT_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_STP_SELECT_INPUT,
+	MUX_INPUT_NUM_MUX,
 };
 
 #endif				/* __ASSEMBLY__ */
diff --git a/arch/arm/mach-mx5/mx53_evk.c b/arch/arm/mach-mx5/mx53_evk.c
new file mode 100644
index 0000000..4b828cd
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_evk.c
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/keypad.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+#include "board-mx53_evk.h"
+#include "iomux.h"
+#include "mx53_pins.h"
+#include "crm_regs.h"
+#include "devices.h"
+#include "usb.h"
+
+/*!
+ * @file mach-mx53/mx53_evk.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX53
+ */
+extern void __init mx53_evk_io_init(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 720p60 TV output */
+	 "720P60", 60, 1280, 720, 13468,
+	 260, 109,
+	 25, 4,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT |
+			FB_SYNC_EXT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+	{
+	 /* MITSUBISHI LVDS panel */
+	 "XGA", 60, 1024, 768, 15385,
+	 220, 40,
+	 21, 7,
+	 60, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+struct cpu_wp *mx53_evk_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+void mx53_evk_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 3,
+};
+
+extern void mx53_evk_gpio_spi_chipselect_active(int cspi_mode, int status,
+						    int chipselect);
+extern void mx53_evk_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+						      int chipselect);
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx53_evk_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx53_evk_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+};
+
+static struct resource mxcfb_resources[] = {
+	[0] = {
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB565,
+	 .mode_str = "800x480M-16@55",
+	 },
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB24,
+	 .mode_str = "1024x768M-16@60",
+	 },
+};
+
+static int __initdata enable_vga = { 0 };
+static int __initdata enable_tv = { 0 };
+
+static void wvga_reset(void)
+{
+}
+
+static struct mxc_lcd_platform_data lcd_wvga_data = {
+	.reset = wvga_reset,
+};
+
+static struct platform_device lcd_wvga_device = {
+	.name = "lcd_claa",
+};
+
+static int __init mxc_init_fb(void)
+{
+	if (!machine_is_mx53_evk())
+		return 0;
+
+	/* by default, fb0 is wvga, fb1 is vga or tv */
+	if (enable_vga) {
+		printk(KERN_INFO "VGA monitor is primary\n");
+	} else if (enable_tv == 2)
+		printk(KERN_INFO "HDTV is primary\n");
+	else
+		printk(KERN_INFO "WVGA LCD panel is primary\n");
+
+	if (enable_tv) {
+		printk(KERN_INFO "HDTV is specified as %d\n", enable_tv);
+		fb_data[1].interface_pix_fmt = IPU_PIX_FMT_YUV444;
+		fb_data[1].mode = &(video_modes[0]);
+	}
+
+	/* Once a customer knows the platform configuration,
+	   this should be simplified to what is desired.
+	 */
+	if (enable_vga || enable_tv == 2) {
+		/*
+		 * DI1 -> DP-BG channel:
+		 *
+		 *    dev    di-out-fmt    default-videmode
+		 *
+		 * 1. VGA       RGB 	   1024x768M-16@60
+		 * 2. TVE       YUV	   video_modes[0]
+		 */
+		mxc_fb_devices[1].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[1].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+		if (fb_data[0].mode_str || fb_data[0].mode)
+			/*
+			 * DI0 -> DC channel:
+			 *
+			 *    dev    di-out-fmt    default-videmode
+			 *
+			 * 1. WVGA      RGB 	   800x480M-16@55
+			 */
+			mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+	} else {
+		/*
+		 * DI0 -> DP-BG channel:
+		 *
+		 *    dev    di-out-fmt    default-videmode
+		 *
+		 * 1. WVGA      RGB 	   800x480M-16@55
+		 */
+		mxc_fb_devices[0].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[0].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+		if (fb_data[1].mode_str || fb_data[1].mode)
+			/*
+			 * DI1 -> DC channel:
+			 *
+			 *    dev    di-out-fmt    default-videmode
+			 *
+			 * 1. VGA       RGB 	   1024x768M-16@60
+			 * 2. TVE       YUV	   video_modes[0]
+			 */
+			mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+	}
+
+	/*
+	 * DI0/1 DP-FG channel:
+	 */
+	mxc_register_device(&mxc_fb_devices[2], NULL);
+
+	return 0;
+}
+device_initcall(mxc_init_fb);
+
+static int __init vga_setup(char *__unused)
+{
+	enable_vga = 1;
+	return 1;
+}
+__setup("vga", vga_setup);
+
+static int __init tv_setup(char *s)
+{
+	enable_tv = 1;
+	if (strcmp(s, "2") == 0 || strcmp(s, "=2") == 0)
+		enable_tv = 2;
+	return 1;
+}
+__setup("hdtv", tv_setup);
+
+static struct mxc_camera_platform_data camera_data = {
+	.io_regulator = "SW4",
+	.analog_regulator = "VIOHI",
+	.mclk = 24000000,
+	.csi = 0,
+};
+
+static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
+	{
+	.type = "ov3640",
+	.addr = 0x3C,
+	.platform_data = (void *)&camera_data,
+	 },
+};
+
+/* TO DO add platform data */
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "tsc2007",
+	 .addr = 0x48,
+	 .irq  = IOMUX_TO_IRQ(MX53_PIN_EIM_A25),
+	},
+	{
+	 .type = "backlight-i2c",
+	 .addr = 0x2c,
+	 },
+	{
+	 .type = "vga-ddc",
+	 .addr = 0x1f,
+	 },
+	{
+	 .type = "eeprom",
+	 .addr = 0x50,
+	 },
+};
+
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (to_platform_device(dev)->id == 0)
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_EIM_DA14));
+	else if (to_platform_device(dev)->id == 1)
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_GPIO_2));
+	else
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_EIM_DA12));
+
+	return rc;
+}
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_EIM_DA13));
+	} else if (to_platform_device(dev)->id == 1) {
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_GPIO_4));
+	} else{		/* config the det pin for SDHC3 */
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_EIM_DA11));
+		}
+
+	return ret;
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+
+static struct mxc_mmc_platform_data mmc3_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+/* TO DO */
+return 0;
+}
+
+static int headphone_det_status(void)
+{
+	return (gpio_get_value(IOMUX_TO_GPIO(MX53_PIN_ATA_DATA5)) == 0);
+}
+
+static int mxc_sgtl5000_init(void);
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 5,
+	.hp_irq = IOMUX_TO_IRQ(MX53_PIN_ATA_DATA5),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.init = mxc_sgtl5000_init,
+};
+
+static int mxc_sgtl5000_init(void)
+{
+	struct clk *ssi_ext1;
+	int rate;
+
+	ssi_ext1 = clk_get(NULL, "ssi_ext1_clk");
+	if (IS_ERR(ssi_ext1))
+		return -1;
+
+	rate = clk_round_rate(ssi_ext1, 12000000);
+	if (rate < 8000000 || rate > 27000000) {
+		printk(KERN_ERR "Error: SGTL5000 mclk freq %d out of range!\n",
+		       rate);
+		clk_put(ssi_ext1);
+		return -1;
+	}
+
+	clk_set_rate(ssi_ext1, rate);
+	clk_enable(ssi_ext1);
+	sgtl5000_data.sysclk = rate;
+
+	return 0;
+}
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	char *str;
+	int size = 0;
+	unsigned long orig_size;
+	struct tag *t;
+
+	mxc_set_cpu_type(MXC_CPU_MX53);
+
+	get_cpu_wp = mx53_evk_get_cpu_wp;
+	set_num_cpu_wp = mx53_evk_set_num_cpu_wp;
+
+	for_each_tag(t, tags) {
+		if (t->hdr.tag != ATAG_CMDLINE)
+			continue;
+		str = t->u.cmdline.cmdline;
+		str = strstr(str, "mem=");
+		if (str != NULL) {
+			str += 4;
+			size = memparse(str, &str);
+			if (size == 0 || size == SZ_512M)
+				return;
+		}
+	}
+
+	for_each_tag(t, tags) {
+		if (t->hdr.tag != ATAG_MEM)
+			continue;
+
+		orig_size = t->u.mem.size;
+		if (!size)
+			size = t->u.mem.size - SZ_32M;
+		t->u.mem.size = size;
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+		mxcfb_resources[0].start = t->u.mem.start + size;
+		mxcfb_resources[0].end = t->u.mem.start + orig_size - 1;
+		break;
+#endif
+	}
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+
+	/* SD card detect irqs */
+	mxcsdhc3_device.resource[2].start = IOMUX_TO_IRQ(MX53_PIN_EIM_DA11);
+	mxcsdhc3_device.resource[2].end = IOMUX_TO_IRQ(MX53_PIN_EIM_DA11);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ(MX53_PIN_EIM_DA13);
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ(MX53_PIN_EIM_DA13);
+
+	mxc_cpu_common_init();
+	mxc_register_gpios();
+	mx53_evk_io_init();
+
+	mxc_register_device(&mxc_dma_device, NULL);
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[2], &mxci2c_data);
+
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&mxc_ipu_device, &mxc_ipu_data);
+	mxc_register_device(&lcd_wvga_device, &lcd_wvga_data);
+	mxc_register_device(&mxc_tve_device, &tve_data);
+	mxc_register_device(&mxcvpu_device, NULL);
+	mxc_register_device(&gpu_device, NULL);
+	/*
+	mxc_register_device(&mx53_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&sdram_autogating_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	*/
+	mxc_register_device(&mxc_iim_device, NULL);
+	mxc_register_device(&mxc_pwm1_device, NULL);
+	mxc_register_device(&mxc_pwm_backlight_device, &mxc_pwm_backlight_data);
+/*	mxc_register_device(&mxc_keypad_device, &keypad_plat_data); */
+
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc3_device, &mmc3_data);
+	mxc_register_device(&mxc_ssi1_device, NULL);
+	mxc_register_device(&mxc_ssi2_device, NULL);
+	/*
+	mxc_register_device(&mxc_alsa_spdif_device, &mxc_spdif_data);
+	*/
+	mxc_register_device(&mxc_fec_device, NULL);
+
+/*
+	spi_register_board_info(mxc_spi_nor_device,
+					ARRAY_SIZE(mxc_spi_nor_device));
+*/
+
+	i2c_register_board_info(0, mxc_i2c0_board_info,
+				ARRAY_SIZE(mxc_i2c0_board_info));
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+
+	mx53_evk_init_mc13892();
+/*
+	pm_power_off = mxc_power_off;
+	*/
+
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+}
+
+static void __init mx53_evk_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	mx53_clocks_init(32768, 24000000, 22579200, 24576000);
+
+	uart_clk = clk_get(NULL, "uart_clk.0");
+	early_console_setup(MX53_BASE_ADDR(UART1_BASE_ADDR), uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx53_evk_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX53_EVK data structure.
+ */
+MACHINE_START(MX53_EVK, "Freescale MX53 EVK Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.fixup = fixup_mxc_board,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx53_evk_gpio.c b/arch/arm/mach-mx5/mx53_evk_gpio.c
new file mode 100644
index 0000000..f5cb20d
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_evk_gpio.c
@@ -0,0 +1,749 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "iomux.h"
+#include "mx53_pins.h"
+
+/*!
+ * @file mach-mx53/mx53_evk_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+static struct mxc_iomux_pin_cfg __initdata mxc_iomux_pins[] = {
+	{
+	 MX53_PIN_EIM_WAIT, IOMUX_CONFIG_ALT1,
+	 },
+	{
+	 MX53_PIN_EIM_OE, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_RW, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_A23, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_A24, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_A25, IOMUX_CONFIG_ALT6,
+	 },
+	{
+	 MX53_PIN_EIM_D16, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_EIM_D17, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_EIM_D18, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_EIM_D19, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_EIM_D20, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_D21, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_D22, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_D23, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_EIM_D24, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_D25, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_D26, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_D28, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_D29, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_EIM_D30, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_EIM_D31, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_EIM_DA11, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_DA12, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_DA13, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_DA14, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_EIM_DA15, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_NANDF_CS2, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_NANDF_CS3, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_ATA_BUFFER_EN, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_ATA_CS_0, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_ATA_CS_1, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_ATA_DA_1, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_ATA_DA_2, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_ATA_DATA4, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_ATA_DATA6, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_ATA_DATA7, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_ATA_DATA12, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_ATA_DATA13, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_ATA_DATA14, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_ATA_DATA15, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_ATA_DIOR, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_ATA_DIOW, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_ATA_DMACK, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_ATA_DMARQ, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_ATA_INTRQ, IOMUX_CONFIG_ALT3,
+	 },
+	{
+	 MX53_PIN_KEY_COL0, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_ROW0, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_COL1, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_ROW1, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_COL2, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_ROW2, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_COL3, IOMUX_CONFIG_ALT4,
+	 },
+	{
+	 MX53_PIN_KEY_COL4, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_KEY_ROW4, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX53_PIN_CSI0_D4, IOMUX_CONFIG_ALT5,
+	 },
+	{
+	 MX53_PIN_CSI0_D5, IOMUX_CONFIG_ALT5,
+	 },
+	{
+	 MX53_PIN_CSI0_D6, IOMUX_CONFIG_ALT5,
+	 },
+	{
+	 MX53_PIN_CSI0_D7, IOMUX_CONFIG_ALT5,
+	 },
+	{
+	 MX53_PIN_CSI0_D9, IOMUX_CONFIG_ALT5,
+	 },
+	{ /* UART1 Tx */
+	 MX53_PIN_CSI0_D10, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{ /* UART1 Rx */
+	 MX53_PIN_CSI0_D11, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	},
+	{
+	 MX53_PIN_CSI0_DATA_EN, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_1, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_2, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_3, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_4, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_5, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_6, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_7, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_8, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_10, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_11, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_12, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_13, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_14, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_16, IOMUX_CONFIG_ALT1,
+	 },
+	{
+	 MX53_PIN_GPIO_17, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_18, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX53_PIN_GPIO_19, IOMUX_CONFIG_ALT3,
+	 },
+	{	/* DI0 display clock */
+	 MX53_PIN_DI0_DISP_CLK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{	/* DI0 data enable */
+	 MX53_PIN_DI0_PIN15, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{	/* DI0 HSYNC */
+	 MX53_PIN_DI0_PIN2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{	/* DI0 VSYNC */
+	 MX53_PIN_DI0_PIN3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT4, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT5, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT6, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT7, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT8, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT9, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT10, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT11, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT12, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT13, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT14, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT15, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT16, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT17, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT18, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT19, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT20, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT21, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT22, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX53_PIN_DISP0_DAT23, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_NONE | PAD_CTL_ODE_OPENDRAIN_NONE |
+	  PAD_CTL_DRV_LOW | PAD_CTL_SRE_SLOW),
+	 },
+	{	/* gpio backlight */
+	 MX53_PIN_DI0_PIN4, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_DRV_HIGH | PAD_CTL_SRE_SLOW),
+	},
+	/* esdhc1 */
+	{
+	 MX53_PIN_SD1_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_SD1_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_SD1_DATA0, IOMUX_CONFIG_ALT0,
+	(PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	 {
+	 MX53_PIN_SD1_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	 {
+	 MX53_PIN_SD1_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	 {
+	 MX53_PIN_SD1_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	/* esdhc3 */
+	{
+	 MX53_PIN_ATA_DATA0, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA1, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA2, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA3, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA8, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA9, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA10, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_DATA11, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_IORDY, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX53_PIN_ATA_RESET_B, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_75k_PU | PAD_CTL_SRE_FAST),
+	 },
+	{ /* FEC pins */
+	 MX53_PIN_FEC_MDIO, IOMUX_CONFIG_ALT0,
+	 PAD_CTL_SRE_FAST,
+	 MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	 },
+	{
+	 MX53_PIN_FEC_REF_CLK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL),
+	 },
+	{
+	 MX53_PIN_FEC_RX_ER, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL),
+	 },
+	{
+	 MX53_PIN_FEC_CRS_DV, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL),
+	 },
+	{
+	 MX53_PIN_FEC_RXD1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL),
+	 },
+	{
+	 MX53_PIN_FEC_RXD0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL),
+	 },
+	{
+	 MX53_PIN_FEC_TX_EN, IOMUX_CONFIG_ALT0,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{
+	 MX53_PIN_FEC_TXD1, IOMUX_CONFIG_ALT0,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{
+	 MX53_PIN_FEC_TXD0, IOMUX_CONFIG_ALT0,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{
+	 MX53_PIN_FEC_MDC, IOMUX_CONFIG_ALT0,
+	 PAD_CTL_DRV_HIGH,
+	 },
+	{
+	MX53_PIN_ATA_DA_0, IOMUX_CONFIG_ALT1,
+	},
+	{ /* audio clock out */
+	 MX53_PIN_GPIO_0, IOMUX_CONFIG_ALT3,
+	 },
+};
+
+static int __initdata enable_w1 = { 0 };
+static int __init w1_setup(char *__unused)
+{
+	enable_w1 = 1;
+	return 1;
+}
+
+__setup("w1", w1_setup);
+
+void __init mx53_evk_io_init(void)
+{
+	int i;
+
+	/* Host1 Vbus with GPIO high */
+	mxc_iomux_set_pad(MX53_PIN_ATA_DA_2, PAD_CTL_DRV_HIGH |
+			PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_ATA_DA_2), "gpio7_8");
+	gpio_direction_output(IOMUX_TO_GPIO(MX53_PIN_ATA_DA_2), 1);
+
+	/* USB HUB RESET - De-assert USB HUB RESET_N */
+	mxc_iomux_set_pad(MX53_PIN_CSI0_DATA_EN, PAD_CTL_DRV_HIGH |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_CSI0_DATA_EN), "gpio5_20");
+	gpio_direction_output(IOMUX_TO_GPIO(MX53_PIN_CSI0_DATA_EN), 0);
+
+	msleep(1);
+	gpio_set_value(IOMUX_TO_GPIO(MX53_PIN_CSI0_DATA_EN), 0);
+	msleep(1);
+	gpio_set_value(IOMUX_TO_GPIO(MX53_PIN_CSI0_DATA_EN), 1);
+
+	/* Enable OTG VBus with GPIO low */
+	mxc_iomux_set_pad(MX53_PIN_EIM_A23, PAD_CTL_DRV_HIGH |
+			PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_EIM_A23), "gpio6_6");
+	gpio_direction_output(IOMUX_TO_GPIO(MX53_PIN_EIM_A23), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX53_PIN_EIM_A23), 0);
+
+	for (i = 0; i < ARRAY_SIZE(mxc_iomux_pins); i++) {
+		mxc_request_iomux(mxc_iomux_pins[i].pin,
+				  mxc_iomux_pins[i].mux_mode);
+		if (mxc_iomux_pins[i].pad_cfg)
+			mxc_iomux_set_pad(mxc_iomux_pins[i].pin,
+					  mxc_iomux_pins[i].pad_cfg);
+		if (mxc_iomux_pins[i].in_select)
+			mxc_iomux_set_input(mxc_iomux_pins[i].in_select,
+					    mxc_iomux_pins[i].in_mode);
+	}
+
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_GPIO_1), "gpio1_1");
+	gpio_direction_output(IOMUX_TO_GPIO(MX53_PIN_GPIO_1), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX53_PIN_GPIO_1), 1); /*BL*/
+
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_GPIO_16), "gpio7_11");
+	gpio_direction_input(IOMUX_TO_GPIO(MX53_PIN_GPIO_16));	/*PMIC_INT*/
+
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_EIM_DA13), "gpio3_13");
+	gpio_direction_input(IOMUX_TO_GPIO(MX53_PIN_EIM_DA13));	/* SD1 CD */
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_EIM_DA14), "gpio3_14");
+	gpio_direction_input(IOMUX_TO_GPIO(MX53_PIN_EIM_DA14));	/* SD1 WP */
+
+	/* SD3 CD */
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_EIM_DA11), "gpio3_11");
+	gpio_direction_input(IOMUX_TO_GPIO(MX53_PIN_EIM_DA11));
+
+	/* SD3 WP */
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_EIM_DA12), "gpio3_12");
+	gpio_direction_input(IOMUX_TO_GPIO(MX53_PIN_EIM_DA11));
+
+	/* reset FEC PHY */
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_ATA_DA_0), "gpio7_6");
+	gpio_direction_output(IOMUX_TO_GPIO(MX53_PIN_ATA_DA_0), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX53_PIN_ATA_DA_0), 0);
+	msleep(1);
+	gpio_set_value(IOMUX_TO_GPIO(MX53_PIN_ATA_DA_0), 1);
+
+
+	/* i2c1 SDA */
+	mxc_request_iomux(MX53_PIN_CSI0_D8,
+			  IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
+	mxc_iomux_set_input(MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+			    INPUT_CTL_PATH0);
+	mxc_iomux_set_pad(MX53_PIN_CSI0_D8, PAD_CTL_SRE_FAST |
+			  PAD_CTL_ODE_OPENDRAIN_ENABLE |
+			  PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+			  PAD_CTL_HYS_ENABLE);
+
+	/* i2c1 SCL */
+	mxc_request_iomux(MX53_PIN_CSI0_D9,
+			  IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
+	mxc_iomux_set_input(MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+			    INPUT_CTL_PATH0);
+	mxc_iomux_set_pad(MX53_PIN_CSI0_D9, PAD_CTL_SRE_FAST |
+			  PAD_CTL_ODE_OPENDRAIN_ENABLE |
+			  PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+			  PAD_CTL_HYS_ENABLE);
+
+	/* i2c2 SDA */
+	mxc_request_iomux(MX53_PIN_KEY_ROW3,
+			  IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+	mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+			    INPUT_CTL_PATH0);
+	mxc_iomux_set_pad(MX53_PIN_KEY_ROW3,
+			  PAD_CTL_SRE_FAST |
+			  PAD_CTL_ODE_OPENDRAIN_ENABLE |
+			  PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+			  PAD_CTL_HYS_ENABLE);
+
+	/* i2c2 SCL */
+	mxc_request_iomux(MX53_PIN_KEY_COL3,
+			  IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+	mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+			    INPUT_CTL_PATH0);
+	mxc_iomux_set_pad(MX53_PIN_KEY_COL3,
+			  PAD_CTL_SRE_FAST |
+			  PAD_CTL_ODE_OPENDRAIN_ENABLE |
+			  PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+			  PAD_CTL_HYS_ENABLE);
+
+	/* headphone_det_b */
+	mxc_request_iomux(MX53_PIN_ATA_DATA5, IOMUX_CONFIG_GPIO);
+	mxc_iomux_set_pad(MX53_PIN_ATA_DATA5, PAD_CTL_100K_PU);
+	gpio_request(IOMUX_TO_GPIO(MX53_PIN_ATA_DATA5), "gpio2_5");
+	gpio_direction_input(IOMUX_TO_GPIO(MX53_PIN_ATA_DATA5));
+
+	/* power key */
+
+	/* LCD related gpio */
+
+	/* Camera reset */
+
+	/* Camera low power */
+
+}
+
+/* workaround for ecspi chipselect pin may not keep correct level when idle */
+void mx53_evk_gpio_spi_chipselect_active(int cspi_mode, int status,
+					     int chipselect)
+{
+	u32 gpio;
+
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			mxc_request_iomux(MX53_PIN_EIM_D19,
+					  IOMUX_CONFIG_ALT4);
+			mxc_iomux_set_pad(MX53_PIN_EIM_D19,
+					  PAD_CTL_HYS_ENABLE |
+					  PAD_CTL_PKE_ENABLE |
+					  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST);
+			break;
+		case 0x2:
+			gpio = IOMUX_TO_GPIO(MX53_PIN_EIM_D19);
+			mxc_request_iomux(MX53_PIN_EIM_D19,
+					  IOMUX_CONFIG_GPIO);
+			gpio_request(gpio, "cspi1_ss1");
+			gpio_direction_output(gpio, 0);
+			gpio_set_value(gpio, 1 & (~status));
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(mx53_evk_gpio_spi_chipselect_active);
+
+void mx53_evk_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+					       int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			mxc_free_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_EIM_D19,
+					  IOMUX_CONFIG_GPIO);
+			mxc_free_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_GPIO);
+			break;
+		case 0x2:
+			mxc_free_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_GPIO);
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(mx53_evk_gpio_spi_chipselect_inactive);
+
+void gpio_lcd_active(void)
+{
+/* TO DO */
+}
+EXPORT_SYMBOL(gpio_lcd_active);
diff --git a/arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c b/arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c
new file mode 100644
index 0000000..805b3e5
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c
@@ -0,0 +1,353 @@
+/*
+ * mx53-evk-pmic-mc13892.c  --  i.MX53 3STACK Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+#include "mx53_pins.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+#define STANDBYSECINV_LSH 11
+#define STANDBYSECINV_WID 1
+
+/* Coin cell charger enable */
+#define CIONCHEN_LSH	23
+#define CIONCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+/*!
+ * the event handler for power on event
+ */
+static void power_on_evt_handler(void)
+{
+	pr_info("pwr on event1 is received \n");
+}
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value;
+	pmic_event_callback_t power_key_event;
+	int register_mask;
+
+	printk("Initializing regulators for 3-stack.\n");
+	if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
+		sw2_init.constraints.state_mem.uV = 1100000;
+	else if (mxc_cpu_is_rev(CHIP_REV_2_0) == 1) {
+		sw2_init.constraints.state_mem.uV = 1250000;
+		sw1_init.constraints.state_mem.uV = 1000000;
+	}
+
+	/* subscribe PWRON1 event to enable ON_OFF key */
+	power_key_event.param = NULL;
+	power_key_event.func = (void *)power_on_evt_handler;
+	pmic_event_subscribe(EVENT_PWRONI, power_key_event);
+
+	/* Bit 4 DRM: keep VSRTC and CLK32KMCU on for all states */
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+	/* Set the STANDBYSECINV bit, so that STANDBY pin is
+	 * interpreted as active low.
+	 */
+	value = BITFVAL(STANDBYSECINV, 1);
+	register_mask = BITFMASK(STANDBYSECINV);
+	pmic_write_reg(REG_POWER_CTL2, value, register_mask);
+
+	/* Enable coin cell charger */
+	value = BITFVAL(CIONCHEN, 1) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(CIONCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc13892_i2c_device = {
+	I2C_BOARD_INFO("mc13892", 0x08),
+	.irq = IOMUX_TO_IRQ(MX53_PIN_GPIO_16),
+	.platform_data = &mc13892_plat,
+};
+
+int __init mx53_evk_init_mc13892(void)
+{
+	return i2c_register_board_info(1, &mc13892_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx5/mx53_pins.h b/arch/arm/mach-mx5/mx53_pins.h
new file mode 100644
index 0000000..bf83e98
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_pins.h
@@ -0,0 +1,421 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_MXC_MX53_PINS_H__
+#define __ASM_ARCH_MXC_MX53_PINS_H__
+#include "iomux.h"
+
+/*!
+ * @file arch-mxc/mx53_pins.h
+ *
+ * @brief MX53 I/O Pin List
+ *
+ * @ingroup GPIO_MX53
+ */
+
+#ifndef __ASSEMBLY__
+
+#define PAD_I_START_MX53		0x348
+
+#define _MXC_BUILD_PIN_MX53(gp, gi, ga, mi, pi) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+	((mi) << MUX_I) | \
+	((pi - PAD_I_START_MX53) << PAD_I) | \
+	((ga) << GPIO_I))
+
+#define _MXC_BUILD_GPIO_PIN_MX53(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN_MX53(gp, gi, ga, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN_MX53(mi, pi) \
+    _MXC_BUILD_PIN_MX53(NON_GPIO_PORT, 0, 0, mi, pi)
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX53 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+enum iomux_pins {
+	MX53_PIN_GPIO_19 = _MXC_BUILD_GPIO_PIN_MX53(3, 5, 1, 0x20, 0x348),
+	MX53_PIN_KEY_COL0 = _MXC_BUILD_GPIO_PIN_MX53(3, 6, 1, 0x24, 0x34C),
+	MX53_PIN_KEY_ROW0 = _MXC_BUILD_GPIO_PIN_MX53(3, 7, 1, 0x28, 0x350),
+	MX53_PIN_KEY_COL1 = _MXC_BUILD_GPIO_PIN_MX53(3, 8, 1, 0x2C, 0x354),
+	MX53_PIN_KEY_ROW1 = _MXC_BUILD_GPIO_PIN_MX53(3, 9, 1, 0x30, 0x358),
+	MX53_PIN_KEY_COL2 = _MXC_BUILD_GPIO_PIN_MX53(3, 10, 1, 0x34, 0x35C),
+	MX53_PIN_KEY_ROW2 = _MXC_BUILD_GPIO_PIN_MX53(3, 11, 1, 0x38, 0x360),
+	MX53_PIN_KEY_COL3 = _MXC_BUILD_GPIO_PIN_MX53(3, 12, 1, 0x3C, 0x364),
+	MX53_PIN_KEY_ROW3 = _MXC_BUILD_GPIO_PIN_MX53(3, 13, 1, 0x40, 0x368),
+	MX53_PIN_KEY_COL4 = _MXC_BUILD_GPIO_PIN_MX53(3, 14, 1, 0x44, 0x36C),
+	MX53_PIN_KEY_ROW4 = _MXC_BUILD_GPIO_PIN_MX53(3, 15, 1, 0x48, 0x370),
+	MX53_PIN_NVCC_KEYPAD = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x374),
+	MX53_PIN_DI0_DISP_CLK = _MXC_BUILD_GPIO_PIN_MX53(3, 16, 1, 0x4C, 0x378),
+	MX53_PIN_DI0_PIN15 = _MXC_BUILD_GPIO_PIN_MX53(3, 17, 1, 0x50, 0x37C),
+	MX53_PIN_DI0_PIN2 = _MXC_BUILD_GPIO_PIN_MX53(3, 18, 1, 0x54, 0x380),
+	MX53_PIN_DI0_PIN3 = _MXC_BUILD_GPIO_PIN_MX53(3, 19, 1, 0x58, 0x384),
+	MX53_PIN_DI0_PIN4 = _MXC_BUILD_GPIO_PIN_MX53(3, 20, 1, 0x5C, 0x388),
+	MX53_PIN_DISP0_DAT0 = _MXC_BUILD_GPIO_PIN_MX53(3, 21, 1, 0x60, 0x38C),
+	MX53_PIN_DISP0_DAT1 = _MXC_BUILD_GPIO_PIN_MX53(3, 22, 1, 0x64, 0x390),
+	MX53_PIN_DISP0_DAT2 = _MXC_BUILD_GPIO_PIN_MX53(3, 23, 1, 0x68, 0x394),
+	MX53_PIN_DISP0_DAT3 = _MXC_BUILD_GPIO_PIN_MX53(3, 24, 1, 0x6C, 0x398),
+	MX53_PIN_DISP0_DAT4 = _MXC_BUILD_GPIO_PIN_MX53(3, 25, 1, 0x70, 0x39C),
+	MX53_PIN_DISP0_DAT5 = _MXC_BUILD_GPIO_PIN_MX53(3, 26, 1, 0x74, 0x3A0),
+	MX53_PIN_DISP0_DAT6 = _MXC_BUILD_GPIO_PIN_MX53(3, 27, 1, 0x78, 0x3A4),
+	MX53_PIN_DISP0_DAT7 = _MXC_BUILD_GPIO_PIN_MX53(3, 28, 1, 0x7C, 0x3A8),
+	MX53_PIN_DISP0_DAT8 = _MXC_BUILD_GPIO_PIN_MX53(3, 29, 1, 0x80, 0x3AC),
+	MX53_PIN_DISP0_DAT9 = _MXC_BUILD_GPIO_PIN_MX53(3, 30, 1, 0x84, 0x3B0),
+	MX53_PIN_DISP0_DAT10 = _MXC_BUILD_GPIO_PIN_MX53(3, 31, 1, 0x88, 0x3B4),
+	MX53_PIN_DISP0_DAT11 = _MXC_BUILD_GPIO_PIN_MX53(4, 5, 1, 0x8C, 0x3B8),
+	MX53_PIN_DISP0_DAT12 = _MXC_BUILD_GPIO_PIN_MX53(4, 6, 1, 0x90, 0x3BC),
+	MX53_PIN_DISP0_DAT13 = _MXC_BUILD_GPIO_PIN_MX53(4, 7, 1, 0x94, 0x3C0),
+	MX53_PIN_DISP0_DAT14 = _MXC_BUILD_GPIO_PIN_MX53(4, 8, 1, 0x98, 0x3C4),
+	MX53_PIN_DISP0_DAT15 = _MXC_BUILD_GPIO_PIN_MX53(4, 9, 1, 0x9C, 0x3C8),
+	MX53_PIN_DISP0_DAT16 = _MXC_BUILD_GPIO_PIN_MX53(4, 10, 1, 0xA0, 0x3CC),
+	MX53_PIN_DISP0_DAT17 = _MXC_BUILD_GPIO_PIN_MX53(4, 11, 1, 0xA4, 0x3D0),
+	MX53_PIN_DISP0_DAT18 = _MXC_BUILD_GPIO_PIN_MX53(4, 12, 1, 0xA8, 0x3D4),
+	MX53_PIN_DISP0_DAT19 = _MXC_BUILD_GPIO_PIN_MX53(4, 13, 1, 0xAC, 0x3D8),
+	MX53_PIN_DISP0_DAT20 = _MXC_BUILD_GPIO_PIN_MX53(4, 14, 1, 0xB0, 0x3DC),
+	MX53_PIN_DISP0_DAT21 = _MXC_BUILD_GPIO_PIN_MX53(4, 15, 1, 0xB4, 0x3E0),
+	MX53_PIN_DISP0_DAT22 = _MXC_BUILD_GPIO_PIN_MX53(4, 16, 1, 0xB8, 0x3E4),
+	MX53_PIN_DISP0_DAT23 = _MXC_BUILD_GPIO_PIN_MX53(4, 17, 1, 0xBC, 0x3E8),
+	MX53_PIN_CSI0_PIXCLK = _MXC_BUILD_GPIO_PIN_MX53(4, 18, 1, 0xC0, 0x3EC),
+	MX53_PIN_CSI0_MCLK = _MXC_BUILD_GPIO_PIN_MX53(4, 19, 1, 0xC4, 0x3F0),
+	MX53_PIN_CSI0_DATA_EN = _MXC_BUILD_GPIO_PIN_MX53(4, 20, 1, 0xC8, 0x3F4),
+	MX53_PIN_CSI0_VSYNC = _MXC_BUILD_GPIO_PIN_MX53(4, 21, 1, 0xCC, 0x3F8),
+	MX53_PIN_CSI0_D4 = _MXC_BUILD_GPIO_PIN_MX53(4, 22, 1, 0xD0, 0x3FC),
+	MX53_PIN_CSI0_D5 = _MXC_BUILD_GPIO_PIN_MX53(4, 23, 1, 0xD4, 0x400),
+	MX53_PIN_CSI0_D6 = _MXC_BUILD_GPIO_PIN_MX53(4, 24, 1, 0xD8, 0x404),
+	MX53_PIN_CSI0_D7 = _MXC_BUILD_GPIO_PIN_MX53(4, 25, 1, 0xDC, 0x408),
+	MX53_PIN_CSI0_D8 = _MXC_BUILD_GPIO_PIN_MX53(4, 26, 1, 0xE0, 0x40C),
+	MX53_PIN_CSI0_D9 = _MXC_BUILD_GPIO_PIN_MX53(4, 27, 1, 0xE4, 0x410),
+	MX53_PIN_CSI0_D10 = _MXC_BUILD_GPIO_PIN_MX53(4, 28, 1, 0xE8, 0x414),
+	MX53_PIN_CSI0_D11 = _MXC_BUILD_GPIO_PIN_MX53(4, 29, 1, 0xEC, 0x418),
+	MX53_PIN_CSI0_D12 = _MXC_BUILD_GPIO_PIN_MX53(4, 30, 1, 0xF0, 0x41C),
+	MX53_PIN_CSI0_D13 = _MXC_BUILD_GPIO_PIN_MX53(4, 31, 1, 0xF4, 0x420),
+	MX53_PIN_CSI0_D14 = _MXC_BUILD_GPIO_PIN_MX53(5, 0, 1, 0xF8, 0x424),
+	MX53_PIN_CSI0_D15 = _MXC_BUILD_GPIO_PIN_MX53(5, 1, 1, 0xFC, 0x428),
+	MX53_PIN_CSI0_D16 = _MXC_BUILD_GPIO_PIN_MX53(5, 2, 1, 0x100, 0x42C),
+	MX53_PIN_CSI0_D17 = _MXC_BUILD_GPIO_PIN_MX53(5, 3, 1, 0x104, 0x430),
+	MX53_PIN_CSI0_D18 = _MXC_BUILD_GPIO_PIN_MX53(5, 4, 1, 0x108, 0x434),
+	MX53_PIN_CSI0_D19 = _MXC_BUILD_GPIO_PIN_MX53(5, 5, 1, 0x10C, 0x438),
+	MX53_PIN_NVCC_CSI0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x43C),
+	MX53_PIN_JTAG_TMS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x440),
+	MX53_PIN_JTAG_MOD = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x444),
+	MX53_PIN_JTAG_TRSTB = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x448),
+	MX53_PIN_JTAG_TDI = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x44C),
+	MX53_PIN_JTAG_TCK = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x450),
+	MX53_PIN_JTAG_TDO = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x454),
+	MX53_PIN_EIM_A25 = _MXC_BUILD_GPIO_PIN_MX53(4, 2, 1, 0x110, 0x458),
+	MX53_PIN_EIM_EB2 = _MXC_BUILD_GPIO_PIN_MX53(1, 30, 1, 0x114, 0x45C),
+	MX53_PIN_EIM_D16 = _MXC_BUILD_GPIO_PIN_MX53(2, 16, 1, 0x118, 0x460),
+	MX53_PIN_EIM_D17 = _MXC_BUILD_GPIO_PIN_MX53(2, 17, 1, 0x11C, 0x464),
+	MX53_PIN_EIM_D18 = _MXC_BUILD_GPIO_PIN_MX53(2, 18, 1, 0x120, 0x468),
+	MX53_PIN_EIM_D19 = _MXC_BUILD_GPIO_PIN_MX53(2, 19, 1, 0x124, 0x46C),
+	MX53_PIN_EIM_D20 = _MXC_BUILD_GPIO_PIN_MX53(2, 20, 1, 0x128, 0x470),
+	MX53_PIN_EIM_D21 = _MXC_BUILD_GPIO_PIN_MX53(2, 21, 1, 0x12C, 0x474),
+	MX53_PIN_EIM_D22 = _MXC_BUILD_GPIO_PIN_MX53(2, 22, 1, 0x130, 0x478),
+	MX53_PIN_EIM_D23 = _MXC_BUILD_GPIO_PIN_MX53(2, 23, 1, 0x134, 0x47C),
+	MX53_PIN_EIM_EB3 = _MXC_BUILD_GPIO_PIN_MX53(1, 31, 1, 0x138, 0x480),
+	MX53_PIN_EIM_D24 = _MXC_BUILD_GPIO_PIN_MX53(2, 24, 1, 0x13C, 0x484),
+	MX53_PIN_EIM_D25 = _MXC_BUILD_GPIO_PIN_MX53(2, 25, 1, 0x140, 0x488),
+	MX53_PIN_EIM_D26 = _MXC_BUILD_GPIO_PIN_MX53(2, 26, 1, 0x144, 0x48C),
+	MX53_PIN_EIM_D27 = _MXC_BUILD_GPIO_PIN_MX53(2, 27, 1, 0x148, 0x490),
+	MX53_PIN_EIM_D28 = _MXC_BUILD_GPIO_PIN_MX53(2, 28, 1, 0x14C, 0x494),
+	MX53_PIN_EIM_D29 = _MXC_BUILD_GPIO_PIN_MX53(2, 29, 1, 0x150, 0x498),
+	MX53_PIN_EIM_D30 = _MXC_BUILD_GPIO_PIN_MX53(2, 30, 1, 0x154, 0x49C),
+	MX53_PIN_EIM_D31 = _MXC_BUILD_GPIO_PIN_MX53(2, 31, 1, 0x158, 0x4A0),
+	MX53_PIN_NVCC_EIM1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x4A4),
+	MX53_PIN_EIM_A24 = _MXC_BUILD_GPIO_PIN_MX53(4, 4, 1, 0x15C, 0x4A8),
+	MX53_PIN_EIM_A23 = _MXC_BUILD_GPIO_PIN_MX53(5, 6, 1, 0x160, 0x4AC),
+	MX53_PIN_EIM_A22 = _MXC_BUILD_GPIO_PIN_MX53(1, 16, 1, 0x164, 0x4B0),
+	MX53_PIN_EIM_A21 = _MXC_BUILD_GPIO_PIN_MX53(1, 17, 1, 0x168, 0x4B4),
+	MX53_PIN_EIM_A20 = _MXC_BUILD_GPIO_PIN_MX53(1, 18, 1, 0x16C, 0x4B8),
+	MX53_PIN_EIM_A19 = _MXC_BUILD_GPIO_PIN_MX53(1, 19, 1, 0x170, 0x4BC),
+	MX53_PIN_EIM_A18 = _MXC_BUILD_GPIO_PIN_MX53(1, 20, 1, 0x174, 0x4C0),
+	MX53_PIN_EIM_A17 = _MXC_BUILD_GPIO_PIN_MX53(1, 21, 1, 0x178, 0x4C4),
+	MX53_PIN_EIM_A16 = _MXC_BUILD_GPIO_PIN_MX53(1, 22, 1, 0x17C, 0x4C8),
+	MX53_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN_MX53(1, 23, 1, 0x180, 0x4CC),
+	MX53_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN_MX53(1, 24, 1, 0x184, 0x4D0),
+	MX53_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN_MX53(1, 25, 1, 0x188, 0x4D4),
+	MX53_PIN_EIM_RW = _MXC_BUILD_GPIO_PIN_MX53(1, 26, 1, 0x18C, 0x4D8),
+	MX53_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN_MX53(1, 27, 1, 0x190, 0x4DC),
+	MX53_PIN_NVCC_EIM4 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x4E0),
+	MX53_PIN_EIM_EB0 = _MXC_BUILD_GPIO_PIN_MX53(1, 28, 1, 0x194, 0x4E4),
+	MX53_PIN_EIM_EB1 = _MXC_BUILD_GPIO_PIN_MX53(1, 29, 1, 0x198, 0x4E8),
+	MX53_PIN_EIM_DA0 = _MXC_BUILD_GPIO_PIN_MX53(2, 0, 1, 0x19C, 0x4EC),
+	MX53_PIN_EIM_DA1 = _MXC_BUILD_GPIO_PIN_MX53(2, 1, 1, 0x1A0, 0x4F0),
+	MX53_PIN_EIM_DA2 = _MXC_BUILD_GPIO_PIN_MX53(2, 2, 1, 0x1A4, 0x4F4),
+	MX53_PIN_EIM_DA3 = _MXC_BUILD_GPIO_PIN_MX53(2, 3, 1, 0x1A8, 0x4F8),
+	MX53_PIN_EIM_DA4 = _MXC_BUILD_GPIO_PIN_MX53(2, 4, 1, 0x1AC, 0x4FC),
+	MX53_PIN_EIM_DA5 = _MXC_BUILD_GPIO_PIN_MX53(2, 5, 1, 0x1B0, 0x500),
+	MX53_PIN_EIM_DA6 = _MXC_BUILD_GPIO_PIN_MX53(2, 6, 1, 0x1B4, 0x504),
+	MX53_PIN_EIM_DA7 = _MXC_BUILD_GPIO_PIN_MX53(2, 7, 1, 0x1B8, 0x508),
+	MX53_PIN_EIM_DA8 = _MXC_BUILD_GPIO_PIN_MX53(2, 8, 1, 0x1BC, 0x50C),
+	MX53_PIN_EIM_DA9 = _MXC_BUILD_GPIO_PIN_MX53(2, 9, 1, 0x1C0, 0x510),
+	MX53_PIN_EIM_DA10 = _MXC_BUILD_GPIO_PIN_MX53(2, 10, 1, 0x1C4, 0x514),
+	MX53_PIN_EIM_DA11 = _MXC_BUILD_GPIO_PIN_MX53(2, 11, 1, 0x1C8, 0x518),
+	MX53_PIN_EIM_DA12 = _MXC_BUILD_GPIO_PIN_MX53(2, 12, 1, 0x1CC, 0x51C),
+	MX53_PIN_EIM_DA13 = _MXC_BUILD_GPIO_PIN_MX53(2, 13, 1, 0x1D0, 0x520),
+	MX53_PIN_EIM_DA14 = _MXC_BUILD_GPIO_PIN_MX53(2, 14, 1, 0x1D4, 0x524),
+	MX53_PIN_EIM_DA15 = _MXC_BUILD_GPIO_PIN_MX53(2, 15, 1, 0x1D8, 0x528),
+	MX53_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN_MX53(5, 12, 1, 0x1DC, 0x52C),
+	MX53_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN_MX53(5, 13, 1, 0x1E0, 0x530),
+	MX53_PIN_EIM_WAIT = _MXC_BUILD_GPIO_PIN_MX53(4, 0, 1, 0x1E4, 0x534),
+	MX53_PIN_EIM_BCLK = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x538),
+	MX53_PIN_NVCC_EIM7 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x53C),
+	MX53_PIN_LVDS1_TX3_P = _MXC_BUILD_GPIO_PIN_MX53(5, 22, 0, 0x1EC, NON_PAD_I),
+	MX53_PIN_LVDS1_TX2_P = _MXC_BUILD_GPIO_PIN_MX53(5, 24, 0, 0x1F0, NON_PAD_I),
+	MX53_PIN_LVDS1_CLK_P = _MXC_BUILD_GPIO_PIN_MX53(5, 26, 0, 0x1F4, NON_PAD_I),
+	MX53_PIN_LVDS1_TX1_P = _MXC_BUILD_GPIO_PIN_MX53(5, 28, 0, 0x1F8, NON_PAD_I),
+	MX53_PIN_LVDS1_TX0_P = _MXC_BUILD_GPIO_PIN_MX53(5, 30, 0, 0x1FC, NON_PAD_I),
+	MX53_PIN_LVDS0_TX3_P = _MXC_BUILD_GPIO_PIN_MX53(6, 22, 0, 0x200, NON_PAD_I),
+	MX53_PIN_LVDS0_CLK_P = _MXC_BUILD_GPIO_PIN_MX53(6, 24, 0, 0x204, NON_PAD_I),
+	MX53_PIN_LVDS0_TX2_P = _MXC_BUILD_GPIO_PIN_MX53(6, 26, 0, 0x208, NON_PAD_I),
+	MX53_PIN_LVDS0_TX1_P = _MXC_BUILD_GPIO_PIN_MX53(6, 28, 0, 0x20C, NON_PAD_I),
+	MX53_PIN_LVDS0_TX0_P = _MXC_BUILD_GPIO_PIN_MX53(6, 30, 0, 0x210, NON_PAD_I),
+	MX53_PIN_GPIO_10 = _MXC_BUILD_GPIO_PIN_MX53(3, 0, 0, 0x214, 0x540),
+	MX53_PIN_GPIO_11 = _MXC_BUILD_GPIO_PIN_MX53(3, 1, 0, 0x218, 0x544),
+	MX53_PIN_GPIO_12 = _MXC_BUILD_GPIO_PIN_MX53(3, 2, 0, 0x21C, 0x548),
+	MX53_PIN_GPIO_13 = _MXC_BUILD_GPIO_PIN_MX53(3, 3, 0, 0x220, 0x54C),
+	MX53_PIN_GPIO_14 = _MXC_BUILD_GPIO_PIN_MX53(3, 4, 0, 0x224, 0x550),
+	MX53_PIN_DRAM_DQM3 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x554),
+	MX53_PIN_DRAM_SDQS3 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x558),
+	MX53_PIN_DRAM_SDCKE1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x55C),
+	MX53_PIN_DRAM_DQM2 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x560),
+	MX53_PIN_DRAM_SDODT1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x564),
+	MX53_PIN_DRAM_SDQS2 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x568),
+	MX53_PIN_DRAM_RESET = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x56C),
+	MX53_PIN_DRAM_SDCLK1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x570),
+	MX53_PIN_DRAM_CAS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x574),
+	MX53_PIN_DRAM_SDCLK0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x578),
+	MX53_PIN_DRAM_SDQS0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x57C),
+	MX53_PIN_DRAM_SDODT0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x580),
+	MX53_PIN_DRAM_DQM0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x584),
+	MX53_PIN_DRAM_RAS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x588),
+	MX53_PIN_DRAM_SDCKE0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x58C),
+	MX53_PIN_DRAM_SDQS1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x590),
+	MX53_PIN_DRAM_DQM1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x594),
+	MX53_PIN_PMIC_ON_REQ = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x598),
+	MX53_PIN_PMIC_STBY_REQ = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x59C),
+	MX53_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN_MX53(5, 7, 1, 0x228, 0x5A0),
+	MX53_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN_MX53(5, 8 , 1, 0x22C, 0x5A4),
+	MX53_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN_MX53(5, 9, 1, 0x230, 0x5A8),
+	MX53_PIN_NANDF_RB0 = _MXC_BUILD_GPIO_PIN_MX53(5, 10, 1, 0x234, 0x5AC),
+	MX53_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN_MX53(5, 11, 1, 0x238, 0x5B0),
+	MX53_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN_MX53(5, 14, 1, 0x23C, 0x5B4),
+	MX53_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN_MX53(5, 15, 1, 0x240, 0x5B8),
+	MX53_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN_MX53(5, 16, 1, 0x244, 0x5BC),
+	MX53_PIN_NVCC_NANDF = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x5C0),
+	MX53_PIN_FEC_MDIO = _MXC_BUILD_GPIO_PIN_MX53(0, 22, 1, 0x248, 0x5C4),
+	MX53_PIN_FEC_REF_CLK = _MXC_BUILD_GPIO_PIN_MX53(0, 23, 1, 0x24C, 0x5C8),
+	MX53_PIN_FEC_RX_ER = _MXC_BUILD_GPIO_PIN_MX53(0, 24, 1, 0x250, 0x5CC),
+	MX53_PIN_FEC_CRS_DV = _MXC_BUILD_GPIO_PIN_MX53(0, 25, 1, 0x254, 0x5D0),
+	MX53_PIN_FEC_RXD1 = _MXC_BUILD_GPIO_PIN_MX53(0, 26, 1, 0x258, 0x5D4),
+	MX53_PIN_FEC_RXD0 = _MXC_BUILD_GPIO_PIN_MX53(0, 27, 1, 0x25C, 0x5D8),
+	MX53_PIN_FEC_TX_EN = _MXC_BUILD_GPIO_PIN_MX53(0, 28, 1, 0x260, 0x5DC),
+	MX53_PIN_FEC_TXD1 = _MXC_BUILD_GPIO_PIN_MX53(0, 29, 1, 0x264, 0x5E0),
+	MX53_PIN_FEC_TXD0 = _MXC_BUILD_GPIO_PIN_MX53(0, 30, 1, 0x268, 0x5E4),
+	MX53_PIN_FEC_MDC = _MXC_BUILD_GPIO_PIN_MX53(0, 31, 1, 0x26C, 0x5E8),
+	MX53_PIN_NVCC_FEC = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x5EC),
+	MX53_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN_MX53(5, 17, 1, 0x270, 0x5F0),
+	MX53_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN_MX53(5, 18, 1, 0x274, 0x5F4),
+	MX53_PIN_ATA_DMARQ = _MXC_BUILD_GPIO_PIN_MX53(6, 0, 1, 0x278, 0x5F8),
+	MX53_PIN_ATA_BUFFER_EN = _MXC_BUILD_GPIO_PIN_MX53(6, 1, 1, 0x27C, 0x5FC),
+	MX53_PIN_ATA_INTRQ = _MXC_BUILD_GPIO_PIN_MX53(6, 2, 1, 0x280, 0x600),
+	MX53_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN_MX53(6, 3, 1, 0x284, 0x604),
+	MX53_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN_MX53(6, 4, 1, 0x288, 0x608),
+	MX53_PIN_ATA_IORDY = _MXC_BUILD_GPIO_PIN_MX53(6, 5, 1, 0x28C, 0x60C),
+	MX53_PIN_ATA_DA_0 = _MXC_BUILD_GPIO_PIN_MX53(6, 6, 1, 0x290, 0x610),
+	MX53_PIN_ATA_DA_1 = _MXC_BUILD_GPIO_PIN_MX53(6, 7, 1, 0x294, 0x614),
+	MX53_PIN_ATA_DA_2 = _MXC_BUILD_GPIO_PIN_MX53(6, 8, 1, 0x298, 0x618),
+	MX53_PIN_ATA_CS_0 = _MXC_BUILD_GPIO_PIN_MX53(6, 9, 1, 0x29C, 0x61C),
+	MX53_PIN_ATA_CS_1 = _MXC_BUILD_GPIO_PIN_MX53(6, 10, 1, 0x2A0, 0x620),
+	MX53_PIN_NVCC_ATA2 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x624),
+	MX53_PIN_ATA_DATA0 = _MXC_BUILD_GPIO_PIN_MX53(1, 0, 1, 0x2A4, 0x628),
+	MX53_PIN_ATA_DATA1 = _MXC_BUILD_GPIO_PIN_MX53(1, 1, 1, 0x2A8, 0x62C),
+	MX53_PIN_ATA_DATA2 = _MXC_BUILD_GPIO_PIN_MX53(1, 2, 1, 0x2AC, 0x630),
+	MX53_PIN_ATA_DATA3 = _MXC_BUILD_GPIO_PIN_MX53(1, 3, 1, 0x2B0, 0x634),
+	MX53_PIN_ATA_DATA4 = _MXC_BUILD_GPIO_PIN_MX53(1, 4, 1, 0x2B4, 0x638),
+	MX53_PIN_ATA_DATA5 = _MXC_BUILD_GPIO_PIN_MX53(1, 5, 1, 0x2B8, 0x63C),
+	MX53_PIN_ATA_DATA6 = _MXC_BUILD_GPIO_PIN_MX53(1, 6, 1, 0x2BC, 0x640),
+	MX53_PIN_ATA_DATA7 = _MXC_BUILD_GPIO_PIN_MX53(1, 7, 1, 0x2C0, 0x644),
+	MX53_PIN_ATA_DATA8 = _MXC_BUILD_GPIO_PIN_MX53(1, 8, 1, 0x2C4, 0x648),
+	MX53_PIN_ATA_DATA9 = _MXC_BUILD_GPIO_PIN_MX53(1, 9, 1, 0x2C8, 0x64C),
+	MX53_PIN_ATA_DATA10 = _MXC_BUILD_GPIO_PIN_MX53(1, 10, 1, 0x2CC, 0x650),
+	MX53_PIN_ATA_DATA11 = _MXC_BUILD_GPIO_PIN_MX53(1, 11, 1, 0x2D0, 0x654),
+	MX53_PIN_ATA_DATA12 = _MXC_BUILD_GPIO_PIN_MX53(1, 12, 1, 0x2D4, 0x658),
+	MX53_PIN_ATA_DATA13 = _MXC_BUILD_GPIO_PIN_MX53(1, 13, 1, 0x2D8, 0x65C),
+	MX53_PIN_ATA_DATA14 = _MXC_BUILD_GPIO_PIN_MX53(1, 14, 1, 0x2DC, 0x660),
+	MX53_PIN_ATA_DATA15 = _MXC_BUILD_GPIO_PIN_MX53(1, 15, 1, 0x2E0, 0x664),
+	MX53_PIN_NVCC_ATA0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x668),
+	MX53_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN_MX53(0, 16, 1, 0x2E4, 0x66C),
+	MX53_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN_MX53(0, 17, 1, 0x2E8, 0x670),
+	MX53_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN_MX53(0, 18, 1, 0x2EC, 0x674),
+	MX53_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN_MX53(0, 19, 1, 0x2F0, 0x678),
+	MX53_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN_MX53(0, 20, 1, 0x2F4, 0x67C),
+	MX53_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN_MX53(0, 21, 1, 0x2F8, 0x680),
+	MX53_PIN_NVCC_SD1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x684),
+	MX53_PIN_SD2_CLK = _MXC_BUILD_GPIO_PIN_MX53(0, 10, 1, 0x2FC, 0x688),
+	MX53_PIN_SD2_CMD = _MXC_BUILD_GPIO_PIN_MX53(0, 11, 1, 0x300, 0x68C),
+	MX53_PIN_SD2_DATA3 = _MXC_BUILD_GPIO_PIN_MX53(0, 12, 1, 0x304, 0x690),
+	MX53_PIN_SD2_DATA2 = _MXC_BUILD_GPIO_PIN_MX53(0, 13, 1, 0x308, 0x694),
+	MX53_PIN_SD2_DATA1 = _MXC_BUILD_GPIO_PIN_MX53(0, 14, 1, 0x30C, 0x698),
+	MX53_PIN_SD2_DATA0 = _MXC_BUILD_GPIO_PIN_MX53(0, 15, 1, 0x310, 0x69C),
+	MX53_PIN_NVCC_SD2 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6A0),
+	MX53_PIN_GPIO_0 = _MXC_BUILD_GPIO_PIN_MX53(0, 0, 1, 0x314, 0x6A4),
+	MX53_PIN_GPIO_1 = _MXC_BUILD_GPIO_PIN_MX53(0, 1, 1, 0x318, 0x6A8),
+	MX53_PIN_GPIO_9 = _MXC_BUILD_GPIO_PIN_MX53(0, 9, 1, 0x31C, 0x6AC),
+	MX53_PIN_GPIO_3 = _MXC_BUILD_GPIO_PIN_MX53(0, 3, 1, 0x320, 0x6B0),
+	MX53_PIN_GPIO_6 = _MXC_BUILD_GPIO_PIN_MX53(0, 6, 1, 0x324, 0x6B4),
+	MX53_PIN_GPIO_2 = _MXC_BUILD_GPIO_PIN_MX53(0, 2, 1, 0x328, 0x6B8),
+	MX53_PIN_GPIO_4 = _MXC_BUILD_GPIO_PIN_MX53(0, 4, 1, 0x32C, 0x6BC),
+	MX53_PIN_GPIO_5 = _MXC_BUILD_GPIO_PIN_MX53(0, 5, 1, 0x330, 0x6C0),
+	MX53_PIN_GPIO_7 = _MXC_BUILD_GPIO_PIN_MX53(0, 7, 1, 0x334, 0x6C4),
+	MX53_PIN_GPIO_8 = _MXC_BUILD_GPIO_PIN_MX53(0, 8, 1, 0x338, 0x6C8),
+	MX53_PIN_GPIO_16 = _MXC_BUILD_GPIO_PIN_MX53(6, 11, 1, 0x33C, 0x6CC),
+	MX53_PIN_GPIO_17 = _MXC_BUILD_GPIO_PIN_MX53(6, 12, 1, 0x340, 0x6D0),
+	MX53_PIN_GPIO_18 = _MXC_BUILD_GPIO_PIN_MX53(6, 13, 1, 0x344, 0x6D4),
+	MX53_PIN_NVCC_GPIO = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6D8),
+	MX53_PIN_POR_B = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6DC),
+	MX53_PIN_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6E0),
+	MX53_PIN_RESET_IN_B = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6E4),
+	MX53_PIN_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6E8),
+	MX53_PIN_TEST_MODE = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6EC),
+	MX53_PIN_GRP_ADDDS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6F0),
+	MX53_PIN_GRP_DDRMODE_CTL = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6F4),
+	MX53_PIN_GRP_DDRPKE = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x6FC),
+	MX53_PIN_GRP_DDRPK = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x708),
+	MX53_PIN_GRP_TERM_CTL3 = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x70C),
+	MX53_PIN_GRP_DDRHYS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x710),
+	MX53_PIN_GRP_DDRMODE = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x714),
+	MX53_PIN_GRP_B0DS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x718),
+	MX53_PIN_GRP_B1DS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x71C),
+	MX53_PIN_GRP_CTLDS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x720),
+	MX53_PIN_GRP_DDR_TYPE = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x724),
+	MX53_PIN_GRP_B2DS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x728),
+	MX53_PIN_GRP_B3DS = _MXC_BUILD_NON_GPIO_PIN_MX53(NON_MUX_I, 0x72C),
+};
+
+/*!
+ * various IOMUX input select register index
+ */
+enum iomux_input_select_mx53 {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DA_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P5_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_CAN1_IPP_IND_CANRX_SELECT_INPUT,		/*0x760*/
+	MUX_IN_CAN2_IPP_IND_CANRX_SELECT_INPUT,
+	MUX_IN_CCM_IPP_ASRC_EXT_SELECT_INPUT,
+	MUX_IN_CCM_IPP_DI1_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL3_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL4_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT,	/*0x780*/
+	MUX_IN_CSPI_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_4_SELECT_INPUT,
+
+	MUX_IN_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT,
+	MUX_IN_ECSPI1_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_ECSPI1_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT,	/*0x7B0*/
+	MUX_IN_ECSPI1_IPP_IND_SS_B_4_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_FSR_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_FST_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_HCKR_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_HCKT_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SCKR_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SCKT_SELECT_INPUT,		/*0x7E0*/
+	MUX_IN_ESAI1_IPP_IND_SDO0_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SDO1_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SDO2_SDI3_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SDO3_SDI2_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SDO4_SDI1_SELECT_INPUT,
+	MUX_IN_ESAI1_IPP_IND_SDO5_SDI0_SELECT_INPUT,
+	MUX_IN_ESDHC1_IPP_WP_ON_SELECT_INPUT,
+	MUX_IN_FEC_FEC_COL_SELECT_INPUT,	/*0x800*/
+	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
+	MUX_IN_FIRI_IPP_IND_RXD_SELECT_INPUT,
+	MUX_IN_GPC_PMIC_RDY_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+	MUX_IN_I2C3_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C3_IPP_SDA_IN_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT,
+	MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_IND_SENS1_DATA_EN_SELECT_INPUT,
+	MUX_IN_IPU_IPP_IND_SENS1_HSYNC_SELECT_INPUT,
+	MUX_IN_IPU_IPP_IND_SENS1_VSYNC_SELECT_INPUT,
+
+	MUX_IN_KPP_IPP_IND_COL_5_SELECT_INPUT,	/*0x840*/
+	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
+
+	MUX_IN_MLB_MLBCLK_IN_SELECT_INPUT,
+	MUX_IN_MLB_MLBDAT_IN_SELECT_INPUT,
+	MUX_IN_MLB_MLBSIG_IN_SELECT_INPUT,
+
+	MUX_IN_OWIRE_BATTERY_LINE_IN_SELECT_INPUT,
+
+	MUX_IN_SDMA_EVENTS_14_SELECT_INPUT,
+	MUX_IN_SDMA_EVENTS_15_SELECT_INPUT,
+
+	MUX_IN_SPDIF_SPDIF_IN1_SELECT_INPUT,	/*0x870*/
+	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART4_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART4_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART5_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART5_IPP_UART_RXD_MUX_SELECT_INPUT,
+
+	MUX_IN_USBOH3_IPP_IND_OTG_OC_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH1_OC_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH2_OC_SELECT_INPUT,
+	MUX_INPUT_NUM_MUX,
+};
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX53_PINS_H__ */
diff --git a/arch/arm/mach-mx5/sdma_script_code_mx53.h b/arch/arm/mach-mx5/sdma_script_code_mx53.h
new file mode 100644
index 0000000..25f192d
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code_mx53.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/************************************************************************************
+
+	SDMA RELEASE LABEL:     "SDMA_RITA.01.00.00"
+
+*************************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_MX53_H__
+#define __SDMA_SCRIPT_CODE_MX53_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_MX53   0
+#define start_SIZE_MX53   22
+
+#define core_ADDR_MX53   80
+#define core_SIZE_MX53   232
+
+#define common_ADDR_MX53   312
+#define common_SIZE_MX53   330
+
+#define ap_2_ap_ADDR_MX53   642
+#define ap_2_ap_SIZE_MX53   41
+
+#define app_2_mcu_ADDR_MX53   683
+#define app_2_mcu_SIZE_MX53   64
+
+#define mcu_2_app_ADDR_MX53   747
+#define mcu_2_app_SIZE_MX53   70
+
+#define uart_2_mcu_ADDR_MX53   817
+#define uart_2_mcu_SIZE_MX53   74
+
+#define shp_2_mcu_ADDR_MX53   891
+#define shp_2_mcu_SIZE_MX53   69
+
+#define mcu_2_shp_ADDR_MX53   960
+#define mcu_2_shp_SIZE_MX53   72
+
+#define uartsh_2_mcu_ADDR_MX53   1032
+#define uartsh_2_mcu_SIZE_MX53   68
+
+#define spdif_2_mcu_ADDR_MX53   1100
+#define spdif_2_mcu_SIZE_MX53   34
+
+#define mcu_2_spdif_ADDR_MX53   1134
+#define mcu_2_spdif_SIZE_MX53   59
+
+#define firi_2_mcu_ADDR_MX53   1193
+#define firi_2_mcu_SIZE_MX53   97
+
+#define mcu_2_firi_ADDR_MX53  1290
+#define mcu_2_firi_SIZE_MX53   79
+
+#define loop_DMAs_routines_ADDR_MX53   1369
+#define loop_DMAs_routines_SIZE_MX53   227
+
+#define test_ADDR_MX53   1596
+#define test_SIZE_MX53   63
+
+#define signature_ADDR_MX53   1023
+#define signature_SIZE_MX53   1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define asrc__mcu_ADDR_MX53   6144
+#define asrc__mcu_SIZE_MX53   114
+
+#define mcu_2_ssiapp_ADDR_MX53   6258
+#define mcu_2_ssiapp_SIZE_MX53   96
+
+#define p_2_p_ADDR_MX53   6354
+#define p_2_p_SIZE_MX53   254
+
+#define ssiapp_2_mcu_ADDR_MX53   6608
+#define ssiapp_2_mcu_SIZE_MX53   93
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_MX53     6144
+#define RAM_CODE_SIZE_MX53           557
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code_mx53[] = {
+	0xc1d9, 0xc1e3, 0x56f3, 0x57db, 0x047a, 0x7d07, 0x072f, 0x076e,
+	0x7d02, 0x6ec7, 0x9813, 0x6ed7, 0x9813, 0x074f, 0x076e, 0x7d02,
+	0x6e01, 0x9813, 0x6e05, 0x5ce3, 0x048f, 0x0410, 0x3c0f, 0x5c93,
+	0x0eff, 0x06bf, 0x06d5, 0x7d01, 0x068d, 0x05a6, 0x5deb, 0x55fb,
+	0x008e, 0x0768, 0x7d02, 0x0769, 0x7c04, 0x06d4, 0x7d01, 0x008c,
+	0x04a0, 0x06a0, 0x076f, 0x7d0c, 0x076e, 0x7d05, 0x7802, 0x62c8,
+	0x5a05, 0x7c2b, 0x9845, 0x7802, 0x5205, 0x6ac8, 0x7c26, 0x9845,
+	0x076e, 0x7d05, 0x7802, 0x620b, 0x5a05, 0x7c21, 0x9845, 0x7802,
+	0x5205, 0x6a0b, 0x7c1c, 0x6a28, 0x7f1a, 0x0768, 0x7d02, 0x0769,
+	0x7c0a, 0x4c00, 0x7c08, 0x0768, 0x7d03, 0x5a05, 0x7f11, 0x9852,
+	0x5205, 0x7e0e, 0x5493, 0x4e00, 0x7ccb, 0x0000, 0x54e3, 0x55eb,
+	0x4d00, 0x7d0a, 0xc1fa, 0x57db, 0x9814, 0x68cc, 0x9860, 0x680c,
+	0x009e, 0x0007, 0x54e3, 0xd866, 0xc20a, 0x9802, 0x55eb, 0x009d,
+	0x058c, 0x0aff, 0x0211, 0x1aff, 0x05ba, 0x05a0, 0x04b2, 0x04ad,
+	0x0454, 0x0006, 0xc1e3, 0x57db, 0x52f3, 0x6a01, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479, 0x7d2c,
+	0x7c36, 0x0479, 0x7c1f, 0x56ee, 0x0f00, 0x0660, 0x7d05, 0x6509,
+	0x7e43, 0x620a, 0x7e41, 0x9890, 0x620a, 0x7e3e, 0x6509, 0x7e3c,
+	0x0512, 0x0512, 0x02ad, 0x0760, 0x7d03, 0x55fb, 0x6dd3, 0x989b,
+	0x55fb, 0x1d04, 0x6dd3, 0x6ac8, 0x7f2f, 0x1f01, 0x2003, 0x4800,
+	0x7ce4, 0x98c3, 0x55fb, 0x6dd7, 0x0015, 0x7805, 0x6209, 0x6ac8,
+	0x6209, 0x6ac8, 0x6dd7, 0x98c2, 0x55fb, 0x6dd7, 0x0015, 0x0015,
+	0x7805, 0x620a, 0x6ac8, 0x620a, 0x6ac8, 0x6dd7, 0x98c2, 0x55fb,
+	0x6dd7, 0x0015, 0x0015, 0x0015, 0x7805, 0x620b, 0x6ac8, 0x620b,
+	0x6ac8, 0x6dd7, 0x7c09, 0x6ddf, 0x7f07, 0x0000, 0x55eb, 0x4d00,
+	0x7d07, 0xc1fa, 0x57db, 0x9876, 0x0007, 0x68cc, 0x680c, 0xc213,
+	0xc20a, 0x9873, 0x0b70, 0x0311, 0x5313, 0x076c, 0x7c01, 0xc1d9,
+	0x5efb, 0x068a, 0x076b, 0x7c01, 0xc1d9, 0x5ef3, 0x59db, 0x58d3,
+	0x018f, 0x0110, 0x390f, 0x008b, 0xc13c, 0x7d2b, 0x5ac0, 0x5bc8,
+	0xc14e, 0x7c27, 0x0388, 0x0689, 0x5ce3, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x073e, 0x4d00, 0x7d18, 0x0870, 0x0011, 0x077e, 0x7d09,
+	0x077d, 0x7d02, 0x5228, 0x98fd, 0x52f8, 0x54db, 0x02bc, 0x02cc,
+	0x7c09, 0x077c, 0x7d02, 0x5228, 0x9906, 0x52f8, 0x54d3, 0x02bc,
+	0x02cc, 0x7d09, 0x0400, 0x98f4, 0x008b, 0x52c0, 0x53c8, 0xc159,
+	0x7dd6, 0x0200, 0x98e4, 0x08ff, 0x00bf, 0x077f, 0x7d15, 0x0488,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb, 0x028f, 0x0212, 0x0212,
+	0x3aff, 0x05da, 0x7c02, 0x073e, 0x992f, 0x02a4, 0x02dd, 0x7d02,
+	0x073e, 0x992f, 0x075e, 0x992f, 0x55eb, 0x0598, 0x5deb, 0x52f3,
+	0x54fb, 0x076a, 0x7d26, 0x076c, 0x7d01, 0x996c, 0x076b, 0x7c57,
+	0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9946, 0x5893, 0x00d6,
+	0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802, 0x5502,
+	0x5d04, 0x7c1d, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x5502, 0x7e17,
+	0x9953, 0x5d04, 0x7f14, 0x0689, 0x5093, 0x4800, 0x7d01, 0x993e,
+	0x99b7, 0x0015, 0x7806, 0x5502, 0x5d04, 0x074f, 0x5502, 0x5d24,
+	0x072f, 0x7c01, 0x99b7, 0x0017, 0x076f, 0x7c01, 0x2001, 0x5593,
+	0x009d, 0x0007, 0xd9be, 0x990c, 0x6cd3, 0x0769, 0x7d04, 0x0768,
+	0x7d02, 0x0e01, 0x997b, 0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593,
+	0x05a0, 0x5d93, 0x06a0, 0x7802, 0x5502, 0x6dc8, 0x7c0f, 0x4e00,
+	0x7c08, 0x0769, 0x7d03, 0x5502, 0x7e09, 0x9988, 0x6dc8, 0x7f06,
+	0x0689, 0x5093, 0x4800, 0x7d01, 0x9973, 0x99b7, 0x99b1, 0x6ac3,
+	0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x999e, 0x5893, 0x00d6,
+	0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802, 0x65c8,
+	0x5d04, 0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x65c8, 0x7e09,
+	0x99ab, 0x5d04, 0x7f06, 0x0689, 0x5093, 0x4800, 0x7d01, 0x9996,
+	0x99b7, 0x5593, 0x009d, 0x0007, 0x6cff, 0xd9be, 0x990c, 0x0000,
+	0x54e3, 0x55eb, 0x4d00, 0x7c01, 0x990c, 0x98f4, 0x54e3, 0x55eb,
+	0x0aff, 0x0211, 0x1aff, 0x077f, 0x7c02, 0x05a0, 0x99cb, 0x009d,
+	0x058c, 0x05ba, 0x05a0, 0x0210, 0x04ba, 0x04ad, 0x0454, 0x0006,
+	0xc1e3, 0x57db, 0x52fb, 0x6ac3, 0x52f3, 0x6a05, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479, 0x7d2b,
+	0x7c1e, 0x0479, 0x7c33, 0x56ee, 0x0f00, 0x55fb, 0x0760, 0x7d02,
+	0x6dc3, 0x99ec, 0x1d04, 0x6dc3, 0x62c8, 0x7e3b, 0x0660, 0x7d02,
+	0x0210, 0x0212, 0x6a09, 0x7f35, 0x0212, 0x6a09, 0x7f32, 0x0212,
+	0x6a09, 0x7f2f, 0x1f01, 0x2003, 0x4800, 0x7ce7, 0x9a20, 0x55fb,
+	0x6dc7, 0x0015, 0x0015, 0x0015, 0x7805, 0x62c8, 0x6a0b, 0x62c8,
+	0x6a0b, 0x6dc7, 0x9a1f, 0x55fb, 0x6dc7, 0x0015, 0x0015, 0x7805,
+	0x62c8, 0x6a0a, 0x62c8, 0x6a0a, 0x6dc7, 0x9a1f, 0x55fb, 0x6dc7,
+	0x0015, 0x7805, 0x62c8, 0x6a09, 0x62c8, 0x6a09, 0x6dc7, 0x7c09,
+	0x6a28, 0x7f07, 0x0000, 0x55eb, 0x4d00, 0x7d05, 0xc1fa, 0x57db,
+	0x99d6, 0xc277, 0x0454, 0xc20a, 0x99d1
+};
+#endif
diff --git a/arch/arm/mach-mx5/serial.c b/arch/arm/mach-mx5/serial.c
index d0ac961..1c0b2c0 100644
--- a/arch/arm/mach-mx5/serial.c
+++ b/arch/arm/mach-mx5/serial.c
@@ -23,7 +23,7 @@
 #include <mach/hardware.h>
 #include <mach/mxc_uart.h>
 #include "serial.h"
-#include "board-mx51_3stack.h"
+#include "board-mx53_evk.h"
 
 #if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
 
@@ -110,6 +110,56 @@ static uart_mxc_port mxc_ports[] = {
 	       .dma_rx_id = MXC_DMA_UART3_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
 	       },
+	[3] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART4_BASE_ADDR),
+			.mapbase = UART4_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART4_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 3,
+			},
+	       .ints_muxed = UART4_MUX_INTS,
+	       .irqs = {UART4_INT2, UART4_INT3},
+	       .mode = UART4_MODE,
+	       .ir_mode = UART4_IR,
+	       .enabled = UART4_ENABLED,
+	       .hardware_flow = UART4_HW_FLOW,
+	       .cts_threshold = UART4_UCR4_CTSTL,
+	       .dma_enabled = UART4_DMA_ENABLE,
+	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
+	       .rx_threshold = UART4_UFCR_RXTL,
+	       .tx_threshold = UART4_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART4_TX,
+	       .dma_rx_id = MXC_DMA_UART4_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[4] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART5_BASE_ADDR),
+			.mapbase = UART5_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART5_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 4,
+			},
+	       .ints_muxed = UART5_MUX_INTS,
+	       .irqs = {UART5_INT2, UART5_INT3},
+	       .mode = UART5_MODE,
+	       .ir_mode = UART5_IR,
+	       .enabled = UART5_ENABLED,
+	       .hardware_flow = UART5_HW_FLOW,
+	       .cts_threshold = UART5_UCR4_CTSTL,
+	       .dma_enabled = UART5_DMA_ENABLE,
+	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
+	       .rx_threshold = UART5_UFCR_RXTL,
+	       .tx_threshold = UART5_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART5_TX,
+	       .dma_rx_id = MXC_DMA_UART5_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
 };
 
 static struct platform_device mxc_uart_device1 = {
@@ -136,15 +186,46 @@ static struct platform_device mxc_uart_device3 = {
 		},
 };
 
+static struct platform_device mxc_uart_device4 = {
+	.name = "mxcintuart",
+	.id = 3,
+	.dev = {
+		.platform_data = &mxc_ports[3],
+		},
+};
+
+static struct platform_device mxc_uart_device5 = {
+	.name = "mxcintuart",
+	.id = 4,
+	.dev = {
+		.platform_data = &mxc_ports[4],
+		},
+};
+
 static int __init mxc_init_uart(void)
 {
+	int i;
+
+	if (cpu_is_mx53()) {
+		for (i = 0; i < ARRAY_SIZE(mxc_ports); i++) {
+			mxc_ports[i].port.mapbase -= 0x20000000;
+		}
+	}
+
 	/* Register all the MXC UART platform device structures */
 	platform_device_register(&mxc_uart_device1);
 	platform_device_register(&mxc_uart_device2);
 #if UART3_ENABLED == 1
 	platform_device_register(&mxc_uart_device3);
 #endif				/* UART3_ENABLED */
-
+	if (cpu_is_mx53()) {
+#if UART4_ENABLED == 1
+		platform_device_register(&mxc_uart_device4);
+#endif				/* UART4_ENABLED */
+#if UART5_ENABLED == 1
+		platform_device_register(&mxc_uart_device5);
+#endif				/* UART5_ENABLED */
+	}
 	return 0;
 }
 
diff --git a/arch/arm/mach-mx5/serial.h b/arch/arm/mach-mx5/serial.h
index c2eb9fa..aa97228 100644
--- a/arch/arm/mach-mx5/serial.h
+++ b/arch/arm/mach-mx5/serial.h
@@ -69,6 +69,20 @@
 #define UART3_DMA_RXBUFSIZE     1024
 #define UART3_UFCR_RXTL         16
 #define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           0
+#define UART4_UCR4_CTSTL        -1
+#define UART4_DMA_ENABLE        0
+#define UART4_DMA_RXBUFSIZE     512
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           0
+#define UART5_UCR4_CTSTL        -1
+#define UART5_DMA_ENABLE        0
+#define UART5_DMA_RXBUFSIZE     512
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
 /*
  * UART Chip level Configuration that a user may not have to edit. These
  * configuration vary depending on how the UART module is integrated with
@@ -115,5 +129,15 @@
 #define UART3_INT1              MXC_INT_UART3
 #define UART3_INT2              -1
 #define UART3_INT3              -1
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              MXC_INT_UART4
+#define UART4_INT2              -1
+#define UART4_INT3              -1
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              MXC_INT_UART5
+#define UART5_INT2              -1
+#define UART5_INT3              -1
 
 #endif				/* __ARCH_ARM_MACH_MX51_SERIAL_H__ */
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index 85017fc..3f49618 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -45,7 +45,7 @@ config ARCH_MX37
 config ARCH_MX5
 	bool "MX5-based"
 	help
-	  This enables support for systems based on Freescale i.MX51
+	  This enables support for systems based on Freescale i.MX5x SoCs.
 
 endchoice
 
@@ -102,7 +102,7 @@ config ISP1504_MXC
 config UTMI_MXC
 	bool
 	default y
-	depends on ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX51
+	depends on ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX5
 
 # set iff we need the 1301 transceiver code
 config ISP1301_MXC
@@ -175,7 +175,7 @@ config ARCH_MXC_IOMUX_V3
 
 config MXC_DVFS_PER
 	bool "Enable DVFS Peripheral"
-	depends on ARCH_MX37 || ARCH_MX51
+	depends on ARCH_MX37 || ARCH_MX5
 	help
 	   Select this if you want to enable HW supported peripheral frequency scaling.
 endif
diff --git a/arch/arm/plat-mxc/cpu_common.c b/arch/arm/plat-mxc/cpu_common.c
index 3aeda90..8ff820d 100644
--- a/arch/arm/plat-mxc/cpu_common.c
+++ b/arch/arm/plat-mxc/cpu_common.c
@@ -73,7 +73,6 @@ __early_param("debug_uart=", uart_parent_setup);
 
 void __init mxc_cpu_common_init(void)
 {
-	mxc_set_cpu_type((((system_rev >> 20) & 0xF) * 10) + ((system_rev >> 16) & 0xF));
 	pr_info("CPU is %s%x Revision %u.%u\n",
 		(mxc_cpu() < 0x100) ? "i.MX" : "MXC",
 		mxc_cpu(), mxc_cpu_rev_major(), mxc_cpu_rev_minor());
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
index 312cb65..4831637 100644
--- a/arch/arm/plat-mxc/cpufreq.c
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -58,7 +58,7 @@ extern int set_low_bus_freq(void);
 extern int set_high_bus_freq(int high_bus_speed);
 extern int low_freq_bus_used(void);
 
-#ifdef CONFIG_ARCH_MX51
+#ifdef CONFIG_ARCH_MX5
 extern struct cpu_wp *(*get_cpu_wp)(int *wp);
 #endif
 
diff --git a/arch/arm/plat-mxc/dvfs_per.c b/arch/arm/plat-mxc/dvfs_per.c
index 269dbb2..43d0dfc 100644
--- a/arch/arm/plat-mxc/dvfs_per.c
+++ b/arch/arm/plat-mxc/dvfs_per.c
@@ -94,7 +94,7 @@ int start_dvfs_per(void);
 void stop_dvfs_per(void);
 int dvfs_per_active(void);
 int dvfs_per_divider_active(void);
-int dvfs_per_pixel_clk_limit();
+int dvfs_per_pixel_clk_limit(void);
 
 extern int low_bus_freq_mode;
 extern int bus_freq_scaling_is_active;
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index 7e661c4..742fb43 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -21,9 +21,9 @@ extern void mx27_map_io(void);
 extern void mx31_map_io(void);
 extern void mx35_map_io(void);
 extern void mx37_map_io(void);
-extern void mx51_map_io(void);
+extern void mx5_map_io(void);
 extern void mxc_init_irq(void);
-extern void mx51_init_irq(void);
+extern void mx5_init_irq(void);
 extern void mx37_init_irq(void);
 extern void mxc_tzic_init_irq(unsigned long);
 extern void mxc_timer_init(struct clk *timer_clk, void __iomem *base, int irq);
@@ -35,6 +35,7 @@ extern int mx31_clocks_init(unsigned long fref);
 extern int mx35_clocks_init(void);
 extern int mx37_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
 extern int mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
+extern int mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
 extern int mxc_init_devices(void);
 extern void mxc_cpu_init(void) __init;
 extern void mxc_cpu_common_init(void);
diff --git a/arch/arm/plat-mxc/include/mach/hardware.h b/arch/arm/plat-mxc/include/mach/hardware.h
index b110686..f07f615 100644
--- a/arch/arm/plat-mxc/include/mach/hardware.h
+++ b/arch/arm/plat-mxc/include/mach/hardware.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -70,8 +70,8 @@
 #include <mach/mx37.h>
 #endif
 
-#ifdef CONFIG_ARCH_MX51
-#include <mach/mx51.h>
+#ifdef CONFIG_ARCH_MX5
+#include <mach/mx5x.h>
 #endif
 
 #ifdef CONFIG_ARCH_MX25
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index 59a9c45..8a6f7bd 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -28,8 +28,8 @@
 #define MXC_GPIO_IRQS		(32 * 3)
 #elif defined CONFIG_ARCH_MX37
 #define MXC_GPIO_IRQS		(32 * 3)
-#elif defined CONFIG_ARCH_MX51
-#define MXC_GPIO_IRQS		(32 * 4)
+#elif defined CONFIG_ARCH_MX5
+#define MXC_GPIO_IRQS		(32 * 7)
 #endif
 
 /*
@@ -74,7 +74,7 @@ extern int mxc_set_irq_fiq(unsigned int irq, unsigned int type);
 void mxc_get_wake_irq(u32 * wake_src[]);
 
 /* Define interrupt number for OProfile */
-#if defined CONFIG_ARCH_MX51
+#if defined CONFIG_ARCH_MX5
 #define MXC_INT_PMU		77
 #endif
 
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
index c898f88..a70d3ef 100644
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,6 +31,10 @@
 #define PHYS_OFFSET             UL(0x90000000)
 #endif
 
+#ifdef CONFIG_ARCH_MX53
+#define PHYS_OFFSET             UL(0x70000000)
+#endif
+
 #ifdef CONFIG_ARCH_MX37
 #define PHYS_OFFSET             UL(0x40000000)
 #endif
@@ -56,7 +60,7 @@
 #define CONSISTENT_DMA_SIZE SZ_8M
 #endif /* CONFIG_MX3_VIDEO */
 
-#ifdef CONFIG_ARCH_MX51
+#ifdef CONFIG_ARCH_MX5
 #define CONSISTENT_DMA_SIZE	(64 * SZ_1M)
 #else
 #define CONSISTENT_DMA_SIZE	(32 * SZ_1M)
diff --git a/arch/arm/plat-mxc/include/mach/mx51.h b/arch/arm/plat-mxc/include/mach/mx51.h
deleted file mode 100644
index 32bfb01..0000000
--- a/arch/arm/plat-mxc/include/mach/mx51.h
+++ /dev/null
@@ -1,489 +0,0 @@
-/*
- * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef __ASM_ARCH_MXC_MX51_H__
-#define __ASM_ARCH_MXC_MX51_H__
-
-#ifndef __ASM_ARCH_MXC_HARDWARE_H__
-#error "Do not include directly."
-#endif
-
-/*!
- * @file arch-mxc/mx51.h
- * @brief This file contains register definitions.
- *
- * @ingroup MSL_MX51
- */
-
-/*!
- * Register an interrupt handler for the SMN as well as the SCC.  In some
- * implementations, the SMN is not connected at all, and in others, it is
- * on the same interrupt line as the SCM. Comment this line out accordingly
- */
-#define USE_SMN_INTERRUPT
-
-/*!
- * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
- * Certain platforms need this bit to be set in order to receive Irda data.
- */
-#define MXC_UART_IR_RXDMUX      0x0004
-/*!
- * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
- * Certain platforms need this bit to be set in order to receive UART data.
- */
-#define MXC_UART_RXDMUX         0x0004
-
-/*!
- * This option is used to set or clear the dspdma bit in the SDMA config
- * register.
- */
-#define MXC_SDMA_DSPDMA         0
-
-/*!
- * Define this option to specify we are using the newer SDMA module.
- */
-#define MXC_SDMA_V2
-
-/*!
- * The maximum frequency that the pixel clock can be at so as to
- * activate DVFS-PER.
- */
-#define DVFS_MAX_PIX_CLK	54000000
-
- /*
- * IRAM
- */
-#define IRAM_BASE_ADDR		0x1FFE0000	/* internal ram */
-#define IRAM_PARTITIONS		16
-#define IRAM_PARTITIONS_TO1	12
-#define IRAM_SIZE		(IRAM_PARTITIONS*SZ_8K)	/* 128KB */
-
-#if defined(CONFIG_MXC_SECURITY_SCC2) \
-    || defined(CONFIG_MXC_SECURITY_SCC2_MODULE)
-#define SCC_IRAM_SIZE  SZ_16K
-#else
-#define SCC_IRAM_SIZE  0
-#endif
-
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-#define SND_RAM_SIZE 0x6000
-#else
-#define SND_RAM_SIZE 0
-#endif
-
-#ifdef CONFIG_MXC_VPU_IRAM
-#define VPU_IRAM_SIZE  0x11000
-#else
-#define VPU_IRAM_SIZE 0
-#endif
-
-#if defined(CONFIG_USB_STATIC_IRAM) \
-    || defined(CONFIG_USB_STATIC_IRAM_PPH)
-#define USB_IRAM_SIZE	SZ_8K
-#else
-#define USB_IRAM_SIZE 0
-#endif
-
-/*
- * NFC
- */
-#define NFC_BASE_ADDR_AXI		0xCFFF0000	/* NAND flash AXI */
-#define NFC_BASE_ADDR_AXI_VIRT	0xF9000000
-#define NFC_AXI_SIZE		SZ_64K
-
-/*
- * Graphics Memory of GPU
- */
-#define GPU_GMEM_BASE_ADDR	0x20000000
-#define GPU_BASE_ADDR			0x30000000
-#define GPU2D_BASE_ADDR		0xD0000000
-
-#define TZIC_BASE_ADDR_T01		0x8FFFC000
-#define TZIC_BASE_ADDR			0xE0000000
-#define TZIC_SIZE		SZ_16K
-
-#define DEBUG_BASE_ADDR	0x60000000
-#define DEBUG_SIZE		SZ_1M
-#define ETB_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00001000)
-#define ETM_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00002000)
-#define TPIU_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00003000)
-#define CTI0_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00004000)
-#define CTI1_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00005000)
-#define CTI2_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00006000)
-#define CTI3_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00007000)
-#define CORTEX_DBG_BASE_ADDR	(DEBUG_BASE_ADDR + 0x00008000)
-
-/*
- * SPBA global module enabled #0
- */
-#define SPBA0_BASE_ADDR 	0x70000000
-#define SPBA0_BASE_ADDR_VIRT	0xFB100000
-#define SPBA0_SIZE		SZ_1M
-
-#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
-#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
-#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
-#define CSPI1_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
-#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
-#define MMC_SDHC3_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
-#define MMC_SDHC4_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00024000)
-#define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
-#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00030000)
-#define SLIM_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00034000)
-#define HSI2C_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00038000)
-#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
-
-/*!
- * defines for SPBA modules
- */
-#define SPBA_SDHC1	0x04
-#define SPBA_SDHC2	0x08
-#define SPBA_UART3	0x0C
-#define SPBA_CSPI1	0x10
-#define SPBA_SSI2	0x14
-#define SPBA_SDHC3	0x20
-#define SPBA_SDHC4	0x24
-#define SPBA_SPDIF	0x28
-#define SPBA_ATA	0x30
-#define SPBA_SLIM	0x34
-#define SPBA_HSI2C	0x38
-#define SPBA_CTRL	0x3C
-
-/*
- * AIPS 1
- */
-#define AIPS1_BASE_ADDR 	0x73F00000
-#define AIPS1_BASE_ADDR_VIRT	0xF7E00000
-#define AIPS1_SIZE		SZ_1M
-
-#define OTG_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00080000)
-#define GPIO1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00084000)
-#define GPIO2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00088000)
-#define GPIO3_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0008C000)
-#define GPIO4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00090000)
-#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
-#define WDOG1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00098000)
-#define WDOG2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0009C000)
-#define GPT1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
-#define SRTC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A4000)
-#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000A8000)
-#define EPIT1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000AC000)
-#define EPIT2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B0000)
-#define PWM1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B4000)
-#define PWM2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
-#define UART1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
-#define UART2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000C0000)
-#define SRC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D0000)
-#define CCM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D4000)
-#define GPC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D8000)
-
-#define DVFSPER_BASE_ADDR 	(GPC_BASE_ADDR + 0x1C4)
-/*!
- * Defines for modules using static and dynamic DMA channels
- */
-#define MXC_DMA_CHANNEL_IRAM         30
-#define MXC_DMA_CHANNEL_SPDIF_TX        MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART1_RX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART1_TX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART2_RX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART2_TX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART3_RX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_UART3_TX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_MMC1		MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_MMC2		MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI1_RX		MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI1_TX		MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_SSI2_RX		MXC_DMA_DYNAMIC_CHANNEL
-#ifdef CONFIG_SDMA_IRAM
-#define MXC_DMA_CHANNEL_SSI2_TX  (MXC_DMA_CHANNEL_IRAM + 1)
-#else				/*CONFIG_SDMA_IRAM */
-#define MXC_DMA_CHANNEL_SSI2_TX		MXC_DMA_DYNAMIC_CHANNEL
-#endif				/*CONFIG_SDMA_IRAM */
-#define MXC_DMA_CHANNEL_CSPI1_RX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI1_TX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI2_RX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI2_TX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI3_RX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_CSPI3_TX	MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_ATA_RX		MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_ATA_TX		MXC_DMA_DYNAMIC_CHANNEL
-#define MXC_DMA_CHANNEL_MEMORY		MXC_DMA_DYNAMIC_CHANNEL
-
-/*
- * AIPS 2
- */
-#define AIPS2_BASE_ADDR	0x83F00000
-#define AIPS2_BASE_ADDR_VIRT	0xF7D00000
-#define AIPS2_SIZE		SZ_1M
-
-#define PLL1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
-#define PLL2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00084000)
-#define PLL3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00088000)
-#define AHBMAX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00094000)
-#define IIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
-#define CSU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0009C000)
-#define ARM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A0000)
-#define OWIRE_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000A4000)
-#define FIRI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A8000)
-#define CSPI2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000AC000)
-#define SDMA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B0000)
-#define SCC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B4000)
-#define ROMCP_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B8000)
-#define RTIC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000BC000)
-#define CSPI3_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
-#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C4000)
-#define I2C1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C8000)
-#define SSI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
-#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D0000)
-#define M4IF_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
-#define ESDCTL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D9000)
-#define WEIM_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DA000)
-#define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DB000)
-#define EMI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DBF00)
-#define MIPI_HSC_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DC000)
-#define ATA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E0000)
-#define SIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000)
-#define SSI3BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E8000)
-#define FEC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000EC000)
-#define TVE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F0000)
-#define VPU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F4000)
-#define SAHARA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000F8000)
-
-/*
- * Memory regions and CS
- */
-#define GPU_CTRL_BASE_ADDR	0x30000000
-#define IPU_CTRL_BASE_ADDR	0x40000000
-#define CSD0_BASE_ADDR		0x90000000
-#define CSD1_BASE_ADDR		0xA0000000
-#define CS0_BASE_ADDR		0xB0000000
-#define CS1_BASE_ADDR		0xB8000000
-#define CS2_BASE_ADDR		0xC0000000
-#define CS3_BASE_ADDR		0xC8000000
-#define CS4_BASE_ADDR		0xCC000000
-#define CS5_BASE_ADDR		0xCE000000
-
-/*!
- * This macro defines the physical to virtual address mapping for all the
- * peripheral modules. It is used by passing in the physical address as x
- * and returning the virtual address. If the physical address is not mapped,
- * it returns 0xDEADBEEF
- */
-#define IO_ADDRESS(x)   \
-	(void __force __iomem *) \
-	((((x) >= (unsigned long)SPBA0_BASE_ADDR) && \
-	  ((x) < (unsigned long)SPBA0_BASE_ADDR + SPBA0_SIZE)) ? \
-	   SPBA0_IO_ADDRESS(x):\
-	(((x) >= (unsigned long)AIPS1_BASE_ADDR) && \
-	  ((x) < (unsigned long)AIPS1_BASE_ADDR + AIPS1_SIZE)) ? \
-	   AIPS1_IO_ADDRESS(x):\
-	(((x) >= (unsigned long)AIPS2_BASE_ADDR) && \
-	  ((x) < (unsigned long)AIPS2_BASE_ADDR + AIPS2_SIZE)) ? \
-	   AIPS2_IO_ADDRESS(x):\
-	(((x) >= (unsigned long)NFC_BASE_ADDR_AXI) && \
-	  ((x) < (unsigned long)NFC_BASE_ADDR_AXI + NFC_AXI_SIZE)) ? \
-	   NFC_BASE_ADDR_AXI_IO_ADDRESS(x):\
-	0xDEADBEEF)
-
-/*
- * define the address mapping macros: in physical address order
- */
-#define SPBA0_IO_ADDRESS(x)  \
-	(((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
-
-#define AIPS1_IO_ADDRESS(x)  \
-	(((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
-
-#define AIPS2_IO_ADDRESS(x)  \
-	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
-
-#define NFC_BASE_ADDR_AXI_IO_ADDRESS(x) \
-	(((x) - NFC_BASE_ADDR_AXI) + NFC_BASE_ADDR_AXI_VIRT)
-
-#define IS_MEM_DEVICE_NONSHARED(x)		0
-
-/*
- * DMA request assignments
- */
-#define DMA_REQ_SSI3_TX1		47
-#define DMA_REQ_SSI3_RX1		46
-#define DMA_REQ_SPDIF			45
-#define DMA_REQ_UART3_TX	44
-#define DMA_REQ_UART3_RX	43
-#define DMA_REQ_SLIM_B_TX		42
-#define DMA_REQ_SDHC4			41
-#define DMA_REQ_SDHC3		40
-#define DMA_REQ_CSPI_TX		39
-#define DMA_REQ_CSPI_RX		38
-#define DMA_REQ_SSI3_TX2		37
-#define DMA_REQ_IPU		36
-#define DMA_REQ_SSI3_RX2		35
-#define DMA_REQ_EPIT2		34
-#define DMA_REQ_CTI2_1			33
-#define DMA_REQ_EMI_WR		32
-#define DMA_REQ_CTI2_0			31
-#define DMA_REQ_EMI_RD			30
-#define DMA_REQ_SSI1_TX1	29
-#define DMA_REQ_SSI1_RX1	28
-#define DMA_REQ_SSI1_TX2	27
-#define DMA_REQ_SSI1_RX2	26
-#define DMA_REQ_SSI2_TX1	25
-#define DMA_REQ_SSI2_RX1	24
-#define DMA_REQ_SSI2_TX2	23
-#define DMA_REQ_SSI2_RX2	22
-#define DMA_REQ_SDHC2		21
-#define DMA_REQ_SDHC1		20
-#define DMA_REQ_UART1_TX	19
-#define DMA_REQ_UART1_RX	18
-#define DMA_REQ_UART2_TX	17
-#define DMA_REQ_UART2_RX	16
-#define DMA_REQ_GPU			15
-#define DMA_REQ_EXTREQ1		14
-#define DMA_REQ_FIRI_TX		13
-#define DMA_REQ_FIRI_RX		12
-#define DMA_REQ_HS_I2C_RX		11
-#define DMA_REQ_HS_I2C_TX		10
-#define DMA_REQ_CSPI2_TX		9
-#define DMA_REQ_CSPI2_RX		8
-#define DMA_REQ_CSPI1_TX		7
-#define DMA_REQ_CSPI1_RX		6
-#define DMA_REQ_SLIM_B			5
-#define DMA_REQ_ATA_TX_END	4
-#define DMA_REQ_ATA_TX		3
-#define DMA_REQ_ATA_RX		2
-#define DMA_REQ_GPC		1
-#define DMA_REQ_VPU			0
-
-/*
- * Interrupt numbers
- */
-#define MXC_INT_BASE		0
-#define MXC_INT_RESV0		0
-#define MXC_INT_MMC_SDHC1	1
-#define MXC_INT_MMC_SDHC2	2
-#define MXC_INT_MMC_SDHC3	3
-#define MXC_INT_MMC_SDHC4		4
-#define MXC_INT_RESV5		5
-#define MXC_INT_SDMA		6
-#define MXC_INT_IOMUX		7
-#define MXC_INT_NFC			8
-#define MXC_INT_VPU		9
-#define MXC_INT_IPU_ERR		10
-#define MXC_INT_IPU_SYN		11
-#define MXC_INT_GPU			12
-#define MXC_INT_RESV13		13
-#define MXC_INT_USB_H1			14
-#define MXC_INT_EMI		15
-#define MXC_INT_USB_H2			16
-#define MXC_INT_USB_H3			17
-#define MXC_INT_USB_OTG		18
-#define MXC_INT_SAHARA_H0		19
-#define MXC_INT_SAHARA_H1		20
-#define MXC_INT_SCC_SMN		21
-#define MXC_INT_SCC_STZ		22
-#define MXC_INT_SCC_SCM		23
-#define MXC_INT_SRTC_NTZ	24
-#define MXC_INT_SRTC_TZ		25
-#define MXC_INT_RTIC		26
-#define MXC_INT_CSU		27
-#define MXC_INT_SLIM_B			28
-#define MXC_INT_SSI1		29
-#define MXC_INT_SSI2		30
-#define MXC_INT_UART1		31
-#define MXC_INT_UART2		32
-#define MXC_INT_UART3		33
-#define MXC_INT_RESV34		34
-#define MXC_INT_RESV35		35
-#define MXC_INT_CSPI1		36
-#define MXC_INT_CSPI2		37
-#define MXC_INT_CSPI			38
-#define MXC_INT_GPT		39
-#define MXC_INT_EPIT1		40
-#define MXC_INT_EPIT2		41
-#define MXC_INT_GPIO1_INT7	42
-#define MXC_INT_GPIO1_INT6	43
-#define MXC_INT_GPIO1_INT5	44
-#define MXC_INT_GPIO1_INT4	45
-#define MXC_INT_GPIO1_INT3	46
-#define MXC_INT_GPIO1_INT2	47
-#define MXC_INT_GPIO1_INT1	48
-#define MXC_INT_GPIO1_INT0	49
-#define MXC_INT_GPIO1_LOW	50
-#define MXC_INT_GPIO1_HIGH	51
-#define MXC_INT_GPIO2_LOW	52
-#define MXC_INT_GPIO2_HIGH	53
-#define MXC_INT_GPIO3_LOW	54
-#define MXC_INT_GPIO3_HIGH	55
-#define MXC_INT_GPIO4_LOW		56
-#define MXC_INT_GPIO4_HIGH		57
-#define MXC_INT_WDOG1		58
-#define MXC_INT_WDOG2		59
-#define MXC_INT_KPP		60
-#define MXC_INT_PWM1			61
-#define MXC_INT_I2C1			62
-#define MXC_INT_I2C2		63
-#define MXC_INT_HS_I2C			64
-#define MXC_INT_RESV65			65
-#define MXC_INT_RESV66		66
-#define MXC_INT_SIM_IPB			67
-#define MXC_INT_SIM_DAT		68
-#define MXC_INT_IIM		69
-#define MXC_INT_ATA		70
-#define MXC_INT_CCM1		71
-#define MXC_INT_CCM2		72
-#define MXC_INT_GPC1		73
-#define MXC_INT_GPC2		74
-#define MXC_INT_SRC		75
-#define MXC_INT_NM			76
-#define MXC_INT_PMU			77
-#define MXC_INT_CTI_IRQ			78
-#define MXC_INT_CTI1_TG0		79
-#define MXC_INT_CTI1_TG1		80
-#define MXC_INT_MCG_ERR		81
-#define MXC_INT_MCG_TMR		82
-#define MXC_INT_MCG_FUNC		83
-#define MXC_INT_GPU2_IRQ	84
-#define MXC_INT_GPU2_BUSY	85
-#define MXC_INT_RESV86		86
-#define MXC_INT_FEC		87
-#define MXC_INT_OWIRE		88
-#define MXC_INT_CTI1_TG2		89
-#define MXC_INT_SJC			90
-#define MXC_INT_SPDIF		91
-#define MXC_INT_TVE			92
-#define MXC_INT_FIRI			93
-#define MXC_INT_PWM2			94
-#define MXC_INT_SLIM_EXP		95
-#define MXC_INT_SSI3			96
-#define MXC_INT_EMI_BOOT		97
-#define MXC_INT_CTI1_TG3		98
-#define MXC_INT_SMC_RX			99
-#define MXC_INT_VPU_IDLE		100
-#define MXC_INT_EMI_NFC		101
-#define MXC_INT_GPU_IDLE		102
-
-/* gpio and gpio based interrupt handling */
-#define GPIO_DR                 0x00
-#define GPIO_GDIR               0x04
-#define GPIO_PSR                0x08
-#define GPIO_ICR1               0x0C
-#define GPIO_ICR2               0x10
-#define GPIO_IMR                0x14
-#define GPIO_ISR                0x18
-#define GPIO_INT_LOW_LEV        0x0
-#define GPIO_INT_HIGH_LEV       0x1
-#define GPIO_INT_RISE_EDGE      0x2
-#define GPIO_INT_FALL_EDGE      0x3
-#define GPIO_INT_NONE           0x4
-
-#endif				/*  __ASM_ARCH_MXC_MX51_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mx5x.h b/arch/arm/plat-mxc/include/mach/mx5x.h
new file mode 100644
index 0000000..3316b08
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx5x.h
@@ -0,0 +1,579 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_MX5X_H__
+#define __ASM_ARCH_MXC_MX5X_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+/*!
+ * @file arch-mxc/mx5x.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup MSL_MX5
+ */
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*!
+ * This option is used to set or clear the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*!
+ * Define this option to specify we are using the newer SDMA module.
+ */
+#define MXC_SDMA_V2
+
+/*!
+ * The maximum frequency that the pixel clock can be at so as to
+ * activate DVFS-PER.
+ */
+#define DVFS_MAX_PIX_CLK	54000000
+
+ /*
+ * IRAM
+ */
+#define MX53_IRAM_BASE_ADDR		0xF8000000	/* internal ram */
+#define MX51_IRAM_BASE_ADDR		0x1FFE0000	/* internal ram */
+#define IRAM_PARTITIONS		16
+#define IRAM_SIZE		(IRAM_PARTITIONS*SZ_8K)	/* 128KB */
+
+#if defined(CONFIG_MXC_SECURITY_SCC2) \
+    || defined(CONFIG_MXC_SECURITY_SCC2_MODULE)
+#define SCC_IRAM_SIZE  SZ_16K
+#else
+#define SCC_IRAM_SIZE  0
+#endif
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE 0x6000
+#else
+#define SND_RAM_SIZE 0
+#endif
+
+#ifdef CONFIG_MXC_VPU_IRAM
+#define VPU_IRAM_SIZE  0x11000
+#else
+#define VPU_IRAM_SIZE 0
+#endif
+
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+#define USB_IRAM_SIZE	SZ_8K
+#else
+#define USB_IRAM_SIZE 0
+#endif
+
+/*
+ * NFC
+ */
+#define MX53_NFC_BASE_ADDR_AXI		0xF7FF0000	/* NAND flash AXI */
+#define MX51_NFC_BASE_ADDR_AXI		0xCFFF0000	/* NAND flash AXI */
+#define NFC_BASE_ADDR_AXI_VIRT	0xF9000000
+#define NFC_AXI_SIZE		SZ_64K
+
+/*
+ * Graphics Memory of GPU
+ */
+#define MX53_GPU_GMEM_BASE_ADDR		0xF8020000
+#define MX51_GPU_GMEM_BASE_ADDR		0x20000000
+#define GPU_BASE_ADDR			0x30000000
+#define MX53_GPU2D_BASE_ADDR		0x20000000
+#define MX51_GPU2D_BASE_ADDR		0xD0000000
+
+#define MX53_TZIC_BASE_ADDR		0x0FFFC000
+#define MX51_TZIC_BASE_ADDR_T01		0x8FFFC000
+#define MX51_TZIC_BASE_ADDR		0xE0000000
+#define TZIC_SIZE		SZ_16K
+
+#define DEBUG_BASE_ADDR	0x40000000
+/*MX53 + 0x2000000 */
+#define DEBUG_SIZE		SZ_1M
+#define ETB_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00001000)
+#define ETM_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00002000)
+#define TPIU_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00003000)
+#define CTI0_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00004000)
+#define CTI1_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00005000)
+#define CTI2_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00006000)
+#define CTI3_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00007000)
+#define CORTEX_DBG_BASE_ADDR	(DEBUG_BASE_ADDR + 0x00008000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR 	0x70000000
+#define SPBA0_BASE_ADDR_VIRT	0xFB100000
+#define SPBA0_SIZE		SZ_1M
+
+#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
+#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
+#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI1_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define ESAI_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00018000)
+#define MMC_SDHC3_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
+#define MMC_SDHC4_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00024000)
+#define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
+#define ASRC_BASE_ADDR		(SPBA0_BASE_ADDR + 0x0002C000)
+#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00030000)
+#define SLIM_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00034000)
+#define HSI2C_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00038000)
+#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
+
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_SDHC1	0x04
+#define SPBA_SDHC2	0x08
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI1	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_ESAI	0x18
+#define SPBA_SDHC3	0x20
+#define SPBA_SDHC4	0x24
+#define SPBA_SPDIF	0x28
+#define SPBA_ASRC	0x2C
+#define SPBA_ATA	0x30
+#define SPBA_SLIM	0x34
+#define SPBA_HSI2C	0x38
+#define SPBA_CTRL	0x3C
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR 	0x73F00000
+#define AIPS1_BASE_ADDR_VIRT	0xF7E00000
+#define AIPS1_SIZE		SZ_1M
+
+#define OTG_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00080000)
+#define GPIO1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00084000)
+#define GPIO2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00088000)
+#define GPIO3_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0008C000)
+#define GPIO4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00090000)
+#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
+#define WDOG1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00098000)
+#define WDOG2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0009C000)
+#define GPT1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
+#define SRTC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A4000)
+#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000A8000)
+#define EPIT1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000AC000)
+#define EPIT2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B0000)
+#define PWM1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B4000)
+#define PWM2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
+#define UART1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
+#define UART2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000C0000)
+#define CAN1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C8000)
+#define CAN2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000CC000)
+#define SRC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D0000)
+#define CCM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D4000)
+#define GPC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D8000)
+#define GPIO5_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000DC000)
+#define GPIO6_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000E0000)
+#define GPIO7_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000E4000)
+#define MX53_ATA_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000E8000)
+#define I2C3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000EC000)
+#define UART4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000F0000)
+
+#define DVFSPER_BASE_ADDR 	(GPC_BASE_ADDR + 0x1C4)
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_IRAM         30
+#define MXC_DMA_CHANNEL_SPDIF_TX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SPDIF_RX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI2_TX  (MXC_DMA_CHANNEL_IRAM + 1)
+#else				/*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_SSI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#endif				/*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_CSPI1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_ESAI MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_ESAI MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_ESAI MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI1_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI1_TX1 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI2_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI2_TX1 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI1_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI1_TX1 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI2_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI2_TX1 MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR	0x83F00000
+#define AIPS2_BASE_ADDR_VIRT	0xF7D00000
+#define AIPS2_SIZE		SZ_1M
+
+#define PLL1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
+#define PLL2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00084000)
+#define PLL3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00088000)
+#define PLL4_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0008C000)
+#define UART5_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00090000)
+#define AHBMAX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00094000)
+#define IIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
+#define CSU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0009C000)
+#define ARM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A0000)
+#define OWIRE_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000A4000)
+#define FIRI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A8000)
+#define CSPI2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000AC000)
+#define SDMA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B0000)
+#define SCC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B4000)
+#define ROMCP_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B8000)
+#define RTIC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000BC000)
+#define CSPI3_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
+#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C4000)
+#define I2C1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C8000)
+#define SSI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
+#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D0000)
+#define RTC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D4000)
+#define M4IF_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
+#define ESDCTL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D9000)
+#define WEIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DA000)
+#define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DB000)
+#define EMI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DBF00)
+#define MIPI_HSC_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DC000)
+#define MLB_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000)
+#define SSI3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E8000)
+#define ATA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E0000) /* MX51 */
+#define SIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000) /* MX51 */
+#define FEC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000EC000)
+#define TVE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F0000)
+#define VPU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F4000)
+#define SAHARA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000F8000)
+#define PTP_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000FC000)
+
+/*
+ * Memory regions and CS
+ */
+#define GPU_CTRL_BASE_ADDR	0x30000000
+#define MX51_IPU_CTRL_BASE_ADDR	0x40000000
+#define MX53_IPU_CTRL_BASE_ADDR	0x18000000
+#define CSD0_BASE_ADDR		0x90000000
+#define CSD1_BASE_ADDR		0xA0000000
+#define CS0_BASE_ADDR		0xB0000000
+#define CS1_BASE_ADDR		0xB8000000
+#define CS2_BASE_ADDR		0xC0000000
+#define CS3_BASE_ADDR		0xC8000000
+#define CS4_BASE_ADDR		0xCC000000
+#define CS5_BASE_ADDR		0xCE000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	(void __force __iomem *) \
+	((((x) >= (unsigned long)SPBA0_BASE_ADDR) && \
+	  ((x) < (unsigned long)SPBA0_BASE_ADDR + SPBA0_SIZE)) ? \
+	   SPBA0_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)AIPS1_BASE_ADDR) && \
+	  ((x) < (unsigned long)AIPS1_BASE_ADDR + AIPS1_SIZE)) ? \
+	   AIPS1_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)AIPS2_BASE_ADDR) && \
+	  ((x) < (unsigned long)AIPS2_BASE_ADDR + AIPS2_SIZE)) ? \
+	   AIPS2_IO_ADDRESS(x) : \
+	0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+#define SPBA0_IO_ADDRESS(x)  \
+	(((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS1_IO_ADDRESS(x)  \
+	(((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define MX53_BASE_ADDR(x) (cpu_is_mx53() ? (x) - 0x20000000 : (x))
+
+#define IS_MEM_DEVICE_NONSHARED(x)		0
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_SSI3_TX1				47
+#define DMA_REQ_SSI3_RX1				46
+#define DMA_REQ_SSI3_TX2_MX53			45
+#define DMA_REQ_SPDIF_MX51			45
+#define DMA_REQ_SSI3_RX2				44
+#define DMA_REQ_UART3_TX_MX53		43
+#define DMA_REQ_UART3_RX_MX53		42
+#define DMA_REQ_SLIM_B_TX				42 /* MX51 */
+#define DMA_REQ_UART3_TX_MX51		44
+#define DMA_REQ_UART3_RX_MX51		43
+#define DMA_REQ_ESAI_TX				41
+#define DMA_REQ_SDHC4_MX51			41
+#define DMA_REQ_ESAI_RX				40
+#define DMA_REQ_SDHC3					40 /* MX51 */
+#define DMA_REQ_CSPI_TX				39
+#define DMA_REQ_CSPI_RX				38
+#define DMA_REQ_ASRC_DMA6				37
+#define DMA_REQ_SSI3_TX2_MX51			37 /* MX51 */
+#define DMA_REQ_ASRC_DMA5				36
+#define DMA_REQ_IPU_MX51				36
+#define DMA_REQ_ASRC_DMA4				35
+#define DMA_REQ_ASRC_DMA3				34
+
+#define DMA_REQ_EPIT2					34 /* MX51 */
+#define DMA_REQ_CTI2_1					33 /* MX51 */
+#define DMA_REQ_EMI_WR_MX51			32
+#define DMA_REQ_EMI_WR_MX53			31
+#define DMA_REQ_CTI2_0					31
+
+#define DMA_REQ_ASRC_DMA2				33
+#define DMA_REQ_ASRC_DMA1				32
+#define DMA_REQ_EMI_RD					30
+#define DMA_REQ_SSI1_TX1				29
+#define DMA_REQ_SSI1_RX1				28
+#define DMA_REQ_SSI1_TX2				27
+#define DMA_REQ_SSI1_RX2				26
+#define DMA_REQ_SSI2_TX1				25
+#define DMA_REQ_SSI2_RX1				24
+#define DMA_REQ_SSI2_TX2				23
+#define DMA_REQ_SSI2_RX2				22
+/* I2C2 is shared w/SDHC2 on MX53 */
+#define DMA_REQ_SDHC2					21
+/* I2C1 is shared w/SDHC1 on MX53 */
+#define DMA_REQ_SDHC1					20
+#define DMA_REQ_UART1_TX				19
+#define DMA_REQ_UART1_RX				18
+
+#define DMA_REQ_UART2_TX				17 /* MX51 */
+#define DMA_REQ_UART2_RX				16 /* MX51 */
+#define DMA_REQ_GPU					15 /* MX51 */
+#define DMA_REQ_EXTREQ1				14 /* MX51 */
+
+#define DMA_REQ_UART5_TX				17
+#define DMA_REQ_UART5_RX				16
+#define DMA_REQ_SPDIF_TX				15
+#define DMA_REQ_SPDIF_RX				14
+/* UART2 is shared w/FIRI on MX53 */
+#define DMA_REQ_FIRI_TX					13
+#define DMA_REQ_FIRI_RX				12
+#define DMA_REQ_SDHC4_MX53			11
+
+#define DMA_REQ_HS_I2C_RX				11 /* MX51 */
+#define DMA_REQ_HS_I2C_TX				10 /* MX51 */
+/* SDHC3 is shared w/I2C3 on MX53 */
+#define DMA_REQ_I2C3					10
+#define DMA_REQ_HS_I2C_RX				11 /* MX51 */
+#define DMA_REQ_HS_I2C_TX				10 /* MX51 */
+#define DMA_REQ_CSPI2_TX				9
+#define DMA_REQ_CSPI2_RX				8
+#define DMA_REQ_CSPI1_TX				7
+#define DMA_REQ_CSPI1_RX				6
+#define DMA_REQ_IPU_MX53				5
+#define DMA_REQ_SLIM_B					5 /* MX51 */
+#define DMA_REQ_ATA_TX_END			4
+#define DMA_REQ_ATA_TX					3
+#define DMA_REQ_ATA_RX					2
+#define DMA_REQ_GPC					1
+#define DMA_REQ_VPU					0
+
+/*
+ * Interrupt numbers
+ */
+#define MXC_INT_BASE		0
+#define MXC_INT_RESV0		0
+#define MXC_INT_MMC_SDHC1	1
+#define MXC_INT_MMC_SDHC2	2
+#define MXC_INT_MMC_SDHC3	3
+#define MXC_INT_MMC_SDHC4	4
+#define MXC_INT_DAP		5
+#define MXC_INT_SDMA		6
+#define MXC_INT_IOMUX		7
+#define MXC_INT_NFC		8
+#define MXC_INT_VPU		9
+#define MXC_INT_IPU_ERR	10
+#define MXC_INT_IPU_SYN	11
+#define MXC_INT_GPU		12
+#define MXC_INT_UART4		13
+#define MXC_INT_USB_H1		14
+#define MXC_INT_EMI		15
+#define MXC_INT_USB_H2		16
+#define MXC_INT_USB_H3		17
+#define MXC_INT_USB_OTG	18
+#define MXC_INT_SAHARA_H0	19
+#define MXC_INT_SAHARA_H1	20
+#define MXC_INT_SCC_SMN	21
+#define MXC_INT_SCC_STZ	22
+#define MXC_INT_SCC_SCM	23
+#define MXC_INT_SRTC_NTZ	24
+#define MXC_INT_SRTC_TZ	25
+#define MXC_INT_RTIC		26
+#define MXC_INT_CSU		27
+#define MXC_INT_SATA		28
+#define MXC_INT_SLIM_B		28 /* MX51 */
+#define MXC_INT_SSI1		29
+#define MXC_INT_SSI2		30
+#define MXC_INT_UART1		31
+#define MXC_INT_UART2		32
+#define MXC_INT_UART3		33
+#define MXC_INT_RTC			34
+#define MXC_INT_PTP			35
+#define MXC_INT_CSPI1		36
+#define MXC_INT_CSPI2		37
+#define MXC_INT_CSPI		38
+#define MXC_INT_GPT			39
+#define MXC_INT_EPIT1		40
+#define MXC_INT_EPIT2		41
+#define MXC_INT_GPIO1_INT7	42
+#define MXC_INT_GPIO1_INT6	43
+#define MXC_INT_GPIO1_INT5	44
+#define MXC_INT_GPIO1_INT4	45
+#define MXC_INT_GPIO1_INT3	46
+#define MXC_INT_GPIO1_INT2	47
+#define MXC_INT_GPIO1_INT1	48
+#define MXC_INT_GPIO1_INT0	49
+#define MXC_INT_GPIO1_LOW	50
+#define MXC_INT_GPIO1_HIGH	51
+#define MXC_INT_GPIO2_LOW	52
+#define MXC_INT_GPIO2_HIGH	53
+#define MXC_INT_GPIO3_LOW	54
+#define MXC_INT_GPIO3_HIGH	55
+#define MXC_INT_GPIO4_LOW	56
+#define MXC_INT_GPIO4_HIGH	57
+#define MXC_INT_WDOG1		58
+#define MXC_INT_WDOG2		59
+#define MXC_INT_KPP		60
+#define MXC_INT_PWM1		61
+#define MXC_INT_I2C1		62
+#define MXC_INT_I2C2		63
+#define MXC_INT_I2C3		64
+#define MXC_INT_HS_I2C		64 /* MX51 */
+#define MXC_INT_MLB		65
+#define MXC_INT_ASRC		66
+#define MXC_INT_SPDIF_MX53	67
+#define MXC_INT_SIM_IPB		67
+#define MXC_INT_SIM_DAT		68
+#define MXC_INT_IIM		69
+#define MXC_INT_ATA		70
+#define MXC_INT_CCM1		71
+#define MXC_INT_CCM2		72
+#define MXC_INT_GPC1		73
+#define MXC_INT_GPC2		74
+#define MXC_INT_SRC		75
+#define MXC_INT_NM		76
+#define MXC_INT_PMU		77
+#define MXC_INT_CTI_IRQ		78
+#define MXC_INT_CTI1_TG0	79
+#define MXC_INT_CTI1_TG1	80
+#define MXC_INT_ESAI		81
+#define MXC_INT_CAN1		82
+#define MXC_INT_CAN2		83
+#define MXC_INT_MCG_ERR		81 /* MX51 */
+#define MXC_INT_MCG_TMR		82 /* MX51 */
+#define MXC_INT_MCG_FUNC		83 /* MX51 */
+#define MXC_INT_GPU2_IRQ	84
+#define MXC_INT_GPU2_BUSY	85
+#define MXC_INT_UART5		86
+#define MXC_INT_FEC		87
+#define MXC_INT_OWIRE		88
+#define MXC_INT_CTI1_TG2	89
+#define MXC_INT_SJC		90
+#define MXC_INT_SPDIF_MX51		91
+#define MXC_INT_TVE		92
+#define MXC_INT_FIRI		93
+#define MXC_INT_PWM2		94
+#define MXC_INT_SLIM_EXP		95
+#define MXC_INT_SSI3		96
+#define MXC_INT_EMI_BOOT		97
+#define MXC_INT_CTI1_TG3	98
+#define MXC_INT_SMC_RX			99
+#define MXC_INT_VPU_IDLE	100
+#define MXC_INT_EMI_NFC	101
+#define MXC_INT_GPU_IDLE	102
+#define MXC_INT_GPIO5_LOW	103
+#define MXC_INT_GPIO5_HIGH	104
+#define MXC_INT_GPIO6_LOW	105
+#define MXC_INT_GPIO6_HIGH	106
+#define MXC_INT_GPIO7_LOW	107
+#define MXC_INT_GPIO7_HIGH	108
+
+/* gpio and gpio based interrupt handling */
+#define GPIO_DR                 0x00
+#define GPIO_GDIR               0x04
+#define GPIO_PSR                0x08
+#define GPIO_ICR1               0x0C
+#define GPIO_ICR2               0x10
+#define GPIO_IMR                0x14
+#define GPIO_ISR                0x18
+#define GPIO_INT_LOW_LEV        0x0
+#define GPIO_INT_HIGH_LEV       0x1
+#define GPIO_INT_RISE_EDGE      0x2
+#define GPIO_INT_FALL_EDGE      0x3
+#define GPIO_INT_NONE           0x4
+
+#endif				/*  __ASM_ARCH_MXC_MX5X_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index efe4323..5603581 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -33,6 +33,7 @@
 #define MXC_CPU_MX35		35
 #define MXC_CPU_MX37		37
 #define MXC_CPU_MX51		51
+#define MXC_CPU_MX53		53
 
 #ifndef __ASSEMBLY__
 extern unsigned int __mxc_cpu_type;
@@ -134,6 +135,18 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mx51()		(0)
 #endif
 
+#ifdef CONFIG_ARCH_MX53
+# ifdef mxc_cpu_type
+#  undef mxc_cpu_type
+#  define mxc_cpu_type __mxc_cpu_type
+# else
+#  define mxc_cpu_type MXC_CPU_MX53
+# endif
+# define cpu_is_mx53()		(mxc_cpu_type == MXC_CPU_MX53)
+#else
+# define cpu_is_mx53()		(0)
+#endif
+
 #define cpu_is_mx32()		(0)
 
 /*
@@ -169,6 +182,7 @@ cpu_rev(cpu_is_mx31);
 cpu_rev(cpu_is_mx35);
 cpu_rev(cpu_is_mx37);
 cpu_rev(cpu_is_mx51);
+cpu_rev(cpu_is_mx53);
 
 
 #include <linux/types.h>
@@ -602,7 +616,7 @@ struct cpu_wp {
 	u32 cpu_podf;
 };
 
-#ifndef CONFIG_ARCH_MX51
+#ifndef CONFIG_ARCH_MX5
 struct cpu_wp *get_cpu_wp(int *wp);
 #endif
 
@@ -631,6 +645,7 @@ void gpio_deactivate_esai_ports(void);
 #define CSCR_A(n) (IO_ADDRESS(WEIM_BASE_ADDR) + n * 0x10 + 0x8)
 #endif
 
+#define cpu_is_mx5()	(cpu_is_mx51() || cpu_is_mx53())
 #define cpu_is_mx3()	(cpu_is_mx31() || cpu_is_mx35())
 #define cpu_is_mx2()	(cpu_is_mx21() || cpu_is_mx27())
 
diff --git a/arch/arm/plat-mxc/include/mach/timex.h b/arch/arm/plat-mxc/include/mach/timex.h
index 46ebeab..9ab45aa 100644
--- a/arch/arm/plat-mxc/include/mach/timex.h
+++ b/arch/arm/plat-mxc/include/mach/timex.h
@@ -1,6 +1,6 @@
 /*
  *  Copyright (C) 1999 ARM Limited
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -28,7 +28,7 @@
 #define CLOCK_TICK_RATE		16625000
 #elif defined CONFIG_ARCH_MX37
 #define CLOCK_TICK_RATE		8000000
-#elif defined CONFIG_ARCH_MX51
+#elif defined CONFIG_ARCH_MX5
 #define CLOCK_TICK_RATE		8000000
 #endif
 
diff --git a/arch/arm/plat-mxc/include/mach/uncompress.h b/arch/arm/plat-mxc/include/mach/uncompress.h
index 8314faf..4041944 100644
--- a/arch/arm/plat-mxc/include/mach/uncompress.h
+++ b/arch/arm/plat-mxc/include/mach/uncompress.h
@@ -48,6 +48,7 @@ unsigned int system_rev;
 
 static void putc(int ch)
 {
+#ifndef CONFIG_ARCH_MX53
 	static unsigned long serial_port = 0;
 
 	if (unlikely(serial_port == 0)) {
@@ -66,6 +67,7 @@ static void putc(int ch)
 		barrier();
 
 	UART(TXR) = ch;
+#endif
 }
 
 #define flush() do { } while (0)
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index b0fd53c..b411360 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -2516,3 +2516,4 @@ tx51			MACH_TX51		TX51			2529
 dolby_cat1021		MACH_DOLBY_CAT1021	DOLBY_CAT1021		2530
 mx28evk			MACH_MX28EVK		MX28EVK			2531
 mx23evk			MACH_MX23EVK		MX23EVK			2629
+mx53_evk                MACH_MX53_EVK	        MX53_EVK		2716
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
index 916b431..1a00707 100644
--- a/drivers/video/mxc/Makefile
+++ b/drivers/video/mxc/Makefile
@@ -18,4 +18,4 @@ obj-$(CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL)   += mxcfb_claa_wvga.o
 obj-$(CONFIG_FB_MXC_TVOUT_CH7024)           += ch7024.o
 obj-$(CONFIG_FB_MXC_TVOUT_TVE)              += tve.o
 obj-$(CONFIG_FB_MXC_CH7026)		    		+= mxcfb_ch7026.o
-obj-$(CONFIG_FB_MODE_HELPERS)				+= mxc_edid.o
+#obj-$(CONFIG_FB_MODE_HELPERS)				+= mxc_edid.o
-- 
1.5.4.4

